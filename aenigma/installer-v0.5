#!/bin/bash

echo "${g}aenigma.xyz ejabberd installer by openspace [https://github.com/openspace42/aenigma]${x}"
echo
echo "aenigma v0.5"
echo

sourcedir=/root/aenigma # Don't change! | No trailing slash!
installdir=/root/os-aenigma # Don't change! | No trailing slash!
tlsdir=/etc/ssl/aenigma # Don't change! | No trailing slash!
mkdir -p $tlsdir

r=`tput setaf 1`
g=`tput setaf 2`
x=`tput sgr0`
b=`tput bold`

# warning kept in case of future need

# echo "- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -"
# echo
# echo "${r}WARNING:"
# echo
# read -p "Have you read and understood the above, and do you whish to continue now? (y/N): " confirm && [[ $confirm == [yY] ]] || exit 1
# echo
# echo "Confirmed. Now continuing..."
# echo
# echo "- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -"
# echo

if [ -d $installdir ]
then
	previnstall=y
	echo "${g}Found a previous install of aenigma.${x}"
	echo
	read -p "Skip the introduction on XMPP basics? (Y/n): " -n 1 -r
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "Ok, continuing..."
		echo
		skipintro=y
	else
		echo
		skipintro=n
	fi
else
	mkdir -p $installdir
	previnstall=n
	skipintro=n
fi

if [ $skipintro = "n" ]
then

# ///

echo "0] First of all, a little introduction on how XMPP actually works"
echo
echo "XMPP works a little bit like email. You can have a domain [amsterdamhacklab.xyz] and receive email for that domain on a server located at mx01.amsterdamhacklab.xyz, by using the appropriate DNS configuration, and also have other servers [webserver, mapserver, etc...] on other subdomains. In that case, a DNS "MX" record tells sending servers to direct mail intended for amsterdamhacklab.xyz to mx01.amsterdamhacklab.xyz."
echo
echo "In the same way, the XMPP server for amsterdamhacklab.xyz can be located at xmpp.amsterdamhacklab.xyz and a DNS "SRV" record tells any sending servers that XMPP for that domain [i.e. a message directed to mark@amsterdamhacklab.xyz] is handled by the server located at xmpp.amsterdamhacklab.xyz."
echo
read -p "[press enter to continue reading...]"
clear

echo "1] Now, if the domain for which you're setting up your new aenigma server is a domain connected to a bigger project, for which XMPP is just another way of getting in touch with you, definitely set things up like this by using the first option."
echo
echo "This will give you working @domain.tld xmpp account addresses, but the aenigma server will reside at subdomain.domain.tld, as in the following example."
echo
echo "Main domain:          amsterdamhacklab.xyz."
echo "Website:              amsterdamhacklab.xyz / www.amsterdamhacklab.xyz [hosted by another server]."
echo "Your XMPP address:    mark@amsterdamhacklab.xyz."
echo "XMPP server:          xmpp.amsterdamhacklab.xyz"
echo
echo "PROs:                 a] clean addresses [no mark@xmpp.amsterdamhacklab.xyz stuff]"
echo "                      b] more logical setup."
echo "CONs:                 a] requires TLS [SSL] certificate for the top level domain [amsterdamhacklab.xyz]"
echo "                         to be copied over to your new aenigma server [not hard at all, can be automated, see below]"
echo
read -p "[press enter to continue reading...]"
clear

echo "2] If instead your domain [i.e. aenigmapod42.im] is only intended to be used for your shiny new aenigma server, and you don't need other, different servers [a webserver for instance] managing different aspects of your project, you can do as so:"
echo
echo "Set your aenigma server to be located directly at your top level domain, therefore responding directly to amsterdamhacklab.xyz."
echo
echo "Your server hostname:  aenigmapod42.im"
echo "Your addresses:        mark@aenigmapod42.im."
echo
echo "PROs:                  a] clean addresses"
echo "                       b] no separate TLS certificate needed."
echo "CONs:                  a] your domain must be logically dedicated to your aenigma server"
echo "                          and not to a wider project."
echo
read -p "[press enter to continue reading...]"
clear

echo "3] In a third, although NOT suggested case, if you have a domain tied to a wider project [i.e. amsterdamhacklab.xyz] but you don't mind having longer and more complex XMPP account addresses [like mark@xmpp.amsterdamhacklab.xyz], you can choose the third option."
echo
echo "Your server hostname:  subdomain.domain.tld"
echo "Your addresses:        mark@subdomain.domain.tld."
echo
echo "PROs:                  a] domain can be logically connected to other stuff and different servers"
echo "                          with no separate TLS certificate needed."
echo "CONs:                  a] longer and more complex addresses"
echo "                       b] not logically 'clean'."
echo
read -p "[press enter to continue reading...]"
clear

echo "Now that you know how XMPP works, make your choice and let's get your brand new aenigma server up and running!"
echo
echo "----------------"
echo

# \\\

fi

if [ -f $installdir/configoption ]
then
	prevconfigoption="$(cat $installdir/configoption)"
	case "$prevconfigoption" in
	    1|2|3)
		validprevconfigoption=y
		;;
	    *)
		validprevconfigoption=n
		;;
	esac
else
	touch $installdir/configoption
	validprevconfigoption=n
fi

if [ $validprevconfigoption = "y" ]
then
	echo "${g}You previously chose configuration option | $prevconfigoption |${x}"
	echo
	read -p "Keep this option for this installation as well? (Y/n): " -n 1 -r
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		configoption=$prevconfigoption
	else
		echo
		configoption=notyetset
	fi
else
	configoption=notyetset
fi

if [ $configoption = "notyetset" ]
then
	choice='Please select your desired configuration option: '
	echo $choice
	options=("configuration 1" "configuration 2" "configuration 3" "exit")
	select opt in "${options[@]}"
	do
	    echo
	    case $opt in
		"configuration 1")
		    echo "1" > $installdir/configoption
		    configoption=1
		    break
		    ;;
		"configuration 2")
		    echo "2" > $installdir/configoption
		    configoption=2
		    break
		    ;;
		"configuration 3")
		    echo "3" > $installdir/configoption
		    configoption=3
		    break
		    ;;
		"exit")
		    echo "Exiting..."
		    echo
		    exit
		    ;;
		*)  echo "Invalid option. Retry..."
		    echo
		    ;;
	    esac
	done
fi

if [ -f $installdir/domain ]
then
	prevdomain="$(cat $installdir/domain)"
else
	prevdomain="nx"
fi

if [ ! $configoption = "3" ]
then

	echo "Ok, you've chosen option $configoption."
	echo
	if [ ! $prevdomain = "nx" ]
	then
		echo "${g}The domain used for your previous aenigma installation is:${x}"
		echo
		echo " | $prevdomain |"
		echo
		read -p "Keep this domain for this installation as well? (Y/n): " -n 1 -r
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]
		then
			echo "Ok, using previous domain: | $prevdomain |"
			echo
			domain=$prevdomain
			changedomain=n
		else
			echo
			echo "Ok, changing domain..."
			echo
			changedomain=y
		fi
	else
		changedomain=y
	fi

	if [ $changedomain = "y" ]
	then
		defined=n
		until [ $defined = "y" ]
		do
			newdomain=""
			until [ ! $newdomain = "" ]
			do
				read -p "Now set your top level domain, which will also be the part after the @ in your XMPP account addresses: " newdomain
				echo
			done
			valid=n
			until [ $valid = "y" ]
			do
				read -n 1 -p "Is | $newdomain | correct? (Y/n/e[xit]) " answer;
				case $answer in
				"")
					echo
					valid=y
					defined=y
					;;
				y)
					echo -e "\n"
					valid=y
					defined=y
					;;
				n)
					echo -e "\n"
					echo "Ok, then please try again..."
					echo
					valid=y
					defined=n
					;;
				e)
					echo -e "\n"
		        		echo "Exiting..."
		        		echo
		        		exit
		        		;;
				*)
					echo -e "\n"
					echo "Invalid option. Retry..."
		        		echo
					valid=n
				defined=n
			        ;;
				esac
			done
		done
	echo $newdomain > $installdir/domain
	echo "New hostname set to | $newdomain |"
	echo
	domain="$(cat $installdir/domain)"
	fi

else

	echo "Ok, you've chosen option 3."
	echo
	echo "Your domain [the part after the @ in your XMPP account addresses] will match your server hostname."
	echo

fi
sleep 1
clear

currhostname="$(cat /etc/hostname)"

if [ ! $configoption = "2" ]
then

	if [ $configoption = "1" ]
	then
		echo "Your hostname must be a third level domain [subdomain] of either $domain or another domain."
		echo
	elif [ $configoption = "3" ]
	then
		echo "Your hostname must be a third level domain [subdomain] of your main domain."
		echo
	fi

	echo "${g}Your current hostname is:${x}"
	echo
	echo " | $currhostname |"
	echo

	if [ $configoption = "3" ]
	then
		echo "Make sure it is a subdomain of your main domain, and is it what you want it to be."
		echo
	fi

	read -p "Keep this hostname? (Y/n): " -n 1 -r
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "Ok, leaving hostname set to | $currhostname |"
		echo
		changehostname=n
		hostname=$currhostname
	else
		echo
		echo "Ok, changing hostname..."
		echo
		changehostname=y
	fi

	if [ $changehostname = "y" ]
	then
		defined=n
		until [ $defined = "y" ]
		do
			newhostname=""
			until [ ! $newhostname = "" ]
			do
				if [ $configoption = "1" ]
				then
					read -p "Now set your hostname, which must be a third level domain [subdomain] of either $domain or another domain: " newhostname
					echo
				elif [ $configoption = "3" ]
				then
					echo "Keep in mind that your hostname will also become your domain [the part after the @ in your XMPP account addresses]."
					echo
					read -p "Now set your hostname, which must be a third level domain [subdomain] of your main domain: " newhostname
					echo
				fi
			done
			valid=n
			until [ $valid = "y" ]
			do
				read -n 1 -p "Is | $newhostname | correct? (Y/n/e[xit]) " answer;
				case $answer in
				"")
					echo
					valid=y
					defined=y
					;;
				y)
					echo -e "\n"
					valid=y
					defined=y
					;;
				n)
					echo -e "\n"
					echo "Ok, then please try again..."
					echo
					valid=y
					defined=n
					;;
				e)
					echo -e "\n"
		        		echo "Exiting..."
		        		echo
		        		exit
		        		;;
				*)
					echo -e "\n"
					echo "Invalid option. Retry..."
		        		echo
					valid=n
				defined=n
			        ;;
				esac
			done
		done
	echo $newhostname > /etc/hostname
	echo "New hostname set to | $newhostname |"
	echo
	hostname="$(cat /etc/hostname)"
	fi

	if [ $configoption = "3" ]
	then
		domain=$hostname
	fi

else

	echo "Your hostname must be identical to your domain: $domain."
	echo
	echo "Your current hostname is:"
	echo
	echo " | $currhostname |"
	echo
	if [ $currhostname = $domain ]
	then
		echo "${g}Your hostname matches your domain, all good!${x}"
		echo
	else
		echo "${r}Your hostname does NOT match the domain you've specified.${x}"
		echo
		echo "Having chosen option 2, they must be identical."
		echo
		read -p "Do you want to set your hostname to match your domain? (Y/n): " -n 1 -r
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]
		then
			echo "Ok, setting hostname to match domain."
			echo
			echo $domain > /etc/hostname
			echo "New hostname set to | $domain |"
			echo
		else
			echo
			echo "Not changing hostname. Exiting..."
			echo
			exit
		fi
	fi

	hostname="$(cat /etc/hostname)"

fi
sleep 1
clear

echo "----------------"
echo
echo "${b}To make sure everything is correct:${x}"
echo
echo "1] Your XMPP domain [the part after the @ in your XMPP account addresses] will be:"
echo
echo "${b} | $domain | ${x}"
echo
echo "2] And therefore an XMPP account address will look as follows:"
echo
echo "${b} | mark@$domain | ${x}"
echo
echo "3] Your hostname, the location on the internet of this server, will be:"
echo
echo "${b} | $hostname | ${x}"
echo
echo "4] And therefore your aenigma admin panel will be located at:"
echo
echo "${b} | https://$hostname | ${x}"
echo
echo "----------------"
echo

read -p "Does everything look all right? (Y/n): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Nn]$ ]]
then
	echo "Ok, continuing."
	echo
	touch $installdir/domain
	echo "$domain" > $installdir/domain
else
	echo "Ok, no worries. You can re-run this script right now and make the correct choices. Exiting..."
	echo
	exit
fi
clear

echo "${b}Is this server reachable [or intended to be reachable] from the public internet?${x}"
echo
echo "[Answer no if it is only intended for local network usage (i.e. NOT reachable from outside)]"
echo
read -p "Set up the server for ${b}public internet access${x}? (Y/n): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Nn]$ ]]
then
  echo "Ok, continuing in public internet accessibilty mode..."
  echo
  deptype=internet
  sleep 1
else
  echo
  echo "Ok, continuing in local network accessibility mode..."
  echo
  echo "${b}You will need to ensure you have a local DNS server that serves all clients AND this machine as well.${x}"
  echo
  echo "Open a shell to this machine and make sure it's using your local DNS server now before continuing."
  echo
  echo "${b}The DNS checks we'll be running shortly WILL FAIL if this machine's DNS settings don't point it to your local DNS server.${x}"
  echo
  deptype=local
  read -p "[press enter to continue...]"
fi
clear

if [ $deptype = "internet" ]
then
	thisipv4="$(dig +short myip.opendns.com @resolver1.opendns.com)"
	echo "Now testing IPv6 connectivity..."
	echo
	ipv6pingaddr="2001:4860:4860::8888"
	if ping6 -q -c 1 -W 1 $ipv6pingaddr >/dev/null
	then
		echo "${g}IPv6 connectivity good.${x}"
		echo
		ipv6avail=y
	else
		counter=4
		pingacquired=y
		echo
		until ping6 -c1 $ipv6pingaddr &>/dev/null
		do
		echo "Waiting $counter more seconds for IPv6 connectivity..."
		echo
		if [ $counter = 0 ]
		then
			pingacquired=n
			break
		fi
		counter=$(($counter - 1))
		sleep 1
		done
		if [ $pingacquired = "y" ]
		then
			echo "${g}IPv6 connectivity acquired.${x}"
			echo
			ipv6avail=y
		else
			echo "${r}IPv6 connectivity not found.${x}"
			echo
			ipv6avail=n
		fi
	fi
	if [ $ipv6avail = "y" ]
	then
		thisipv6="$(dig +short -6 myip.opendns.com aaaa @resolver1.ipv6-sandbox.opendns.com)"
		echo "Your IPv6 global [public] address appears to be: | $thisipv6 |"
		echo
	fi
	echo "Finished testing IPv6 connectivity."
	echo
else
	ipv6avail=n
	thisipv4="$(ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1')"
	echo "Your machine's primary interface's IPv4 address appears to be: | $thisipv4 |"
	echo
	echo "${b}If this is not your machine's correct primary interface's IPv4 address [i.e. with a private subnet address like 10., 192.168, 172.16, etc...] you must set it correctly now.${x}"
	echo
	read -p "That said, is this your machine's correct primary interface's IPv4 address? (Y/n): " -n 1 -r
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "Ok, basing install on local IPv4 address: | $thisipv4 |"
		echo
	else
		echo
		read -p "Ok, then specify now your machine's correct primary interface's IPv4 address: " newthisipv4
		echo
		read -p "Is | $newthisipv4 | correct? (y/N): " confirm && [[ $confirm == [yY] ]] || exit 1
		echo
		thisipv4=$newthisipv4
		echo "Ok, basing install on newly set local IPv4 address: | $thisipv4 |"
		echo
	fi
fi
sleep 1
clear



additionalTLScertmode="notset"

if [ $configoption = 1 ]
then

	additionalTLScertmode="elsewhere"
	echo "Since you've chosen option 1, your domain is different from your hostname."
	echo
	echo "Therefore, we have to set some DNS 'SRV' records which will direct XMPP connections for $domain accounts to this server."
	echo
	echo "Make sure your DNS settings are as follows:"
	echo
	echo " | _jabber._tcp.$domain         SRV    0 0 5269 $hostname. |"
	echo " | _xmpp-server._tcp.$domain    SRV    0 0 5269 $hostname. |"
	echo " | _xmpp-client._tcp.$domain    SRV    0 0 5222 $hostname. |"
	echo
	read -p "[press enter to continue when finished setting your DNS SRV records...]"
	clear

	echo "Now it's time to set up the TLS [SSL] certificate that is valid for $domain."
	echo
  echo "The certificate file required for aenigma must be an all-in-one private key + certificate + chain file."
  echo
  echo "This means the file must include, in this order, the following:"
  echo
  echo "1] Private key; 2] Leaf [server] cert; 3] Certification Chain [Intermediate cert(s) + Root cert]"
  echo
  read -p "[press enter to continue reading...]"
  clear

  echo "This certificate, if it already exists, resides on the server responding to $domain"
  echo
	echo "This is usually a web server, but check your domain/hosting infrastructure to see what server it is."
	echo
	echo "This is the IP to which your bare domain $domain is pointing to:"
	echo
	dig +noall +answer $domain
	echo
  echo "[If you see no output, then it might be misconfigured or not configured at all.]"
  echo
  read -p "[press enter to continue reading...]"
  clear

	read -p "That said, is there ANOTHER [running] server that responds to $domain? (Y/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]
        then
		read -p "Ok, does this server have a configured TLS [SSL] certificate up and running on it? (Y/n): " -n 1 -r
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
			read -p "Ok, is this a Linux server? (Y/n): " -n 1 -r
                        echo
                        if [[ ! $REPLY =~ ^[Nn]$ ]]
                        then
				read -p "Ok, is this a Letsencrypt certificate? [if unsure, answer no] (Y/n): " -n 1 -r
	                	echo
	                	if [[ ! $REPLY =~ ^[Nn]$ ]]
	                	then
					echo "Very good, therefore access that server as root [or using sudo], and download this script in the root user's home directory:"
					echo
					echo "https://github.com/nikksno/LetsEncrypt-Cert-Push"
					echo
					echo "Now configure it to push its LE TLS cert to this server by following the instructions."
					echo
				else
					echo
					echo "Ok, no problem, you can adapt this script:"
					echo
					echo "https://github.com/nikksno/LetsEncrypt-Cert-Push"
                                        echo
					echo "To have it fetch and concatenate your existing private key, TLS cert, and certification chain on the other server and push the resulting all-in-one file here periodically."
					echo
					echo "Follow the instructions and adapt the paths to the existing TLS certs and private key."
					echo
				fi
			else
				echo "Ok, no problem, find your TLS certificate and related files on the other server and make a simple script to periodically concatenate your existing private key, TLS cert, and certification chain on the other server and send the resulting all-in-one file over to this server, or copy it here manually [and remember to copy it over again every time you renew the cert!]."
				echo
			fi
		else
			read -p "Ok, no problem. Is this server a linux server? (Y/n): " -n 1 -r
                        echo
                        if [[ ! $REPLY =~ ^[Nn]$ ]]
                        then
				echo "Very good. You can therefore install letsencrypt on the other server, generate a cert for $domain, and copy it over here with this script:"
				echo
				echo "https://github.com/nikksno/LetsEncrypt-Cert-Push"
				echo
			else
				echo "Ok, no problem, get a TLS certificate, install it and its related files on the other server, and make a simple script to periodically concatenate your existing private key, TLS cert, and certification chain on the other server and send the resulting all-in-one file over to this server, or copy it here manually [and remember to copy it over again every time you renew the cert!]."
				echo
			fi
		fi
		read -p "Now, in whatever way you've installed or copied to this server the all-in-one TLS cert file for $domain, specify its absolute path [i.e. /home/username/domain.pem] on this server now: " domtlscertloc
		echo
		read -p "Is | $domtlscertloc | correct? (y/N): " confirm && [[ $confirm == [yY] ]] || exit 1
		echo
	else
		echo
		echo "Ok, so we'll point $domain to this server and provision a TLS certificate for it on this very server."
		echo
		echo "If you ever add a new server to respond to $domain [a webserver for instance], simply make sure you periodically send the TLS certificate you'll generate on the new server back here, either by using this script on the new server:"
		echo
		echo "https://github.com/nikksno/LetsEncrypt-Cert-Push"
		echo
		echo "[or an adaptation of it] or by doing some other manual scripting that periodically fetches the TLS cert and all of its related files on the other server, concatenates your private key, TLS cert, and certification chain on the other server, and sends the resulting all-in-one file over to this server, [and does so again every time you renew the cert!]."
		echo
		echo "For now, no need to worry about that."
		echo
		read -p "[press enter to continue reading...]"
		clear

		echo "Let's point $domain and www.$domain to this server for the time being."
		echo
		echo "This is required for the TLS certificate we'll be generating shortly on this server."
		echo
		echo "The DNS checks we'll be running shortly will guide you through these settings as well."
		echo

		additionalTLScertmode="here"

  fi

fi
sleep 1
clear

if [ $additionalTLScertmode = "here" ]
then
	declare -a dnsarray=(
                "hostname"
                "domain"
		"XMPP"
                )
else
        declare -a dnsarray=(
                "hostname"
		"XMPP"
                )
fi

# ///

if [ $ipv6avail = "y" ]
then
        declare -a iparray=(
                "v4"
                "v6"
                )
else
        declare -a iparray=(
                "v4"
                )
fi

for dnstype in "${dnsarray[@]}"
do

if [ $dnstype = "hostname" ]
then
	dnschecktype=$hostname
else
	dnschecktype=$domain
fi

for ipversion in "${iparray[@]}"
do

echo "Now let's make sure your $dnstype's IP$ipversion DNS settings are correct."
echo

if [ $dnstype = "domain" ]
then
	declare -A digarray=(
		[HN]=""
		[www]="www."
	)
elif [ $dnstype = "XMPP" ]
then
	declare -A digarray=(
		[xc]="xc."
		[xu]="xu."
		[xe]="xe."
		[xp]="xp."
		[xi]="xi."
	)
elif [ $dnstype = "hostname" ]
then
	declare -A digarray=(
		[HN]=""
		[www]="www."
	)
fi

# [xc]="XMPP messaging groups [aka conferences / MUCs in XMPP lingo]."
# [xu]="XMPP HTTP uploads."
# [xe]="the ejabberd MOD_ECHO module."
# [xp]="the ejabberd MOD_PUBSUB module."
# [xi]="join channels on IRC servers."

digarrayiter=0

for i in "${!digarray[@]}"
do

	digarrayiter=$(($digarrayiter + 1))
	echo "$digarrayiter] Now checking the ${digarray[$i]}$dnschecktype DNS record in IP$ipversion..."
	echo
	sleep 1

	accept=n
	until [ $accept = "y" ]
	do

	if [ $ipversion = "v4" ]
	then
                	thisip=$thisipv4
			digresult="$(getent ahostsv4 ${digarray[$i]}$dnschecktype. | head -1 |sed 's/ .*//')"
                	rectype="A"
	else
                	thisip=$thisipv6
                	digresult="$(getent ahostsv6 ${digarray[$i]}$dnschecktype. | grep -v $thisipv4 | head -1 | sed 's/ .*//')"
                	rectype="AAAA"
	fi

			if [ -z "$digresult" ]
			then
				echo "${r}The ${digarray[$i]}$dnschecktype IP$ipversion record does NOT appear to be at all set.${x}"
				echo
				echo "Please ensure you set your DNS record as follows:"
				echo
				echo -e "| ${digarray[$i]}$dnschecktype\t\t\t$rectype\t$thisip |"
				echo
				result=notset
			else
				if [ $digresult = $thisip ]
				then
					echo "${g}The ${digarray[$i]}$dnschecktype IP$ipversion record appears to resolve correctly to this server.${x}"
					echo
					echo -e "| ${digarray[$i]}$dnschecktype\t\t\t$rectype\t$thisip |"
					echo
					result=ok
					sleep 1
				else
					echo "${r}The ${digarray[$i]}$dnschecktype IP$ipversion record does NOT appear to correctly resolve to this server.${x}"
					echo
					echo "This is the result of a DNS query for ${digarray[$i]}$dnschecktype:"
					echo
					echo $digresult
					echo
					echo "Please set it instead to:"
					echo
					echo -e "| ${digarray[$i]}$dnschecktype\t\t\t$rectype\t$thisip |"
					echo
					result=incorrect
				fi
			fi

			if [ ! $result = "ok" ]
			then
				valid=n
				until [ $valid = "y" ]
				do
					read -n 1 -p "Test again? (${b}Y${x}[es]/${b}s${x}[kip]/${b}e${x}[xit]) " answer;
					case $answer in
					"")
						echo
						valid=y
						accept=n
						;;
					y)
						echo -e "\n"
						valid=y
						accept=n
						;;
					s)
						echo -e "\n"
						echo "Skipping DNS check for this record..."
						echo
						valid=y
						accept=y
						;;
					e)
						echo -e "\n"
	        				echo "Exiting..."
	        				echo
	        				exit
	        				;;
					*)
						echo -e "\n"
						echo "Invalid option. Retry..."
	        				echo
						valid=n
						accept=n
			        		;;
					esac
				done
			else
				accept=y
			fi
			clear
		done
	done

	echo "Finished checking your $dnstype's IP$ipversion DNS settings."
	echo
	sleep 1

done

# \\\

done



echo "Now setting UFW rules..."
echo

ufw allow 5222
ufw allow 5269
ufw allow 5444
ufw allow 80
ufw allow 443

echo
ufw status

echo "Finished setting UFW rules."
echo
sleep 1

echo "Now installing easyengine..."
echo
wget -qO ee rt.cx/ee && sudo bash ee
echo
echo "Finished installing easyengine."
echo
sleep 1

echo "Now creating easyengine site for $hostname, generating its TLS certificate, and installing it..."
echo
ee site create $hostname
echo
echo "Finished creating easyengine site for $hostname."
echo
sleep 1

echo "Now setting custom nginx config for $hostname..."
echo
sed -i "s/example.im/${hostname}/g" $sourcedir/conf/nginx/hostname.conf
cp $sourcedir/conf/nginx/hostname.conf /etc/nginx/sites-available/$hostname
service nginx reload
echo "Finished setting custom nginx config for $hostname."
echo
sleep 1

echo "Now updating easyengine site $hostname to TLS encrypted with LetsEncrypt..."
echo
ee site update $hostname  --le
echo
echo "Finished updating easyengine site $hostname to TLS encrypted with LetsEncrypt..."
echo

echo "Now adding IPv6 support to the HTTPS version of the $hostname site..."
echo
sed -i "s/example.im/${hostname}/g" $sourcedir/conf/nginx/ssl-hostname.conf
cp $sourcedir/conf/nginx/ssl-hostname.conf /var/www/$hostname/conf/nginx/ssl.conf
echo "Finished adding IPv6 support to the HTTPS version of the $hostname site..."
echo

echo "Now adding IPv6 support to the HTTPS redirect for the $hostname site..."
echo
sed -i "s/example.im/${hostname}/g" $sourcedir/conf/nginx/force-ssl-hostname.conf
cp $sourcedir/conf/nginx/force-ssl-hostname.conf /etc/nginx/conf.d/force-ssl-$hostname.conf
echo "Finished adding IPv6 support to the HTTPS redirect for the $hostname site..."
echo

echo "Now creating all-in-one TLS file for $hostname for ejabberd..."
echo
touch $tlsdir/hostname.pem
cat /etc/letsencrypt/live/$hostname/privkey.pem > $tlsdir/hostname.pem
cat /etc/letsencrypt/live/$hostname/fullchain.pem >> $tlsdir/hostname.pem
echo "Finished creating all-in-one TLS file for $hostname for ejabberd."
echo
sleep 1

echo "Now setting index.html in docroot for $hostname..."
echo
cp $sourcedir/conf/web/hostname/index.html /var/www/$hostname/htdocs/
echo "Finished setting index.html in docroot for $hostname."
echo
sleep 1

if [ $additionalTLScertmode = "here" ]
then

  echo "Since you've chosen to provision a TLS certificate for $domain on this server, now we're now going to do so."
  echo

  echo "Now creating easyengine site for $domain, generating its TLS certificate, and installing it..."
  echo
  ee site create $domain
  echo
  echo "Finished creating easyengine site for $domain."
  echo
  sleep 1

  echo "Now setting custom nginx config for $domain..."
  echo
  sed -i "s/example.im/${domain}/g" $sourcedir/conf/nginx/domain.conf
  cp $sourcedir/conf/nginx/domain.conf /etc/nginx/sites-available/$domain
  service nginx reload
  echo "Finished setting custom nginx config for $domain."
  echo
  sleep 1

  echo "Now updating easyengine site $domain to TLS encrypted with LetsEncrypt..."
  echo
  ee site update $domain  --le
  echo
  echo "Finished updating easyengine site $domain to TLS encrypted with LetsEncrypt..."
  echo

  echo "Now adding IPv6 support to the HTTPS version of the $domain site..."
  echo
  sed -i "s/example.im/${domain}/g" $sourcedir/conf/nginx/ssl-domain.conf
  cp $sourcedir/conf/nginx/ssl-domain.conf /var/www/$domain/conf/nginx/ssl.conf
  echo "Finished adding IPv6 support to the HTTPS version of the $domain site..."
  echo

  echo "Now adding IPv6 support to the HTTPS redirect for the $domain site..."
  echo
  sed -i "s/example.im/${domain}/g" $sourcedir/conf/nginx/force-ssl-domain.conf
  cp $sourcedir/conf/nginx/force-ssl-domain.conf /etc/nginx/conf.d/force-ssl-$domain.conf
  echo "Finished adding IPv6 support to the HTTPS redirect for the $domain site..."
  echo

  echo "Now creating all-in-one TLS file for $domain for ejabberd..."
  echo
  touch $tlsdir/domain.pem
	cat /etc/letsencrypt/live/$domain/privkey.pem > $tlsdir/domain.pem
	cat /etc/letsencrypt/live/$domain/fullchain.pem >> $tlsdir/domain.pem
	domtlscertloc=$tlsdir/domain.pem
  echo "Finished creating all-in-one TLS file for $domain for ejabberd..."
  echo
  sleep 1

  echo "Now setting index.html in docroot for $domain..."
  echo
  cp $sourcedir/conf/web/domain/index.html /var/www/$domain/htdocs/
  echo "Finished setting index.html in docroot for $domain."
  echo
  sleep 1

fi

service nginx restart

echo "Now creating ejabberd directory and setting custom aenigma config to /etc/ejabberd/ejabberd.yml..."
echo
mkdir -p /etc/ejabberd/
touch /etc/ejabberd/ejabberd.yml
sed -i "s/example.im/${domain}/g" $sourcedir/conf/ejabberd/ejabberd.yml
if [ $configoption = 1 ]
then
# [old] direct main cert substitution
# sed -i "s|${tlsdir}/hostname.pem|${domtlscertloc}|g" $sourcedir/conf/ejabberd/ejabberd.yml
# [new] append ${domtlscertloc} in host_config
# sed -i "s|${tlsdir}/hostname.pem|${domtlscertloc}|g" $sourcedir/conf/ejabberd/ejabberd-tlsaddition.txt
sed -i "s|example.im|${domain}|g" $sourcedir/conf/ejabberd/ejabberd-tlsaddition.txt
sed -i "s|pathtofile|${domtlscertloc}|g" $sourcedir/conf/ejabberd/ejabberd-tlsaddition.txt
sed -i '/## aenigma_host_config_placeholder_start:/,/## aenigma_host_config_placeholder_end:/{//!d}' $sourcedir/conf/ejabberd/ejabberd-tlsaddition.txt
sed -i '/## aenigma_host_config_placeholder_start:/ r ejabberd-tlsaddition.txt' $sourcedir/conf/ejabberd/ejabberd-tlsaddition.txt
fi
cp $sourcedir/conf/ejabberd/ejabberd.yml /etc/ejabberd/ejabberd.yml
echo "Finished creating ejabberd directory and setting custom aenigma config to /etc/ejabberd/ejabberd.yml."
echo
sleep 1

echo "Now installing SSLH..."
echo
sshport="$(cat /root/os-dfbs/ssh-port)"
apt-get -y install sslh
if [ $ipv6avail = "y" ]
then
	sed -i "s|thisipv4|${thisipv4}:443 -p ${thisipv6}|g" $sourcedir/conf/sslh/sslh
else
	sed -i "s|thisipv4|${thisipv4}|g" $sourcedir/conf/sslh/sslh
fi
sed -i "s|sshport|${sshport}|g" $sourcedir/conf/sslh/sslh
cp $sourcedir/conf/sslh/sslh /etc/default/sslh
service sslh start
echo
echo "Finished installing SSLH."
echo

echo "Now installing ejabberd..."
echo
currdistro="$(lsb_release --codename | cut -f2)"
apt-get -y install apt-transport-https
echo "deb https://apt.jabber.at $currdistro ejabberd" > /etc/apt/sources.list.d/jabber.at.list
wget -qO- https://apt.jabber.at/gpg-key | apt-key add -
apt-get update
export DEBIAN_FRONTEND=noninteractive ; apt-get install -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --force-yes ejabberd
echo
echo "Finished installing ejabberd."
echo
sleep 1

echo "Now creating uploads directory..."
echo
mkdir -p /etc/ejabberd/uploads/
echo "Finished creating uploads directory."
echo
sleep 1

echo "Now creating HTTP fileserver directory..."
echo
mkdir -p /var/www/ejabberd/
echo "Finished creating HTTP fileserver directory."
echo
sleep 1

echo "Now creating logfile..."
echo
touch /var/log/ejabberd/www_access.log
echo "Finished creating logfile."
echo

echo "Now securing permissions..."
echo
chown -R ejabberd:ejabberd $tlsdir
chmod -R 700 $tlsdir
chown -R ejabberd:ejabberd /etc/ejabberd/uploads/
chmod -R 755 /etc/ejabberd/uploads/
chown -R ejabberd:ejabberd /var/www/ejabberd/
chmod -R 755 /var/www/ejabberd/
echo "Finished securing permissions."
echo
sleep 1

echo "Now stopping ejabberd..."
echo
/usr/sbin/ejabberdctl stop
sleep 8
echo "Finished stopping ejabberd."
echo
sleep 1

echo "Now starting ejabberd..."
/usr/sbin/ejabberdctl start
echo
sleep 8
/usr/sbin/ejabberdctl status
echo
sleep 1
echo "Finished starting ejabberd."
echo
sleep 1

echo "Now registering ejabberd admin user [if it doesn't yet exist]..."
echo
ejbdadminpw=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)
/usr/sbin/ejabberdctl register admin $domain $ejbdadminpw &> /dev/null
echo "Finished registering ejabberd admin user."
echo
sleep 1

read -p "Leave ejabberd admin user password the same as previously set? (Y/n): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Nn]$ ]]
then
	echo "Skipping ejabberd admin user password reset."
	echo
	ejbdadminpwreset=n
else
	echo
	echo "Ok, resetting ejabberd admin user password to: | $ejbdadminpw |"
	echo
	/usr/sbin/ejabberdctl change_password admin $domain $ejbdadminpw
	ejbdadminpwreset=y
fi
sleep 1
clear

echo "Now updating ejabberd's module repo..."
echo
/usr/sbin/ejabberdctl modules_update_specs
echo "Finished updating ejabberd's module repo..."
echo
sleep 1
clear

echo "Now creating 'ADMIN:EVERYBODY' and 'ADMIN:ONLINE' shared roster groups [admin@$domain can see 'everybody' and 'all online']..."
echo
/usr/sbin/ejabberdctl srg_create everybody $domain "everybody [$domain]" "This aenigma group includes every user on this domain" ""
/usr/sbin/ejabberdctl srg-user-add @all@ localhost everybody $domain
/usr/sbin/ejabberdctl srg_create online $domain "online [$domain]" "This aenigma group includes every user who is online on this domain" ""
/usr/sbin/ejabberdctl srg-user-add @online@ localhost online $domain
/usr/sbin/ejabberdctl srg_create admin $domain admin "This is a shared roster group set by aenigma" "everybody\\nonline"
/usr/sbin/ejabberdctl srg-user-add admin $domain admin $domain
echo "Finished creating shared roster groups."
echo
sleep 1
clear

echo "${b}${g}You can finally log in:${x}"
echo
echo "${b}https://$hostname${x}"
echo
echo "${b}admin@$domain${x}"
echo

if [ $ejbdadminpwreset = "y" ]
then
	echo "${b}$ejbdadminpw${x}"
	echo
else
	echo "${b}[your previously set password]${x}"
	echo
fi

read -p "[press enter to continue reading...]"
clear

if [ -f $tlsdir/dh.pem ]
then
	echo "${g}DHparam file found. Skipping generation...${x}"
	echo
else
	echo "One last thing: to make your TLS connections even more secure, you can generate a file called DH parameters file."
	echo
	echo "To do so, simply answer yes, but be aware that this is a very time consuming cryptographic operation, although it must only be performed once."
	echo
	read -p "Generate openssl DHparams file? (Y/n): " -n 1 -r
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "Ok, proceeding with DHparams file generation..."
		openssl dhparam -out $tlsdir/dh.pem.incomplete 4096
		mv $tlsdir/dh.pem.incomplete $tlsdir/dh.pem
		echo
	else
		echo
		echo "Skipping DHparams generation."
		echo
		echo "You can always generate them at a later time by executing:"
		echo
		echo "openssl dhparam -out $tlsdir/dh.pem.incomplete 4096"
		echo
		echo "[and making sure you let the command run until it exits]. Once it's done, execute:"
		echo
		echo "mv $tlsdir/dh.pem.incomplete $tlsdir/dh.pem"
		echo
		/usr/sbin/ejabberdctl restart
	fi
	echo "Finished generating DHparams."
	echo
fi
sleep 1
clear

echo "${b}Now removing installer directory${x}"
echo
echo "Run ${b}git clone https://github.com/openspace42/aenigma${x} once again to download the latest installer!"
echo

rm -r aenigma/

echo "${b}${g}aenigma installation complete!${x}"
echo

exit
