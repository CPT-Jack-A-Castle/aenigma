#!/usr/bin/env bash

### openspace synthia bootstrap framework
### [https://github.com/openspace42/synthia]
### v0.3.1

os_dna_version="v0.3.2-beta.4"

################################################################################

synthia-define_vars() {

	############################################################################
	#################### Insert your initial variables here ####################
	############################################################################

	export proj_name="aenigma"
	export author_name="openspace42"
	export git_host="https://github.com"

	### Set this to `y` if your project stores no data on end users' machines that could go lost during a re-install or update
	export skip_install_time_backup="n"

	### Set this to the directory that has the most impactful size when performing a backup [such as `/var/www/` for nginx-related projects]
	export backup_ref_dir="/var/lib/ejabberd"

	############################################################################
	############################################################################
	############################################################################

	### Do NOT edit the following line

	dna-define_vars

	############################################################################
	################## Insert your additional variables here ###################
	############################################################################

	### Set the paths to the cluster / nodes conf dirs

	export conf_cluster_dir="${conf_dir}/cluster"
	export conf_cluster_nodes_dir="${conf_cluster_dir}/nodes"

	export conf_xmpp_dir="${conf_dir}/xmpp"

	### Set the paths to the nodes_db files

	export nodes_db_ipv4_path="${conf_cluster_nodes_dir}/nodes_db_ipv4"
	export nodes_db_ipv6_path="${conf_cluster_nodes_dir}/nodes_db_ipv6"
	export nodes_db_numbered_path="${conf_cluster_nodes_dir}/nodes_db_numbered"
	export nodes_db_online_path="${tmp_project_dir}/nodes_db_online"

	############################################################################
	############################################################################
	############################################################################

}

################################################################################

synthia-define_formatting() {

	r=$'\e[1;31m'
	g=$'\e[1;32m'
	l=$'\e[1;34m'
	m=$'\e[1;35m'
	y=$'\e[1;33m'
	o=$'\e[38;5;208m'
	c=$'\e[1;36m'
	n=$'\e[1;39m'
	x=$'\e[0m'
	b=$'\033[1m'

}

synthia-check_root() {

	if [[ $EUID -ne 0 ]]
	then
		echo "${r-}${b-}This script must be run as root.${x-}"
		echo
		echo "${b-}Exiting...${x-}"
		echo
		exit 1
	fi

}

synthia-download_dna() {

	clone_host="https://github.com"
	clone_author="openspace42"
	clone_name="dna"

	clone_base_dir="/root/${clone_author}"
	clone_dir="${clone_base_dir}/${clone_name}"

	mkdir -p "${clone_base_dir}"

	if [ "${custom_dna_version-null}" = "l" ]
	then

		export dna_selected_vers="v0.0.1-custom-local"

		echo "${r-}${b-}Sourcing | ${n-}local version${r-} | of | ${n-}dna${r-} | respecting any local alteration performed as per | ${n-}-d l${r-} |.${x-}"

		echo "${dna_selected_vers}" > "./version_installed"

	else

		if [ -d "${clone_dir}" ]
		then
			rm -r "${clone_dir:?}"
		fi

		( cd "${clone_base_dir}" && git clone "${clone_host}/${clone_author}/${clone_name}" && echo && cd "${clone_name}"

			. ./functions/snippets

			git config advice.detachedHead false

			### Define latest version

			export dna_latest_vers_final="$(semtag getfinal)"
			export dna_latest_vers_tagged="$(semtag getlast)"
			export dna_latest_vers_bl_edge="$(semtag getcurrent)"

		    if [ "${custom_dna_version-null}" = "b" ]
		    then

		        export dna_selected_vers="${dna_latest_vers_bl_edge}"

		        echo "${r-}${b-}Installing | ${n-}bleeding-edge version${r-} | of | ${n-}dna${r-} | up to latest git commit as per | ${n-}-d b${r-} |.${x-}"
				echo

				git fetch
		        git reset --hard origin/master

			elif [[ "${custom_dna_version-null}" == *"v"* ]]
			then

				export dna_selected_vers="${custom_dna_version}"

				echo "${c-}${b-}Installing | ${n-}version ${dna_selected_vers}${c-} | of | ${n-}dna${c-} | as per | ${n-}-d ${dna_selected_vers}${c-} |.${x-}"
				echo

				git checkout "tags/${dna_selected_vers}"

		    elif [ "${custom_dna_version-null}" = "t" ]
		    then

		        export dna_selected_vers="${dna_latest_vers_tagged}"

		        echo "${o-}${b-}Installing | ${n-}latest-tagged version [${dna_selected_vers}]${o-} | of | ${n-}dna${o-} | [independently of its stability type] as per | ${n-}-d t${o-} |.${x-}"
				echo

		        git checkout "tags/${dna_latest_vers_tagged}"

		    elif [ "${custom_dna_version-null}" = "f" ]
			then

		        export dna_selected_vers="${dna_latest_vers_final}"

				echo "${y-}${b-}Installing | ${n-}latest-final version [${dna_selected_vers}]${y-} | of | ${n-}dna${y-} | as per | ${n-}-d f${y-} |.${x-}"
				echo

		        git checkout "tags/${dna_latest_vers_final}"

			else

				export dna_selected_vers="${os_dna_version}"

				echo "${b-}Installing | ${g-}version [${dna_selected_vers}]${n-} | of | ${g-}dna${n-} |.${x-}"
				echo

				git checkout "tags/${os_dna_version}"

		    fi

			echo "${dna_selected_vers}" > "./version_installed"

		)

	fi

}

synthia-source_dna() {

	for f in /root/openspace42/dna/functions/*
	do
		. $f
	done

}

################################################################################

################################################################################
######################## Insert project functions here #########################
################################################################################

aenigma-display_logo() {

	### Add delay for previous outputs

	sleep 1

	### Determine terminal window size

	columns_number="$(tput cols)"
	rows_number="$(tput lines)"

	### Check that the terminal window is large enough to display the logo

	if [ "${columns_number}" -ge "93" ] && [ "${rows_number}" -ge "24" ]
	then

	    ### Determine terminal window horizontal center

	    columns_median="$(echo $((columns_number / 2)))"

	    ### The aenigma logo is 45 pixels and therefore 90 columns wide, therefore...

	    base_column="$(echo $((columns_median - 45)))"

		### Determine terminal window vertical center

	    rows_median="$(echo $((rows_number / 2)))"

	    ### The aenigma logo is 17 rows tall, therefore...

	    base_row="$(echo $((rows_median - 9)))"

		### Determine bottom padding

		bottom_padding="$(echo $((base_row - 2)))"

	    ### Set colors

	    b=$'\e[38;5;16m'
	    w=$'\e[38;5;15m'

	    l=$'\e[38;5;33m'

	    x=$'\e[0m'
	    z=$'\e[8m'

	    ### Set white base for all lines
	    set p02{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p03{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p04{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p05{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p06{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p07{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p08{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p09{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p10{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p11{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p12{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p13{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p14{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p15{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p16{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p17{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item

	    ### Line 03

	    eval p0319='$b'

	    ### Line 06

	    eval p06{03..09}='$l'
	    eval p06{11..17}='$b'
	    eval p0619='$b'
	    eval p06{21..27}='$b'
	    eval p06{29..35}='$b'
	    eval p06{38..43}='$b'

	    ### Lines {07..08}

	    eval p{07..08}06='$l'
	    eval p{07..08}09='$l'
	    eval p{07..08}11='$b'
	    eval p{07..08}17='$b'
	    eval p{07..08}19='$b'
	    eval p{07..08}21='$b'
	    eval p{07..08}27='$b'
	    eval p{07..08}29='$b'
	    eval p{07..08}32='$b'
	    eval p{07..08}35='$b'
	    eval p{07..08}43='$b'

	    ### Line 09

	    eval p09{03..09}='$l'
	    eval p0911='$b'
	    eval p0917='$b'
	    eval p0919='$b'
	    eval p0921='$b'
	    eval p0927='$b'
	    eval p0929='$b'
	    eval p0932='$b'
	    eval p0935='$b'
	    eval p09{37..43}='$b'

	    ### Lines {10..11}

	    eval p{10..11}03='$l'
	    eval p{10..11}06='$l'
	    eval p{10..11}11='$b'
	    eval p{10..11}17='$b'
	    eval p{10..11}19='$b'
	    eval p{10..11}21='$b'
	    eval p{10..11}27='$b'
	    eval p{10..11}29='$b'
	    eval p{10..11}32='$b'
	    eval p{10..11}35='$b'
	    eval p{10..11}37='$b'
	    eval p{10..11}43='$b'

	    ### Line 12

	    eval p12{03..09}='$l'
	    eval p1211='$b'
	    eval p1217='$b'
	    eval p1219='$b'
	    eval p12{21..27}='$b'
	    eval p1229='$b'
	    eval p1232='$b'
	    eval p1235='$b'
	    eval p12{37..43}='$b'

	    ### Lines {13..14}

	    eval p{13..14}27='$b'

	    ### Line 15

	    eval p15{22..27}='$b'

	    ### Set borders

	    set p01{01..45} && array="$@" && for item in $array; do eval $item='$b'; done && unset array item
	    set p17{01..45} && array="$@" && for item in $array; do eval $item='$b'; done && unset array item
	    eval p{01..17}01='$b'
	    eval p{01..17}45='$b'

		### Clear

		clear

		### Print top padding

		yes '' | sed ${base_row}q

	    ### Print

	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p01{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p02{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p03{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p04{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p05{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p06{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p07{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p08{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p09{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p10{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p11{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p12{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p13{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p14{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p15{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p16{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p17{01..45}██ | tr -d ' ')"

		### Reset formatting

	    echo ${x}

		unset b w l x z

		synthia-define_formatting

		### Print bottom padding

		yes '' | sed ${bottom_padding}q

		### Add delay

		sleep 2

		### Clear

		clear

	fi

}

aenigma-xmpp_intro() {

	dna-echo -m "First of all, a little introduction on how XMPP actually works"
	dna-echo -m "XMPP works very much like email. You can have a domain [amsterdamhacklab.xyz] and receive email for that domain on a server located at mx01.amsterdamhacklab.xyz, by using the appropriate DNS configuration, and also have other servers [webserver, mapserver, etc...] on other subdomains."
	dna-echo -m "In that case, a DNS MX record tells sending servers to direct mail intended for amsterdamhacklab.xyz to mx01.amsterdamhacklab.xyz."
	dna-echo -m "In the same way, the XMPP server for amsterdamhacklab.xyz can be located at ae01.amsterdamhacklab.xyz and a DNS SRV record tells any sending servers that XMPP for that domain [i.e. a message directed to mark@amsterdamhacklab.xyz] is handled by the server located at ae01.amsterdamhacklab.xyz."

	read -rp "${b-}[press enter to continue reading...]${x-}"
	clear

	dna-echo -m "$proj_name fully embraces this opportunity."
	dna-echo -m "The domain for which you're setting up your new $proj_name server can definitely be a domain connected to a bigger project, that already points to other servers, and for which XMPP is just another service."
	dna-echo -m "This will give you working @amsterdamhacklab.xyz JIDs [XMPP account addresses], but the $proj_name server will reside at ae01.amsterdamhacklab.xyz, as in the following example:"
	dna-echo -m "${o-}Domain:${n-}               ${y-}amsterdamhacklab.xyz.${n-}"
	dna-echo -m "${o-}Website:${n-}              ${y-}amsterdamhacklab.xyz${n-} / ${y-}www.amsterdamhacklab.xyz${n-} [hosted by another server]."
	dna-echo -m "${o-}Your JID format:${n-}      ${y-}mark@amsterdamhacklab.xyz.${n-}"
	dna-echo -m "${o-}XMPP server:${n-}          ${y-}xmpp.amsterdamhacklab.xyz${n-}"

	read -rp "${b-}[press enter to continue reading...]${x-}"
	clear

	### Add cluster info here

	dna-echo -m "Now that you know how XMPP works, let's get your brand new $proj_name server up and running!"

}

aenigma-install_sslh() {

	### Install SSLH

	dna-echo -m "Now installing SSLH..."
	dna-install_build_tools
	/usr/sbin/service sslh stop &> /dev/null || true
	ssh_port="$(cat $os_conf_dir/ssh_port)"
	apt-get -y install libwrap0-dev libconfig-dev || true
	rm -r "$tmp_project_dir/sslh" &> /dev/null || true
	git clone https://github.com/yrutschle/sslh "$tmp_project_dir/sslh"
	( cd "$tmp_project_dir/sslh" && make install && make && cp sslh-select /usr/local/sbin/sslh )
	sed -i "s|this_ipv4-var|${this_ipv4}|g" $source_dir/conf/sslh/etc-sslh.cfg
	if [ $ipv6_available = "y" ]
	then
		sed -i "s|#ipv6_comma|,|g" $source_dir/conf/sslh/etc-sslh.cfg
		sed -i "s|#ipv6_line||g" $source_dir/conf/sslh/etc-sslh.cfg
		sed -i "s|this_ipv6-var|${this_ipv6}|g" $source_dir/conf/sslh/etc-sslh.cfg
	else
		sed -i "s|#ipv6_comma||g" $source_dir/conf/sslh/etc-sslh.cfg
		sed -i "s|#ipv6_line|#|g" $source_dir/conf/sslh/etc-sslh.cfg
	fi
	sed -i "s|domain-var|${domain}|g" $source_dir/conf/sslh/etc-sslh.cfg
	sed -i "s|ssh_port-var|${ssh_port}|g" $source_dir/conf/sslh/etc-sslh.cfg
	sed -i "s|xu.@|xu${node_number}.@|g" $source_dir/conf/sslh/etc-sslh.cfg
	cp $source_dir/conf/sslh/etc-sslh.cfg /etc/sslh.cfg
	cp $source_dir/conf/sslh/etc-init.d.sslh /etc/init.d/sslh
	chmod +x /etc/init.d/sslh
	update-rc.d sslh defaults
	systemctl daemon-reload
	rm -r "$tmp_project_dir/sslh"
	mkdir -p /var/run/sslh
	touch /var/run/sslh/sslh.pid
	service sslh restart || true
	echo
	dna-echo -m "${g-}Finished installing SSLH."

}

aenigma-restart_ejabberd_if_running() {

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
		dna-echo -m "Now restarting ejabberd..."
		/usr/sbin/service ejabberd restart
	else
		dna-echo -m "ejabberd not running. Skipping restart."
	fi

}

aenigma-add_ejabberd_repo() {

	dna-check_dpkg_availability
	currdistro="$(lsb_release --codename | cut -f2)"
	apt-get -y install apt-transport-https || true
	echo "deb https://apt.jabber.at $currdistro ejabberd" > /etc/apt/sources.list.d/jabber.at.list
	wget -qO- https://apt.jabber.at/gpg-key | apt-key add -
	apt-get update
	echo

}

aenigma-get_ejabberd_candidate_version() {

	ejabberd_candidate_version="$(apt-cache show ejabberd | grep Version | head -1 | sed "s|Version: ||" | cut -d ':' -f 2 | cut -f1 -d'-')"

}

aenigma-get_ejabberd_installed_version() {

	if dpkg -s ejabberd &> /dev/null
	then
		ejabberd_installed_version="$(dpkg -s ejabberd | grep '^Version:' | sed "s|Version: ||" | cut -d ':' -f 2 | cut -f1 -d'-')"
	else
		ejabberd_installed_version=none
	fi

}

aenigma-install_ejabberd_config() {

	dna-echo -m "Now creating ejabberd directory and setting custom aenigma config..."

	aenigma-get_ejabberd_candidate_version

	source_ejab_conf_file="${source_dir}/conf/ejabberd/ejabberd-${ejabberd_candidate_version}.yml"

	if [ ! -f "${source_ejab_conf_file}" ]
	then
		### Fallback to ejabberd.yml for v18.09 in case the ejabberd candidate install version isn't among the ones we have config files for
		source_ejab_conf_file="$source_dir/conf/ejabberd/ejabberd-18.09.yml"
	fi

	mkdir -p "/etc/ejabberd/"
	cp "${source_ejab_conf_file}" "/etc/ejabberd/ejabberd.yml"
	sed -i "s/domain.xyz/${domain}/g" "/etc/ejabberd/ejabberd.yml"
	sed -i "s/hostname.xyz/${hostname}/g" "/etc/ejabberd/ejabberd.yml"

	dna-echo -s "Finished creating ejabberd directory and setting custom aenigma config."

}

aenigma-set_permissions() {

	dna-echo -m "Now setting permissions..."

	### /var/lib/ejabberd/

	if id "ejabberd" >/dev/null 2>&1
	then
		chown -R "ejabberd:ejabberd" "/var/lib/ejabberd/uploads/"
		chmod 2750 "/var/lib/ejabberd/uploads/"
		if [ -f "/var/lib/ejabberd/.erlang.cookie" ]
		then
			chown "ejabberd:ejabberd" "/var/lib/ejabberd/.erlang.cookie"
		fi
	fi

	### /var/www/ejabberd

	if id "ejabberd" >/dev/null 2>&1
	then
		chown -R "ejabberd:ejabberd" "/var/www/ejabberd/"
		chmod -R 755 "/var/www/ejabberd/"
	fi

	### /var/log/ejabberd

	if id "ejabberd" >/dev/null 2>&1
	then
		chown -R "ejabberd:adm" "/var/log/ejabberd/"
		chmod -R 755 "/var/log/ejabberd/"
	fi

	### $ssl_project_dir

	if id "ejabberd" >/dev/null 2>&1
	then
		chown -R "ejabberd:ejabberd" "${ssl_project_dir}"
		chmod -R 700 "${ssl_project_dir}"
	fi

	### ~/.ssh/

	chown "root:root" "/root/.ssh/authorized_keys" 2> /dev/null || true
	chmod 755 "/root/.ssh/" 2> /dev/null || true
	chmod 600 "/root/.ssh/authorized_keys" 2> /dev/null || true

	dna-echo -m "${g-}Finished setting permissions."

}

aenigma-create_ejabberd_locations() {

	### Create ejabberd uploads directory

	dna-echo -m "Now creating uploads directory..."
	mkdir -p "/var/lib/ejabberd/uploads/"
	dna-echo -m "${g-}Finished creating uploads directory."

	### Create HTTP uploads directory

	dna-echo -m "Now creating HTTP fileserver directory..."
	mkdir -p "/var/www/ejabberd/"
	dna-echo -m "${g-}Finished creating HTTP fileserver directory."

	### Create logfile

	dna-echo -m "Now creating logfile..."
	mkdir -p "/var/log/ejabberd/"
	touch "/var/log/ejabberd/www_access.log"
	dna-echo -m "${g-}Finished creating logfile."

	### Set permissions

	aenigma-set_permissions

}

aenigma-install_ejabberd() {

	### Ensure DPKG is available before proceeding.

	dna-check_dpkg_availability

	### Inhibit ejabberd from starting after install as permissions won't be already correct

	echo exit 101 > "/usr/sbin/policy-rc.d"
	chmod +x "/usr/sbin/policy-rc.d"

	### Proceed

	dna-echo -m "Now installing ejabberd..."

	export DEBIAN_FRONTEND=noninteractive ; apt-get install -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --force-yes ejabberd || true
	echo

	### Remove autostart inhibition

	rm "/usr/sbin/policy-rc.d"

	dna-echo -s "Finished installing ejabberd."
}

aenigma-create_nodes_db_numbered() {

	### Create a node-numbered version of "nodes_db"

	if [ -f "${nodes_db_numbered_path}" ]
	then
		rm "${nodes_db_numbered_path}"
		touch "${nodes_db_numbered_path}"
	fi

	array_iter=1
	IFS=$'\n'
	set -f
	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
	do
		array_iter_padded="$(echo ${array_iter} | xargs printf %02d)"
		echo -e "${node_ipv4}\tae${array_iter_padded}.${domain}" >> "${nodes_db_numbered_path}"
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4
	IFS=$' \t\n'

}

aenigma-initialize_nodes_db_files() {

	mkdir -p "${conf_cluster_nodes_dir}"

	dna-get_public_ipv4 -s

	dna-check_ipv6_connectivity -s

	### IPv4

	touch "${nodes_db_ipv4_path}"

	if [ -s "${nodes_db_ipv4_path}" ]
	then
		### File is not empty, alter first line.
		sed -i "1s/.*/${this_ipv4}/" "${nodes_db_ipv4_path}"
	else
		### File is empty, write to it.
		echo "${this_ipv4}" > "${nodes_db_ipv4_path}"
	fi

	### IPv6

	touch "${nodes_db_ipv6_path}"

	if [ -s "${nodes_db_ipv6_path}" ]
	then

		### File is not empty, alter first line.

		if [ "${ipv6_available}" = "y" ]
		then
			sed -i "1s/.*/${this_ipv6}/" "${nodes_db_ipv6_path}"
		else
			sed -i "1s/.*/null/" "${nodes_db_ipv6_path}"
		fi

	else

		### File is empty, write to it.

		if [ "${ipv6_available}" = "y" ]
		then
			echo "${this_ipv6}" > "${nodes_db_ipv6_path}"
		else
			echo "null" > "${nodes_db_ipv6_path}"
		fi

	fi

	aenigma-create_nodes_db_numbered

}

aenigma-update_routing_info() {

	### Set UFW rules on this node according to the updated nodes_db

	array_iter=1
	IFS=$'\n'
	set -f
	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
	do
		/usr/sbin/ufw insert "${array_iter}" allow from "${node_ipv4}"
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4 array_iter
	IFS=$' \t\n'
	echo

	### Import nodes_db to /etc/hosts to provide ejabberd with a locally resolved list of nodes to cluster with

	if ! grep -q "### aenigma nodes list start" /etc/hosts
	then
		echo >> /etc/hosts
		echo "### aenigma nodes list start" >> /etc/hosts
	fi

	if ! grep -Pzoq '### aenigma nodes list start(?:.*\n)*?\K### aenigma nodes list end' /etc/hosts
	then
		echo "### aenigma nodes list end" >> /etc/hosts
	fi

	sed -i '/### aenigma nodes list start/,/### aenigma nodes list end/{//!d}' /etc/hosts
	sed -i "/### aenigma nodes list start/ r ${nodes_db_numbered_path}" /etc/hosts

}

aenigma-refresh_nodes_db_online() {

	############################################################################

	### This function will always get invoked at the beginning push_routing_info() in the later event that an existing node cannot be reached at the time of running a new clusterization.
	### It will create a copy of nodes_db_ipv4 and nodes that appear to be offline will be removed from it, for use by subsequent functions, until the end of the clusterize script.

	############################################################################

	### Touch temp dir

	dna-touch_tmp_project_dir

	############################################################################

	if [ -f "${nodes_db_online_path}" ]
	then
		rm "${nodes_db_online_path}"
		touch "${nodes_db_online_path}"
	fi

	############################################################################

	cp "${nodes_db_ipv4_path}" "${nodes_db_online_path}"

	############################################################################

}

aenigma-check_ip_info_current() {

	if [ ! -f "${nodes_db_ipv4_path}" ] || [ ! -f "${nodes_db_ipv6_path}" ]
    then
		dna-echo -m "Not all nodes_db files found or none at all. Skipping IP change checks."
        return 0
    fi

	### Fetch IP addresses for this machine

	dna-get_public_ipv4

	dna-check_ipv6_connectivity

	### Check to see if this machine's IPs have changed since last install / clusterization

	this_registered_ipv4="$(cat ${nodes_db_ipv4_path} | head -1 | xargs)"

	this_registered_ipv6="$(cat ${nodes_db_ipv6_path} | head -1 | xargs)"

	if [ ! "${this_ipv4}" = "${this_registered_ipv4}" ]
	then
		dna-echo -e "The public IPv4 address for this machine appears to have changed since the last install or the last run of the clusterize script."
		dna-echo -m "It now appears to be: | ${y-}${this_ipv4}${n-} |."
		dna-echo -m "This node, however, appears to be registered with the following: | ${y-}${this_registered_ipv4}${n-} |."
		dna-echo -m "Please re-run the installation to update the records for this machine on the nodes database."
		dna-exit
	fi

	if [ ! "${this_ipv6}" = "${this_registered_ipv6}" ]
	then
		dna-echo -e "The public IPv6 address for this machine appears to have changed since the last install or the last run of the clusterize script."
		dna-echo -m "It now appears to be: | ${y-}${this_ipv6}${n-} |."
		dna-echo -m "This node, however, appears to be registered with the following: | ${y-}${this_registered_ipv6}${n-} |."
		dna-echo -m "Please re-run the installation to update the records for this machine on the nodes database."
		dna-exit
	fi

}

aenigma-push_routing_info() {

	############################################################################

	### Push nodes_db files to all secondary nodes for /etc/hosts and ufw rules configuration.
	### At the same time, check to see if any existing secondary nodes are offline, and, if so, remove them from nodes_db_online.

	aenigma-refresh_nodes_db_online

	array_iter=1
	IFS=$'\n'
	set -f

	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")							### Do NOT escape this variable
	do
		node_number="$(echo ${array_iter} | xargs printf %02d)"
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${node_ipv4}" = "${this_ipv4}" ]
		then
			if ! /usr/bin/scp -P42022 -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i /root/.ssh/aenigma_cluster -r "${conf_cluster_nodes_dir}" "root@${node_ipv4}:${conf_cluster_dir}"
			then
				echo
				dna-echo -e "Existing node number | ${n-}${node_number}${r-} | is not responding at IPv4 address | ${n-}${node_ipv4}${r-} |."
				dna-echo -m "It is NOT reccommended to continue the installation as the node in question will not be informed of the new node we're setting up right now."
				dna-echo -m "However, you can continue running the installation now and run the | ${o-}push_routing_info${n-} | script at at a later time by executing:"
				dna-echo -m " | ${y-}bash ${tools_dir}/${proj_name}-push_routing_info${n-} | "
	            dna-ask_for_boolean -d "y" -q "Continue anyway?"
	            if [ "${boolean_output}" = "y" ]
	            then
					dna-echo -n -m "Ok, continuing..."
					### Remove node from nodes_db_online
					sed -i "/^${node_ipv4}$/d" "${nodes_db_online_path}"
				else
					dna-echo -m "Ok, aborting..."
					dna-exit
				fi
			fi
		fi
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4
	IFS=$' \t\n'

	############################################################################

	aenigma-exec() {

		### Define the commands that will be passed to the aenigma-exec script on the remote machine to be run, one per line between the quotes.

        bash openspace42/aenigma/tools/aenigma-exec -c "
aenigma-update_routing_info
"

	}

	############################################################################

	for online_node_ipv4 in $(cat < "${nodes_db_online_path}")
	do
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${online_node_ipv4}" = "${this_ipv4}" ]
		then
			### SSH into the secondary node, declare the aenigma-exec function, and run it inside of the subshell.
	        ssh -tt -p42022 -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${online_node_ipv4}" "$(declare -f aenigma-exec); export -f aenigma-exec; exec bash -li" <<END
set -eu
. /root/openspace42/aenigma/functions
synthia-source_dna
synthia-define_vars
dna-read_conf_settings
aenigma-exec
exit
END
		fi
		echo
	done
	unset online_node_ipv4

	############################################################################

}

aenigma-push_certs() {

	############################################################################

	### Push LetsEncrypt TLS certificate files to all secondary nodes.
	### At the same time, check to see if any existing secondary nodes are offline, and, if so, remove them from nodes_db_online.

	aenigma-refresh_nodes_db_online

	array_iter=1
	IFS=$'\n'
	set -f

	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")							### Do NOT escape this variable
	do
		node_number="$(echo ${array_iter} | xargs printf %02d)"
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${node_ipv4}" = "${this_ipv4}" ]
		then
			if ! /usr/bin/scp -P42022 -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i /root/.ssh/aenigma_cluster -r "${ssl_project_dir}" "root@${node_ipv4}:${ssl_dir}"
			then
				echo
				dna-echo -e "Node number | ${n-}${node_number}${r-} | is not responding at IPv4 address | ${n-}${node_ipv4}${r-} |."
				dna-echo -m "Ensure such node is actually online and when it is execute this script again by running:"
				dna-echo -m " | ${y-}${tools_dir}/${proj_name}-create-push-certs${n-} | "
				if [ "${interactive}" = "y" ]
				then
		            dna-ask_for_boolean -d "y" -q "Continue anyway with all other nodes now?"
		            if [ "${boolean_output}" = "y" ]
		            then
						dna-echo -n -m "Ok, continuing..."
						### Remove node from nodes_db_online
						sed -i "/^${node_ipv4}$/d" "${nodes_db_online_path}"
					else
						dna-echo -m "Ok, aborting..."
						dna-exit
					fi
				else
					dna-echo -e "Skipping node | ${n-}${node_number}${r-} | and continuing with all others now."
					### Send an alert email.
			        dna-send_mail -s "aenigma: node: | ${node_number} | offline" \
			        -b "Automated post-renewal LetsEncrypt TLS certificate files push to node: | ${node_number} | has failed, as it appears to be offline. Look into the situation and when the node is back online simply log into your primary node [the machine sending this very notification] and execute: | ${tools_dir}/${proj_name}-create-push-certs |." \
			        -r "${admin_mail}"
				fi
			fi
		fi
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4
	IFS=$' \t\n'

	############################################################################

	aenigma-exec() {

		### Define the commands that will be passed to the aenigma-exec script on the remote machine to be run, one per line between the quotes.

        bash openspace42/aenigma/tools/aenigma-exec -c "
set +e
chown -R "ejabberd:ejabberd" "${ssl_project_dir}"
set -e
chmod -R 700 "${ssl_project_dir}"
/usr/sbin/service ejabberd restart
"

	}

	############################################################################

	for online_node_ipv4 in $(cat < "${nodes_db_online_path}")
	do
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${online_node_ipv4}" = "${this_ipv4}" ]
		then
			### SSH into the secondary node, declare the aenigma-exec function, and run it inside of the subshell.
	        ssh -tt -p42022 -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${online_node_ipv4}" "$(declare -f aenigma-exec); export -f aenigma-exec; exec bash -li" <<END
set -eu
. /root/openspace42/aenigma/functions
synthia-source_dna
synthia-define_vars
dna-read_conf_settings
aenigma-exec
exit
END
		fi
		echo
	done
	unset online_node_ipv4

	############################################################################

}

aenigma-test_online_nodes() {

	############################################################################

	dna-echo -m "This function attempts to connect to every node in your cluster, and checks for consistency across all nodes' ejabberd's cluster synchronization state."
	dna-echo -m "If a node is found to be offline, you will have the choice to remove it from your primary node [this machine]'s database of nodes."
	dna-press_to_continue

	############################################################################

	### Check to see if any existing secondary nodes are offline, and, if so, remove them from nodes_db_online

	aenigma-refresh_nodes_db_online

	array_iter=1
	IFS=$'\n'
	set -f

	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")							### Do NOT escape this variable
	do
		node_number="$(echo ${array_iter} | xargs printf %02d)"
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${node_ipv4}" = "${this_ipv4}" ]
		then
			if /usr/bin/ssh -p42022 -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${node_ipv4}" exit
			then
				dna-echo -s "Node number: | ${n-}${node_number}${g-} | is responding at IPv4 address: | ${n-}${node_ipv4}${g-} |."
			else
				echo
				dna-echo -e "Node number: | ${n-}${node_number}${r-} | is NOT responding at IPv4 address | ${n-}${node_ipv4}${r-} |."
				dna-echo -m "If you have decommissioned this server or intend to do so, you can remove this node from this primary node's configuration about the cluster."
				dna-echo -m "Data on such secondary node will not be affected in any way, but this primary node won't consider it part of the cluster during future operations."
				dna-echo -m "If somehow such secondary node is still running, even though we cannot reach it right now, it will still actually take part in the ejabberd cluster."
	            dna-ask_for_boolean -d "n" -q "Would you like to remove this node from the cluster database now?"
	            if [ "${boolean_output}" = "y" ]
	            then
					dna-echo -m "Ok, removing node now..."
					/usr/sbin/ejabberdctl --no-timeout leave_cluster "ejabberd@ae${node_number}.${domain}" || true
					dna-echo -m "Now restarting ejabberd..."
					/usr/sbin/service ejabberd restart
					initial_last_node_number=$(wc -l < "${nodes_db_ipv4_path}" | xargs printf %02d)
					if [ "${node_number}" = "${initial_last_node_number}" ]
					then
						### Remove node from nodes_db files
						sed -i "${node_number}d" "${nodes_db_ipv4_path}"
						sed -i "${node_number}d" "${nodes_db_ipv6_path}"
						aenigma-create_nodes_db_numbered
						aenigma-push_routing_info
						dna-echo -s "Node deleted successfully."
						node_removed="y"
					else
						dna-echo -m "Performing this removal would leave an empty space for node number | ${o-}${node_number}${n-} |."
						dna-echo -m "To remove it from our cluster configuration it is required to reconfigure the last numbered node: [number | ${o-}${initial_last_node_number}${n-} |] to take the place of the newly removed node."
						dna-echo -m "If you do not want to proceed with this operation, the removal will be aborted."
						dna-ask_for_boolean -d "y" -q "Would you like to reconfigure node number | ${o-}${initial_last_node_number}${n-} | now?"
						if [ "${boolean_output}" = "y" ]
						then
							dna-echo -m "Ok, reconfiguring node now..."
							/usr/sbin/ejabberdctl --no-timeout leave_cluster "ejabberd@ae${initial_last_node_number}.${domain}" || true
							dna-echo -m "Now restarting ejabberd..."
							/usr/sbin/service ejabberd restart
							### Get the last node in nodes_db_ipv4
							target_node_ipv4=$(cat ${nodes_db_ipv4_path} | sed -n "${initial_last_node_number}"p)
							### Copy its IPv4 to the line of the node to be removed
							sed -i "${node_number}s/.*/${target_node_ipv4}/" "${nodes_db_ipv4_path}"
							### Delete the reconfigured node's initial line
							sed -i "${initial_last_node_number}d" "${nodes_db_ipv4_path}"
							### Get the last node in nodes_db_ipv6
							target_node_ipv6=$(cat ${nodes_db_ipv6_path} | sed -n "${initial_last_node_number}"p)
							### Copy its IPv6 to the line of the node to be removed
							sed -i "${node_number}s/.*/${target_node_ipv6}/" "${nodes_db_ipv6_path}"
							### Delete the reconfigured node's initial line
							sed -i "${initial_last_node_number}d" "${nodes_db_ipv6_path}"
							aenigma-create_nodes_db_numbered
							dna-echo -s "Node number: | ${n-}${initial_last_node_number}${g-} | successfully changed to number: | ${n-}${node_number}${g-} |."
							node_removed="y"
							launch_node_reinstallation="y"
						else
							dna-echo -m "Ok, aborting node removal."
						fi
					fi
					if [ "${launch_node_reinstallation-null}" = "y" ]
					then
						dna-echo -m "Having re-ordered what is now node number | ${o-}${node_number}${n-} | it's time to re-configure it and notify it of the change."
						dna-echo -m "Open a new shell to it [located at IP: | ${y-}${target_node_ipv4}${n-} |] and run the installer from there now. Then come back here."
						dna-press_to_continue
						dna-echo -n -m "Ok, now launching | ${c-}${proj_name}-clusterize${n-} | script..."
						bash "${tools_dir}/${proj_name}-clusterize"
					fi
				else
					dna-echo -m "Ok, skipping node removal."
					dna-exit
				fi
			fi
		fi
		array_iter=$((array_iter + 1))
		if [ "${node_removed}" = "y" ]
		then
			dna-echo -e "Interrupting | ${n-}test_online_nodes${r-} | function execution."
			dna-echo -m "Having removed a node, if you want to keep testing online nodes, given the new node arrangement, simply re-run the script."
			dna-press_to_continue
			break
		fi
	done
	unset node_ipv4
	IFS=$' \t\n'

	############################################################################

	dna-echo -m "Now pushing routing info..."

	aenigma-push_routing_info

	############################################################################

}

aenigma-perform_dns_checks() {

	### Perform DNS checks. They must only be run by the primary node.

	############################################################################

	if [ "${cluster_enabled}" = "cluster" ]
	then

		dna-echo -m "Performing DNS checks for the following nodes:"
		dna-echo -m "${y-}$(cat ${nodes_db_numbered_path})"

	fi

	############################################################################

	### Perform checks in both IPv4 and IPv6. If this node [or a node in case of a cluster] doesn't have IPv6 connectivity its IPv6 check will be ignored locally.

	declare -a ip_version_array=(
		"4"
		"6"
	)

	aenigma-calculate_ip_version_vars() {

		if [ "${ip_version}" = "4" ]
		then
			nodes_db_path="${nodes_db_ipv4_path}"
			address_type="a"
		elif [ "${ip_version}" = "6" ]
		then
			nodes_db_path="${nodes_db_ipv6_path}"
			address_type="aaaa"
		fi

	}

	############################################################################

	### Check hostnames.

	for ip_version in "${ip_version_array[@]}"
	do

		aenigma-calculate_ip_version_vars

		array_iter=1
		IFS=$'\n'
		set -f

		for node_ip in $(cat < "${nodes_db_path}")
		do

			node_number="$(echo ${array_iter} | xargs printf %02d)"
			dna-check_dns_record -n "ae${node_number}.${domain}" -t "${address_type}" -r "${node_ip}"
			array_iter=$((array_iter + 1))

		done

		unset array_iter
		IFS=$' \t\n'

	done

	############################################################################

	### Now check that "ae.$domain" points to all nodes in a round-robin fashion.

	for ip_version in "${ip_version_array[@]}"
	do

		aenigma-calculate_ip_version_vars

		dna-check_dns_record -n "ae.${domain}" -t "${address_type}" -r "${nodes_db_path}"

	done

	############################################################################

	### Check XMPP services records

	### First check services that need to point to each node respectively

	for ip_version in "${ip_version_array[@]}"
	do

		aenigma-calculate_ip_version_vars

		array_iter=1
		IFS=$'\n'
		set -f

		for node_ip in $(cat < "${nodes_db_path}")
		do

			node_number="$(echo ${array_iter} | xargs printf %02d)"

			declare -a xmpp_service_array=(
				"xe"
				"xm"
				"xp"
				"xu"
				"xv"
			)

			for xmpp_service in "${xmpp_service_array[@]}"
			do

				dna-check_dns_record -n "${xmpp_service}${node_number}.${domain}" -t "${address_type}" -r "${node_ip}"

			done

			array_iter=$((array_iter + 1))

		done

		unset array_iter
		IFS=$' \t\n'

	done

	### Then check "xc.$domain" as it should not be a set of numbered records [xc01, xc02...] but instead be only one record pointing to all nodes in a round-robin fashion

	for ip_version in "${ip_version_array[@]}"
	do

		aenigma-calculate_ip_version_vars

		dna-check_dns_record -n "xc.${domain}" -t "${address_type}" -r "${nodes_db_path}"

	done

	############################################################################

	### Check SRV records

	dna-check_dns_record -n "_xmpp-client._tcp.${domain}" -t "srv" -r "0 0 5222 ae.${domain}."

	declare -a srv_record_array=(
		"_jabber._tcp"
		"_xmpp-server._tcp"
	)

	for srv_record in "${srv_record_array[@]}"
	do

		dna-check_dns_record -n "${srv_record}.${domain}" -t "srv" -r "0 0 5269 ae.${domain}."

	done

	############################################################################

	unset dns_checks_outcome

}

backup_locally_loop() {

	if [ "${cluster_mode-null}" = "secondary" ]
	then
		echo "${r-}${b-}The backup script is only intended to run on the primary node.${x-}"
		echo
		echo "${b-}The primary node will take care of backing up the ejabberd uploads directory of the secondary nodes. No further backup is required on secondary nodes.${x-}"
		echo
		dna-exit
	fi

	cp -r "${conf_dir}" "${tmp_backup_dir}"/conf/
	mkdir -p "${tmp_backup_dir}"/data/
	/usr/sbin/ejabberdctl backup ejabberd-mnesia-backup
	mv /var/lib/ejabberd/ejabberd-mnesia-backup "${tmp_backup_dir}"/data/ejabberd-mnesia-backup
	cp -r /etc/ejabberd/ "${tmp_backup_dir}"/data/etc-ejabberd/
	cp -r /var/lib/ejabberd/ "${tmp_backup_dir}"/data/var-lib-ejabberd/

	if [ "${cluster_enabled}" = "y" ]
	then
		for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
		do
			### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
			if [ ! "${node_ipv4}" = "${this_ipv4}" ]
			then
				mkdir -p "${tmp_backup_dir}"/data/${node_ipv4}/"
				/usr/bin/scp -P42022 -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@ae${node_ipv4}:/var/lib/ejabberd/uploads/" "${tmp_backup_dir}"/data/${node_ipv4}/"
			fi
		done
		unset node_ipv4
	fi

}

restore_loop() {

	echo "${b-}1] Now restoring aenigma config directory...${x-}"
	echo

	rsync -aAXx --delete $restore_file_path/conf/ $conf_dir/

	echo "${b-}2] Now restoring ejabberd database...${x-}"
	echo

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
	        echo "${g-}${b-}ejabberd is already running. Continuing...${x-}"
	        echo
	else
	        echo "${r-}${b-}ejabberd NOT running. Starting it now...${x-}"
	        echo
	        echo "${b-}Now starting ejabberd ...${x-}"
	        /usr/sbin/service ejabberd start
	        echo
	        dna-wait -s "8" -d "Now allowing ejabberd to start up correctly..."
	        /usr/sbin/ejabberdctl
	        echo
	        sleep 1
	fi

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
	        cd $restore_file_path/data/
		cp ./ejabberd-mnesia-backup /var/lib/ejabberd/
	        /usr/sbin/ejabberdctl restore ejabberd-mnesia-backup
		rm /var/lib/ejabberd/ejabberd-mnesia-backup
	        echo "${b-}Successfully restored ejabberd database...${x-}"
	        echo
	        dna-wait -s "8" -d "Now allowing ejabberd sync the database..."
	else
	        echo "${r-}${b-}ERROR: ejabberd STILL NOT running. Unable to restore database from backup.${x-}"
	        echo
	        dna-exit
	fi

	echo "${b-}Now restoring ejabberd directories...${x-}"
	echo

	echo "${b-}Now stopping ejabberd for directory restore...${x-}"
	echo
	/usr/sbin/service ejabberd stop
	dna-wait -s "8" -d "Now allowing ejabberd to shut down correctly..."

	echo "${b-}3] Now syncing ejabberd directories...${x-}"
	echo

	rsync -aAXx --delete $restore_file_path/data/etc-ejabberd/ /etc/ejabberd/
	rsync -aAXx --delete $restore_file_path/data/var-lib-ejabberd/ /var/lib/ejabberd/

	aenigma-set_permissions

	echo "${b-}Now starting ejabberd...${x-}"
	/usr/sbin/service ejabberd start
	echo
	dna-wait -s "8" -d "Now allowing ejabberd to start up correctly..."
	/usr/sbin/ejabberdctl status
	echo
	sleep 1

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then

	        echo "${g-}${b-}Restore complete!${x-}"
	        echo
	        echo "${b-}Now please verify your aenigma instance is running correctly and has everything you except it to.${x-}"
	        echo

	        read -p "${b-}Has your previous instance of aenigma been restored correctly? (Y/n): ${x-}" -n 1 -r
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
	                echo "${g-}${b-}Ok, all done!${x-}"
	                echo
	                if [ -f $conf_dir/blocks3backups ]
	                then
				rm $conf_dir/blocks3backups
	                        echo "${b-}Removing S3 backups lock since your restore has been successful.${x-}"
	                        echo
	                        echo "${r-}${b-}This machine will now pick up where the old one left off and start backing up again to S3 and will overwrite all previous data stored on S3.${x-}"
	                        echo
	                        echo "${b-}If you've changed your mind and are NOT yet sure this restore was completely successful, simply:${x-}"
	                        echo
	                        echo "${b-} | touch $conf_dir/blocks3backups |"
	                        echo
	                        echo "${b-}And remember to remove it as soon as you're done verifying this restored instance to then resume backups to S3!${x-}"
	                        echo
	                        echo "${g-}${b-}All done for now.${x-}"
	                        echo
	                fi
	        else
	                echo
	                echo "${b-}Sorry about that, please collect all evidence you can find so and simply file an issue report at:${x-}"
		        	echo
		        	echo "${b-} | ${git_host}/${author_name}/${project_name}/issues |${x-}"
		        	echo
		        	echo "${b-}Thank you in advance!${x-}"
	                echo
	        fi

	else

	        echo "${r-}${b-}ERROR: ejabberd not running after restore. Please check ejabberd directories.${x-}"
	        echo
	        echo "${b-}Please collect all evidence you can find so and simply file an issue report at:${x-}"
	        echo
	        echo "${b-} | https://github.com/openspace42/aenigma/issues |${x-}"
	        echo
	        echo "${b-}Thank you in advance!${x-}"
	        echo
	        echo "${b-}Exiting...${x-}"
	        echo
	        exit

	fi

	if [ -d "$restores_dir/local/" ]
	then
		rm -r "$restores_dir/local/"
	fi

	if [ -d "/root/${proj_name}-restore/" ]
	then
		rm -r "/root/${proj_name}-restore/"
	fi

	if [ -d "$tmpdir" ]
	then
		rm -r "${tmpdir:?}"
	fi

	if [ $bootstrapmode = "on" ]
	then
		echo "${b-}Now that we're finished with the initial restore, it's time to re-run the install script and get this machine up and running with your old instance's files and settings${x-}"
		echo
		echo "${b-}Running install script now.${x-}"
		echo
		echo "${r-}${b-}Should you exit the install script during its runtime, you can re-run it manually with:${x-}"
		echo
		echo "${b-} | bash $sourcedir/install.sh | ${x-}"
		cd
		bash $sourcedir/install.sh
	fi

}

################################################################################
################################################################################
################################################################################

synthia-perform_installation() {

	############################################################################
	################### Add your install-time functions here ###################
	############################################################################

	### Display aenigma logo

	aenigma-display_logo

	################################################################################

	### Display intro

	if [ "${skip_intro}" = "n" ]
	then
	    aenigma-xmpp_intro
	fi

	################################################################################

	if ! dna-check_distro_ubuntu_18 && ! dna-check_distro_debian_9
	then
		dna-echo -e "${proj_name} only runs on Ubuntu 18.04 LTS [bionic] or Debian 9 [stretch]."
		dna-echo -m "This is due - among other factors - to the fact that the ejabberd version installed by our APT repo of choice on previous releases is too old."
		dna-echo -m "You can edit out this check to proceed at your own risk."
		dna-exit
	fi

	################################################################################

	dna-abort_on_sslh_session

	dna-inception

	################################################################################

	dna-refresh_tmp_project_dir

	mkdir -p "${ssl_project_dir}"

	############################################################################

	clear

	### Ask user if this aenigma node is going to be part of a cluster

	describe_setting() {

		dna-echo -m "${proj_name} can be setup to run in a cluster of multiple servers, all working together to make your instance run smoothly, robustly, and be fault-tolerant and load-balancing."
		dna-echo -m "If you wish to setup ${proj_name} in a cluster configuration, you must specify so now."

	}

	validate_input() {

		case $input in
			single)		valid="y"
						;;
			cluster)	valid="y"
						;;
			*)			dna-echo -e "Invalid setting for | ${n-}cluster_enabled${r-} | in function | ${n-}${FUNCNAME[0]}${r-} |."
						valid="n"
						;;
		esac

	}

	dna-set_option -o "cluster_enabled" -p "cluster" -d "y" -c "[single/cluster]" -v "y"

	if [ "${cluster_enabled}" = "cluster" ]
	then

		describe_setting() {

			dna-echo -m "Having chosen to run ${proj_name} in a cluster of servers, you must now designate your master node that will be performing some special operations to lead the cluster."

		}

		validate_input() {

			case $input in
				primary)	valid="y"
							;;
				secondary)	valid="y"
							;;
				*)			dna-echo -e "Invalid setting for | ${n-}cluster_enabled${r-} | in function | ${n-}${FUNCNAME[0]}${r-} |."
							valid="n"
							;;
			esac

		}

		dna-set_option -o "cluster_mode" -p "cluster" -d "y" -c "[primary/secondary]" -v "y"

		if [ "${cluster_mode}" = "primary" ]
		then
			dna-echo -m "Having chosen that this server will be your primary node for your ${proj_name} installation, we can carry on with the standard installation."
		else
			dna-echo -m "Having chosen that this server will be a secondary node for your ${proj_name} installation, we first need to make sure that there is an already running primary node that is already up and running and perfectly configured."
            dna-ask_for_boolean -d "y" -q "Is the primary node for this ${proj_name} already up and running and perfectly configured?"
            if [ "${boolean_output}" = "y" ]
            then
				dna-echo -m "Ok, let's then continue on with the configuration of this secondary node and proceed to have it join the cluster lead by your already running primary node..."
            else
				dna-echo -m "Ok, no problem. Please proceed with the full installation and configuration of your primary node on its respective server by following the same ${proj_name} install and selecting the | ${y-}primary${n-} | node option when prompted."
				dna-echo -m "Only then will we be able to continue with the installation of this secondary node."
				dna-echo -m "Aborting installation for now."
                dna-exit
            fi
		fi

	fi

	############################################################################
	############################################################################

	if [ ! "${cluster_mode-null}" = "secondary" ]
	then

		########################################################################

		### Start creating the nodes_db files and print this machine [the primary node]'s public IPv4 and IPv6 [if available] to the first line of each
		### We create the nodes_db file independently of whether clusterization is enabled or not.

		if [ "${cluster_enabled}" = "single" ]
		then

			### Clusterization has been turned off. Delete the conf_nodes directory if present.

			if [ -d "${conf_cluster_nodes_dir}" ]
			then
				rm -rf "${conf_cluster_nodes_dir}"
			fi

		fi

		########################################################################

		### Set xmpp domain

	    describe_setting() {

	        dna-echo -m "Now specify your top level domain, which will become the part after the @ in your JIDs [XMPP account addresses]:"

	    }

	    dna-set_option -o "domain" -p "xmpp" -d "y" -v "n"

	    if [ $previous_value_outcome = "not-kept" ]
	    then

	        dna-echo -m "- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -"
	        dna-echo -e "WARNING:"
	        dna-echo -e "Changing domains will not preserve any user accounts or data. It will revert this ejabberd instance to a fresh install."
	        dna-echo -m "In the future, all user accounts and data for the previous domain might be recovered automatically if you ever re-run the install and select the old domain, but this hasn't been thoroughly tested yet."
	        dna-echo -m "If you answer no to the following question, nothing will be deleted."
	        dna-echo -m "- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -"

            dna-ask_for_boolean -d "n" -q "Are you absolutely sure you want to change the XMPP domain now?"
            if [ "${boolean_output}" = "y" ]
            then
	            dna-echo -m "Ok, proceeding..."
	        else
	            dna-echo -m "Ok, setting your domain back to the previous value | ${y-}${previous_value}${n-} |..."
	            domain="${previous_value}"
	            echo "${previous_value}" > "${opt_path}"
	        fi

	    fi

		########################################################################

		### Review and set machine hostname

		curr_host_name="$(cat /etc/hostname)"

	    if [ "${curr_host_name}" = "ae01.${domain}" ]
	    then

			dna-echo -s "Your hostname is already correctly set to: | ${n-}ae01.${domain}${g-} |."

		else

			dna-echo -m "This machine's hostname must become: | ${y-}ae01.${domain}${n-} |."
			dna-echo -m "This allows for a correct setup of ejabberd that will make it possible in the future to turn this instance of ${proj_name} into a cluster should you ever choose to do so."
			dna-echo -m "Your current hostname is:"
			dna-echo -m " | ${y-}${curr_host_name}${n-} | "
            dna-ask_for_boolean -d "y" -q "Do you want to correctly set your hostname automatically?"
            if [ "${boolean_output}" = "y" ]
            then
			    dna-echo -m "Ok, setting hostname to: | ${y-}ae01.${domain}${n-} |."
			    echo "ae01.${domain}" > "/etc/hostname"
			else
			    dna-echo -m "Ok, not changing hostname."
				dna-exit
			fi

	    fi

		hostname="$(cat /etc/hostname)"

		########################################################################

		### Review domain and hostname to see if the user approves

		dna-echo -m "----------------------------------------------------------------"

		dna-echo -m "To make sure everything is correct:"
		dna-echo -m "1] Your | ${o-}XMPP domain${n-} | [the part after the @ in your XMPP account addresses] will be:"
		dna-echo -m " | ${y-}$domain${n-} | "
		dna-echo -m "2] And therefore your | ${o-}JIDs [XMPP account addresses]${n-} | will look as follows:"
		dna-echo -m " | ${y-}aurora@$domain${n-} | "
		dna-echo -m "3] Your | ${o-}hostname${n-} | [the location on the internet of this server] will be:"
		dna-echo -m " | ${y-}$hostname${n-} | "
		dna-echo -m "4] And therefore your | ${o-}${proj_name} admin panel${n-} | will be located at:"
		dna-echo -m " | ${y-}https://$hostname${n-} | "

		dna-echo -m "----------------------------------------------------------------"

		dna-ask_for_boolean -d "y" -q "Does everything look all right?"
		if [ "${boolean_output}" = "y" ]
		then
		    dna-echo -m "Ok, continuing."
		else
		    dna-echo -m "Ok, no worries. You can re-run this script right now and make the correct choices. Exiting..."
		    dna-exit
		fi

		########################################################################

		### Set node_number to 01 as this is the primary node

		dna-set_option -o "node_number" -p "cluster" -s "01"

		### Initialize nodes_db files

		aenigma-initialize_nodes_db_files

		### Update routing info

		aenigma-update_routing_info

	else

		########################################################################

		### As this is a secondary node, we need to join an existing ejabberd cluster and therefore start clean and remove any ejabberd data already present on this server.

		dna-echo -e "Proceeding with this installation as a secondary node will wipe anything and everything that might already present on this [and only this] server."
		dna-echo -m "If this node is currently part of a cluster, data on other nodes will NOT be affected, and this node will re-obtain all cluster data from other nodes upon completion of the installation."
		dna-echo -m "If however you've previously used this machine to host a standalone installation or not-yet-clusterized data, this will be permanently lost."
		dna-echo -m "Please ensure there is no UNIQUE [as in non-clustered] and VALUABLE [as in you don't want to lose] data on this machine."

		dna-ask_for_boolean -d "n" -q "Proceed with wiping any ejabberd-related data on this server during the course of this installation?"
		if [ "${boolean_output}" = "y" ]
		then
			dna-echo -m "Ok, proceeding with ejabberd wipe at the end of this installation..."
		else
			dna-echo -m "Ok, skipping ejabberd wipe and aborting installation."
			dna-exit
		fi

		########################################################################

	fi

	############################################################################
	############################################################################

	### Set admin email address

	dna-set_admin_email

	############################################################################

	### Check internet connectivity and get public IP addresses

	dna-get_public_ipv4

	dna-check_ipv6_connectivity

	############################################################################

	### Create the necessary files and directories for ejabberd

	aenigma-create_ejabberd_locations

	### Create the $conf_xmpp_dir

	mkdir -p "${conf_xmpp_dir}"

	############################################################################

	if [ "${cluster_enabled}" = "cluster" ]
	then

		### Add cronjob for resync_cluster script

		dna-add_cron_job -n "${proj_name}-resync_cluster" -t "@reboot" -c "bash /root/openspace42/${proj_name}/tools/${proj_name}-resync_cluster --return-check"

	fi

	############################################################################
	############################################################################

	if [ ! "${cluster_mode-null}" = "secondary" ]
	then

		### Proceed with primary node installation

		aenigma-perform_dns_checks

		########################################################################

		### Provision the LetsEncrypt wildcard TLS certificate for $domain

	    dna-echo -m "It's time to set up the LetsEncrypt wildcard TLS [SSL] certificate that will be valid for | *.${domain} |."

		dna-provision_le_wildcard_cert -d "${domain}"

		########################################################################

		#### Copy the LetsEncrypt post-renewal script to its location and actually run it now to be ready for the installation

		cp "${source_dir}/conf/letsencrypt/post-renewal-hook" "/etc/letsencrypt/renewal-hooks/post/${proj_name}-create-push-certs"

		### Execute the post-renewal script now to generate the all-in-one TLS cert for ejabberd

		bash "${tools_dir}/${proj_name}-create-push-certs"

		clear

		########################################################################

		### Setup backup restore

		dna-setup_backup_restore

		########################################################################

	else

		### Proceed with secondary node installation

		########################################################################

		### Clear any letsencrypt post-renewal-hook if present from a previous installation in primary node mode

		if [ -f "/etc/letsencrypt/renewal-hooks/post/${proj_name}-create-push-certs" ]
		then
			rm "/etc/letsencrypt/renewal-hooks/post/${proj_name}-create-push-certs"
		fi

		########################################################################

		### Generate token [or use the public IPv6 address of this machine if available] as visual fingerprint for user connection checking

		if [ "${ipv6_available}" = "y" ]
		then
			echo "${this_ipv6}" > "${tmp_project_dir}/aenigma-cluster-token"
		else
			aenigma_cluster_token="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)"
			echo "${aenigma_cluster_token}" > "${tmp_project_dir}/aenigma-cluster-token"
		fi

		########################################################################

		### Temporarily stop ufw to avoid locking out the primary node during installation

		/usr/sbin/ufw --force disable

		########################################################################

		dna-echo -m "This is the public IPv4 for this machine:"
		dna-echo -m " | ${y-}$this_ipv4${n-} | "
		dna-echo -m "Enter it on the primary node when prompted to do so, then follow the instructions from there."

		sleep 1

		########################################################################

		if [ -f "${ssh_auth_keys_file}" ]
		then
	        dna-echo -s "SSH Authorized Keys file found."
		else
			dna-echo -m "SSH Authorized Keys file NOT found. Creating it now."
			mkdir -p "/root/.ssh/"
	        touch "${ssh_auth_keys_file}"
		fi

		########################################################################

		if grep -q "ae01." "${ssh_auth_keys_file}"
		then

			dna-echo -s "An SSH public key generated by the primary node was already previously saved on this server."

			####################################################################

			check_condition() {

				if [ -f "${tmp_project_dir}/aenigma-cluster-ssh-connection-successful" ]
				then
					condition_verified="y"
				fi

			}

			dna-wait_for -m "32" -d "Now looking to see if the primary node is already able to connect to this node..."

			if [ "${wait_output}" = "ok" ]
			then
				dna-echo -s "Primary node SSH connection to this node succeeded. Continuing installation..."
				primary_node_ssh_connection="ok"
				rm -r "${tmp_project_dir}/aenigma-cluster-ssh-connection-successful"
			else
				dna-echo -e "The primary node was not able to connect to this node with the SSH public key already saved on this machine."
				dna-echo -m "You will now need to specify the SSH public key displayed on your primary node."
				dna-echo -m "[or if it manages to connect in the mean time, simply type: | ${y-}skip${n-} |]"
				primary_node_ssh_connection="attempted"
			fi

			unset wait_output

			####################################################################

		fi

		if [ ! "${primary_node_ssh_connection-null}" = "ok" ]
		then

			validate_input() {

				if [ "${input}" = "skip" ]
				then

					if [ -f "${tmp_project_dir}/aenigma-cluster-ssh-connection-successful" ]
					then
						valid="y"
					else
						dna-echo -e "The primary node still does NOT appear to have been able to successfully connect to this node."
						dna-echo -m "Ensure its connection to this machine has actually succeeded and, if not, specify the public SSH key it will display shortly."
						valid=n
					fi

				else

					dna-validate_ssh_pubkey -s -k "${input}"

					if [ "${key_is_valid}" = "y" ]
					then
						valid="y"
					else
						dna-echo -e "The key you specified does NOT appear to be a valid SSH Public Key."
						valid="n"
					fi

				fi

			}

			if [ "${primary_node_ssh_connection-null}" = "attempted" ]
			then
				dna-set_value -d "Now specify the public SSH key [or write | ${y-}skip${n-} | if the connection was already successful]:" -v "y"
			else
				dna-set_value -d "Now specify the public SSH key that will be displayed shortly on the primary node:" -v "y"
			fi

			cluster_ssh_pubkey="${value}"

			if [ ! "${value}" = "skip" ]
			then

				if ! grep -q "${cluster_ssh_pubkey}" "${ssh_auth_keys_file}"
				then
					echo "$cluster_ssh_pubkey" >> "${ssh_auth_keys_file}"
				fi

			fi

			unset value

		fi

		################################################################################

		### Print clusterization token and instructions

		dna-echo -m "A token has been generated to verify a correct connection to this machine from the primary node."
		dna-echo -m "You'll be asked to verify it matches with the one that will shortly be displayed on the primary node."
		dna-echo -m "Its value is: | ${y-}$(cat ${tmp_project_dir}/aenigma-cluster-token)${n-} |."

		dna-echo -m "After that, continue the setup on the primary node and come back here when finished."

		sleep 1

		########################################################################

		check_condition() {

			if [ -f "${tmp_project_dir}/aenigma-cluster-primary-node-setup-complete" ]
			then
				condition_verified="y"
			fi

		}

		dna-wait_for -d "Now waiting for setup on the primary node to be complete..."
		rm -r "${tmp_project_dir}/aenigma-cluster-primary-node-setup-complete"
		dna-echo -s "Primary node setup complete. Now continuing installation..."
		unset wait_output
		sleep 1

		########################################################################

		### Re-enable ufw

		/usr/sbin/ufw --force enable

		########################################################################

		### Read newly received config

		dna-read_conf_settings

		### Set hostname according to the node_number from the newly received config

		echo "ae${node_number}.${domain}" > "/etc/hostname"

		hostname="$(cat /etc/hostname)"

		########################################################################

	fi

	############################################################################
	############################################################################

	### Set UFW rules

	dna-echo -m "Now setting UFW rules..."

	ufw allow 5222
	ufw allow 5223
	ufw allow 5269
	ufw allow 5444
	ufw allow 80
	ufw allow 443

	echo

	############################################################################

	### Stop SSLH to avoid any conflicts with a brand new nginx installation

	if systemctl is-active --quiet sslh
	then

		dna-echo -m "Now stopping SSLH..."
		/usr/sbin/service sslh stop
		dna-echo -s "Finished stopping SSLH."

	fi

	### Install nginx and configure ejabberd admin panel reverse proxy site

	dna-install_dependencies -e -p "nginx"

	############################################################################

	### Create and configure the $hostname website

	if [ -f "/etc/nginx/sites-available/default" ]
	then
		rm "/etc/nginx/sites-available/default"
	fi

	if [ -L "/etc/nginx/sites-enabled/default" ]
	then
		rm "/etc/nginx/sites-enabled/default"
	fi

	cp "${source_dir}/conf/nginx/hostname" "/etc/nginx/sites-available/${proj_name}"

	sed -i "s/hostname.xyz/${hostname}/g" "/etc/nginx/sites-available/${proj_name}"
	sed -i "s/domain.xyz/${domain}/g" "/etc/nginx/sites-available/${proj_name}"

	mkdir -p "/var/www/${hostname}/"
	chown -R "www-data:www-data" "/var/www/${hostname}/"

	cp "${source_dir}/conf/web/hostname/index.html" "/var/www/${hostname}/"

	if [ ! -L "/etc/nginx/sites-enabled/${proj_name}" ]
	then
		ln -s "/etc/nginx/sites-available/${proj_name}" "/etc/nginx/sites-enabled/${proj_name}"
	fi

	### Reload nginx

	service nginx reload || true

	### Restart nginx

	/usr/sbin/service nginx restart || true

	############################################################################

	### Install SSLH

	aenigma-install_sslh

	############################################################################
	############################################################################

	if [ ! "${cluster_mode-null}" = "secondary" ]
	then

		### Determine if this is a fresh install

		if [ ! -f "/var/lib/ejabberd/LATEST.LOG" ]
		then

			### This is a fresh install, we can proceed with customizing the ERLANG_NODE value in the /etc/default/ejabberd config file and wiping the data directory after installing ejabberd.

			set_erlang_node_to_hostname="ok"
			wipe_var_lib_ejabberd="ok"

		else

			### This is a re-install.

			wipe_var_lib_ejabberd="no"

			### Check to see if config file already exists.

			if [ -f "/etc/default/ejabberd" ]
			then

				### The config file is in place. Check to see if the ERLANG_NODE value is already correct.

				if grep -q "^ERLANG_NODE=ejabberd@${hostname}$" "/etc/default/ejabberd"
				then

					### The configuration is already correct, the existing data in /var/lib/ejabberd will work fine.

					set_erlang_node_to_hostname="no"

				else

					### Check to see if the ERLANG_NODE line exists

					if ! grep -q "ERLANG_NODE=ejabberd@" "/etc/default/ejabberd"
					then

						dna-echo -e "There is an error in your existing | ${n-}/etc/default/ejabberd${r-} | file as the | ${n-}ERLANG_NODE${r-} | setting is missing."
						dna-echo -m "The installation will continue without any issues, but ejabberd might refuse to start at the end if your existing data in | ${y-}/var/lib/ejabberd/${n-} | indicates that ejabberd was previously running under a different ERLANG_NODE value."
						dna-echo -m "If this is the case, after the installation is complete, edit the | ${y-}/etc/default/ejabberd${n-} | file and set the ERLANG_NODE value back to whatever you were using before [likely | ${y-}ERLANG_NODE=ejabberd@localhost${n-} |]."
						dna-echo -m "Keep in mind, though, that altering the ERLANG_NODE value will make it impossible to turn this instance of $proj_name into a cluster in the future."
						dna-echo -m "To do that, you will have to start fresh by deleting the | ${y-}/var/lib/ejabberd/${n-} | directory and run an re-install in order to start using the brand new instance from scratch."
						read -rp "${b-}Press enter to continue...${x-}"
						echo

						set_erlang_node_to_hostname="ok"

					else

						### Check to see if the ERLANG_NODE line is commented or its value is set to localhost

						if grep -q "#ERLANG_NODE=ejabberd@" "/etc/default/ejabberd" || grep -q "^ERLANG_NODE=ejabberd@localhost$" "/etc/default/ejabberd"
						then

							dna-echo -e "Your existing | ${n-}/etc/default/ejabberd${r-} | config file indicates that you were previously using this instance with a previous version of ${proj_name}."

						else

							dna-echo -e "Your existing | ${n-}/etc/default/ejabberd${r-} | config file indicates that you were previously using this instance of ${proj_name} with a different hostname than the current one."

						fi

						dna-echo -m "If you choose to continue with the upgrade/re-install, the installation will continue without any issues, but it will be impossible to turn this instance of $proj_name into a cluster in the future."
						dna-echo -m "To do that, you will have to start fresh by deleting the | ${y-}/var/lib/ejabberd/${n-} | directory and run an re-install in order to start using the brand new instance from scratch."
						read -rp "${b-}Press enter to continue...${x-}"
						echo

						set_erlang_node_to_hostname="no"

					fi

				fi

			else

				### It's possible the installation was never completed in the first place, this might explain the lack of a configuration file.

				if [ -f "${conf_dir}/version/version_installed" ]
				then

					### An installation was actually completed at some point. Proceed with warning the user.

					dna-echo -e "The | ${n-}/etc/default/ejabberd${r-} | configuration file of this existing installation of ${proj_name} is missing."
					dna-echo -m "The installation will continue without any issues, but ejabberd might refuse to start at the end if your existing data in | ${y-}/var/lib/ejabberd/${n-} | indicates that ejabberd was previously running under a different ERLANG_NODE value."
					dna-echo -m "If this is the case, after the installation is complete, edit the | ${y-}/etc/default/ejabberd${n-} | file and set the ERLANG_NODE value back to whatever you were using before [likely | ${y-}ERLANG_NODE=ejabberd@localhost${n-} |]."
					dna-echo -m "Keep in mind, though, that altering the ERLANG_NODE value will make it impossible to turn this instance of $proj_name into a cluster in the future."
					dna-echo -m "To do that, you will have to start fresh by deleting the | ${y-}/var/lib/ejabberd/${n-} | directory run an re-install in order to and start using the brand new instance from scratch."
					read -rp "${b-}Press enter to continue...${x-}"
					echo

				fi

				set_erlang_node_to_hostname="ok"

			fi

		fi

	else

		### This is a secondary node install, the user has already consented to a full wipe, we can therefore proceed with customizing the ERLANG_NODE value in the ejabberdctl.cfg config file and wiping the data directory after installing ejabberd.

		set_erlang_node_to_hostname="ok"
		wipe_var_lib_ejabberd="ok"

	fi

	############################################################################
	############################################################################

	### Prepare APT for ejabberd installation.

	aenigma-add_ejabberd_repo

	############################################################################

	### Check the current status of ejabberd on this machine

	aenigma-get_ejabberd_installed_version

	if [ ! "${ejabberd_installed_version}" = "none" ]
	then

		### ejabberd is currently installed. Check if an ejabberd upgrade is going to be performed.

		aenigma-get_ejabberd_candidate_version

		if [ ! "${ejabberd_candidate_version}" = "${ejabberd_installed_version}" ]
		then

			dna-echo -s "A new version of ejabberd is available from the APT repository. Upgrading it now..."

			### Upgrade ejabberd by non-interactively installing the new config files
			### [which we'll the re-replace later in the installation anyway].

			export DEBIAN_FRONTEND=noninteractive ; apt-get install -y -o Dpkg::Options::="--force-confnew" --force-yes --only-upgrade ejabberd || true

		fi

	else

		### Remove the "ejabberd_admin_password_set" file if it exists as ejabberd was not currently installed

		if [ -f "${conf_xmpp_dir}/ejabberd_admin_password_set" ]
		then
			rm "${conf_xmpp_dir}/ejabberd_admin_password_set"
		fi

	fi

	############################################################################

	### Install the aenigma ejabberd config.

	aenigma-install_ejabberd_config

	### Perform a full APT upgrade

	dna-apt_full_upgrade -e

	### Actually install ejabberd.

	aenigma-install_ejabberd

	############################################################################

	### Stop ejabberd if it's already running [i.e. because it was already installed]

	if systemctl is-active --quiet ejabberd
	then

		dna-echo -m "Now stopping ejabberd..."
		/usr/sbin/service ejabberd stop
		dna-wait -s "4" -d "Now allowing ejabberd to shut down correctly..."
		dna-echo -s "Finished stopping ejabberd."

	fi

	### Set permissions now that user ejabberd exists while ejabberd has still not started yet

	aenigma-set_permissions

	### Perform some changes on the ejabberd config files.

	sed -i "s/xe.@/xe${node_number}.@/g" /etc/ejabberd/ejabberd.yml
	sed -i "s/xm.@/xm${node_number}.@/g" /etc/ejabberd/ejabberd.yml
	sed -i "s/xp.@/xp${node_number}.@/g" /etc/ejabberd/ejabberd.yml
	sed -i "s/xu.@/xu${node_number}.@/g" /etc/ejabberd/ejabberd.yml

	sed -i "/INET_DIST_INTERFACE=/c\INET_DIST_INTERFACE=${this_ipv4}" "/etc/default/ejabberd"

	if [ "${set_erlang_node_to_hostname}" = "ok" ]
	then
		sed -i "/# ERLANG_NODE/d" /etc/default/ejabberd
		sed -i "/ERLANG_NODE=/c\ERLANG_NODE=ejabberd@${hostname}" /etc/default/ejabberd
	fi

	if [ "${wipe_var_lib_ejabberd}" = "ok" ]
	then

		/usr/sbin/service ejabberd stop 2> /dev/null || true
		( cd /var/lib/ejabberd/ && find -maxdepth 1 ! -name .erlang.cookie ! -name uploads ! -name . -exec rm -rv {} \; ) > /dev/null

	fi

	dna-echo -m "Now finally starting up ejabberd..."
	/usr/sbin/service ejabberd start
	dna-wait -s "16" -d "Now allowing ejabberd to start up correctly..."
	/usr/sbin/ejabberdctl status
	echo
	dna-echo -s "Finished starting ejabberd back up."

	############################################################################
	############################################################################

	if [ ! "${cluster_mode-null}" = "secondary" ]
	then

		### Add backup script to crontab

		dna-add_cron_job -n ${proj_name}-backup -t "8 4 * * *" -c "bash /root/openspace42/${proj_name}/tools/${proj_name}-backup"

		### Register ejabberd admin user

		dna-echo -m "Now registering ejabberd admin user [if it doesn't yet exist]..."
		ejab_admin_pw="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)"
		/usr/sbin/ejabberdctl register admin "$domain" "$ejab_admin_pw" &> /dev/null || true
		dna-echo -s "Finished registering ejabberd admin user."

		if [ -f "${conf_xmpp_dir}/ejabberd_admin_password_set" ]
		then
            dna-ask_for_boolean -d "y" -q "Leave ejabberd admin user password the same as previously set?"
            if [ "${boolean_output}" = "y" ]
            then
		        dna-echo -m "Ok, skipping ejabberd admin user password reset."
		        ejab_admin_pwreset="n"
		    else
		        echo
		        dna-echo -m "Ok, resetting ejabberd admin user password to: | ${y-}${ejab_admin_pw}${n-} |."
		        /usr/sbin/ejabberdctl change_password admin "${domain}" "${ejab_admin_pw}"
		        ejab_admin_pwreset="y"
		    fi
		else
		    touch "${conf_xmpp_dir}/ejabberd_admin_password_set"
		    ejab_admin_pwreset="y"
		fi

		### Update ejabberd's module repo

		dna-echo -m "Now updating ejabberd's module repo..."
		set +e
		/usr/sbin/ejabberdctl modules_update_specs
		set -e
		dna-echo -s "Finished updating ejabberd's module repo..."

		### Create shared roster groups

		dna-echo -m "Now creating 'ADMIN:EVERYBODY' and 'ADMIN:ONLINE' shared roster groups [admin@${domain} can see 'everybody' and 'all online']..."
		/usr/sbin/ejabberdctl srg_create everybody "$domain" "everybody [$domain]" "This aenigma group includes every user on this domain" ""
		/usr/sbin/ejabberdctl srg-user-add @all@ localhost everybody "$domain"
		/usr/sbin/ejabberdctl srg_create online "$domain" "online [$domain]" "This aenigma group includes every user who is online on this domain" ""
		/usr/sbin/ejabberdctl srg-user-add @online@ localhost online "$domain"
		/usr/sbin/ejabberdctl srg_create admin "$domain" admin "This is a shared roster group set by aenigma" "everybody\\nonline"
		/usr/sbin/ejabberdctl srg-user-add admin "$domain" admin "$domain"
		dna-echo -s "Finished creating shared roster groups."

	fi

	############################################################################
	############################################################################

	### Run some generic operations to catch services status output and alert the user if something has gone wrong.

	declare -A service_checker_array=(
			[APT]="apt-get -y upgrade"
			[NGINX]="/usr/sbin/service nginx restart"
			[SSLH]="/usr/sbin/service sslh restart"
		)

	add_service_check_bottom_spacing() {

		if [ "${service}" = "APT" ]
		then
			echo
		fi

	}

	for service in "${!service_checker_array[@]}"
	do

		set +e

		if ${service_checker_array[$service]}
		then
			add_service_check_bottom_spacing
			dna-echo -s "All | ${n-}${service}${g-} | operations completed successfully."
		else
			add_service_check_bottom_spacing
			dna-echo -e "An error has occured during | ${n-}${service}${g-} | operations."
			dna-echo -m "This was one of the last steps in this installation, so it's possible that your end result is at least partially working."
			dna-echo -m "Review the output above and try running the installation again."
			read -rp "${b-}[press enter to continue reading...]${x-}"
		fi

		set -e

	done

	############################################################################
	############################################################################

	if [ ! "${cluster_mode-null}" = "secondary" ]
	then

		### Pring login information and credentials

		dna-echo -s "You can finally log in to your web administration panel:"
		dna-echo -m " | ${y-}https://${hostname}${n-} | "
		dna-echo -m " | ${y-}admin@${domain}${n-} | "

		if [ "${ejab_admin_pwreset}" = "y" ]
		then
		    dna-echo -m " | ${y-}${ejab_admin_pw}${n-} | "
		else
		    dna-echo -m " | ${y-}[your previously set password]${n-} | "
		fi

		dna-press_to_continue

		if [ "${cluster_mode-null}" = "primary" ]
		then

			dna-echo -m "It's now time to run the | ${o-}clusterize${n-} | script to start adding your secondary nodes."
            dna-ask_for_boolean -d "y" -q "Are you ready to do so now?"
            if [ "${boolean_output}" = "y" ]
            then
				dna-echo -n -m "Ok, running the | ${o-}clusterize${n-} | script now..."
				bash "${tools_dir}/${proj_name}-clusterize"
			else
				dna-echo -m "Ok, you can run the | ${o-}clusterize${n-} | script at any time by executing:"
				dna-echo -m " | ${y-}bash ${tools_dir}/${proj_name}-clusterize${n-} | "
				read -rp "${b-}[press enter to continue reading...]${x-}"
				echo
			fi

		fi

	else

		########################################################################

		dna-echo -m "Now joining ejabberd cluster by connecting to the primary node..."

		if /usr/sbin/ejabberdctl --no-timeout join_cluster "ejabberd@ae01.${domain}"
		then
			dna-echo -s "The ejabberd cluster was successfully joined!"
		else
			dna-echo -e "The ejabberd cluster join operation failed."
			dna-echo -m "Inspect the | ${y-}/var/log/ejabberd/error.log${n-} | logfile for more information."
			dna-exit
		fi

		########################################################################

	fi

	############################################################################
	############################################################################

	### Generate aenigma-specific DHparam file

	dna-generate_project_specific_dhparam

	### If DHparam file was found or generated, amend the config file to include them:

	if [ "${dh_param_status}" = "ok" ]
	then

		if grep -q "### dhfile" "/etc/ejabberd/ejabberd.yml"
		then

			sed -i "s|### dhfile: 'DHFILE'|dhfile: 'DHFILE'|g" "/etc/ejabberd/ejabberd.yml"
			sed -i "s|### s2s_dhfile: 'DHFILE'|s2s_dhfile: 'DHFILE'|g" "/etc/ejabberd/ejabberd.yml"

			dna-echo -m "Now restarting ejabberd..."

			/usr/sbin/service ejabberd restart

		fi

	fi

	############################################################################

	dna-remove_tmp_project_dir

	############################################################################
	############################################################################
	############################################################################

}

################################################################################
