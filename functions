#!/usr/bin/env bash

### openspace synthia bootstrap framework
### [https://github.com/openspace42/synthia]
### v0.3.2

dna_version="v0.3.12"

################################################################################

synthia-define_vars() {

	############################################################################
	#################### Insert your initial variables here ####################
	############################################################################

	export proj_name="aenigma"
	export author_name="openspace42"
	export git_host="https://github.com"

	### Set this to `y` if your project stores no data on end users' machines that could go lost during a re-install or update
	export skip_install_time_backup="n"

	### Set this to the directory that has the most impactful size when performing a backup [such as `/var/www/` for nginx-related projects]
	export backup_ref_dir="/var/lib/ejabberd"

	############################################################################
	############################################################################
	############################################################################

	### Do NOT edit the following line

	dna-define_vars

	############################################################################
	################## Insert your additional variables here ###################
	############################################################################

	### Set the paths to the cluster / nodes conf dirs

	export conf_cluster_dir="${conf_dir}/cluster"
	export conf_cluster_nodes_dir="${conf_cluster_dir}/nodes"

	export conf_xmpp_dir="${conf_dir}/xmpp"

	### Set the path to the domains_db file

	export domains_db_path="${conf_xmpp_dir}/domains_db"

	### Set the paths to the nodes_db files

	export nodes_db_ipv4_path="${conf_cluster_nodes_dir}/nodes_db_ipv4"
	export nodes_db_ipv6_path="${conf_cluster_nodes_dir}/nodes_db_ipv6"
	export nodes_db_numbered_path="${conf_cluster_nodes_dir}/nodes_db_numbered"
	export nodes_db_online_path="${tmp_project_dir}/nodes_db_online"
	export nodes_db_initial_path="${tmp_project_dir}/nodes_db_initial"

	############################################################################
	############################################################################
	############################################################################

}

################################################################################

synthia-define_formatting() {

	r=$'\e[1;31m'
	g=$'\e[1;32m'
	l=$'\e[1;34m'
	m=$'\e[1;35m'
	y=$'\e[1;33m'
	o=$'\e[38;5;208m'
	c=$'\e[1;36m'
	n=$'\e[1;39m'
	x=$'\e[0m'
	b=$'\033[1m'

}

synthia-check_root() {

	if [[ $EUID -ne 0 ]]
	then
		echo "${r-}${b-}This script must be run as root.${x-}"
		echo
		echo "${b-}Exiting...${x-}"
		echo
		exit 1
	fi

}

synthia-download_dna() {

	clone_host="https://github.com"
	clone_author="openspace42"
	clone_name="dna"

	clone_base_dir="/root/${clone_author}"
	clone_dir="${clone_base_dir}/${clone_name}"

	mkdir -p "${clone_base_dir}"

	if [ "${custom_dna_version-}" = "l" ]
	then

		export dna_selected_vers="v0.0.1-custom-local"

		echo "${r-}${b-}Sourcing | ${n-}local version${r-} | of | ${n-}dna${r-} | respecting any local alteration performed as per | ${n-}-d l${r-} |.${x-}"

		echo "${dna_selected_vers}" > "./version_installed"

	else

		if [ -d "${clone_dir}" ]
		then
			rm -r "${clone_dir:?}"
		fi

		( cd "${clone_base_dir}" && git clone "${clone_host}/${clone_author}/${clone_name}" && echo && cd "${clone_name}"

			. ./functions/snippets

			git config advice.detachedHead false

			### Define latest version

			export dna_latest_vers_final="$(semtag getfinal)"
			export dna_latest_vers_tagged="$(semtag getlast)"
			export dna_latest_vers_bl_edge="$(semtag getcurrent)"

		    if [ "${custom_dna_version-}" = "b" ]
		    then

		        export dna_selected_vers="${dna_latest_vers_bl_edge}"

		        echo "${r-}${b-}Installing | ${n-}bleeding-edge version${r-} | of | ${n-}dna${r-} | up to latest git commit as per | ${n-}-d b${r-} |.${x-}"
				echo

				git fetch
		        git reset --hard origin/master

			elif [[ "${custom_dna_version-}" == *"v"* ]]
			then

				export dna_selected_vers="${custom_dna_version}"

				echo "${c-}${b-}Installing | ${n-}version ${dna_selected_vers}${c-} | of | ${n-}dna${c-} | as per | ${n-}-d ${dna_selected_vers}${c-} |.${x-}"
				echo

				git checkout "tags/${dna_selected_vers}"

		    elif [ "${custom_dna_version-}" = "t" ]
		    then

		        export dna_selected_vers="${dna_latest_vers_tagged}"

		        echo "${o-}${b-}Installing | ${n-}latest-tagged version [${dna_selected_vers}]${o-} | of | ${n-}dna${o-} | [independently of its stability type] as per | ${n-}-d t${o-} |.${x-}"
				echo

		        git checkout "tags/${dna_latest_vers_tagged}"

		    elif [ "${custom_dna_version-}" = "f" ]
			then

		        export dna_selected_vers="${dna_latest_vers_final}"

				echo "${y-}${b-}Installing | ${n-}latest-final version [${dna_selected_vers}]${y-} | of | ${n-}dna${y-} | as per | ${n-}-d f${y-} |.${x-}"
				echo

		        git checkout "tags/${dna_latest_vers_final}"

			else

				export dna_selected_vers="${dna_version}"

				echo "${b-}Installing | ${g-}version [${dna_selected_vers}]${n-} | of | ${g-}dna${n-} |.${x-}"
				echo

				git checkout "tags/${dna_version}"

		    fi

			echo "${dna_selected_vers}" > "./version_installed"

		)

	fi

}

synthia-source_dna() {

	for f in /root/openspace42/dna/functions/*
	do
		. $f
	done

}

################################################################################

################################################################################
######################## Insert project functions here #########################
################################################################################

aenigma-display_logo() {

	### Add delay for previous outputs

	sleep 1

	### Determine terminal window size

	columns_number="$(tput cols)"
	rows_number="$(tput lines)"

	### Check that the terminal window is large enough to display the logo

	if [ "${columns_number}" -ge "93" ] && [ "${rows_number}" -ge "24" ]
	then

	    ### Determine terminal window horizontal center

	    columns_median="$(echo $((columns_number / 2)))"

	    ### The aenigma logo is 45 pixels and therefore 90 columns wide, therefore...

	    base_column="$(echo $((columns_median - 45)))"

		### Determine terminal window vertical center

	    rows_median="$(echo $((rows_number / 2)))"

	    ### The aenigma logo is 17 rows tall, therefore...

	    base_row="$(echo $((rows_median - 9)))"

		### Determine bottom padding

		bottom_padding="$(echo $((base_row - 2)))"

	    ### Set colors

	    b=$'\e[38;5;16m'
	    w=$'\e[38;5;15m'

	    l=$'\e[38;5;33m'

	    x=$'\e[0m'
	    z=$'\e[8m'

	    ### Set white base for all lines
	    set p02{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p03{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p04{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p05{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p06{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p07{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p08{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p09{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p10{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p11{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p12{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p13{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p14{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p15{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p16{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p17{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item

	    ### Line 03

	    eval p0319='$b'

	    ### Line 06

	    eval p06{03..09}='$l'
	    eval p06{11..17}='$b'
	    eval p0619='$b'
	    eval p06{21..27}='$b'
	    eval p06{29..35}='$b'
	    eval p06{38..43}='$b'

	    ### Lines {07..08}

	    eval p{07..08}06='$l'
		eval p{07..08}{07..08}='$b'
	    eval p{07..08}09='$l'
	    eval p{07..08}11='$b'
	    eval p{07..08}17='$b'
	    eval p{07..08}19='$b'
	    eval p{07..08}21='$b'
	    eval p{07..08}27='$b'
	    eval p{07..08}29='$b'
	    eval p{07..08}32='$b'
	    eval p{07..08}35='$b'
	    eval p{07..08}43='$b'

	    ### Line 09

	    eval p09{03..09}='$l'
	    eval p0911='$b'
	    eval p0917='$b'
	    eval p0919='$b'
	    eval p0921='$b'
	    eval p0927='$b'
	    eval p0929='$b'
	    eval p0932='$b'
	    eval p0935='$b'
	    eval p09{37..43}='$b'

	    ### Lines {10..11}

	    eval p{10..11}03='$l'
		eval p{10..11}{04..05}='$b'
	    eval p{10..11}06='$l'
	    eval p{10..11}11='$b'
	    eval p{10..11}17='$b'
	    eval p{10..11}19='$b'
	    eval p{10..11}21='$b'
	    eval p{10..11}27='$b'
	    eval p{10..11}29='$b'
	    eval p{10..11}32='$b'
	    eval p{10..11}35='$b'
	    eval p{10..11}37='$b'
	    eval p{10..11}43='$b'

	    ### Line 12

	    eval p12{03..09}='$l'
	    eval p1211='$b'
	    eval p1217='$b'
	    eval p1219='$b'
	    eval p12{21..27}='$b'
	    eval p1229='$b'
	    eval p1232='$b'
	    eval p1235='$b'
	    eval p12{37..43}='$b'

	    ### Lines {13..14}

	    eval p{13..14}27='$b'

	    ### Line 15

	    eval p15{22..27}='$b'

	    ### Set borders

	    set p01{01..45} && array="$@" && for item in $array; do eval $item='$b'; done && unset array item
	    set p17{01..45} && array="$@" && for item in $array; do eval $item='$b'; done && unset array item
	    eval p{01..17}01='$b'
	    eval p{01..17}45='$b'

		### Clear

		clear

		### Print top padding

		yes '' | sed ${base_row}q

	    ### Print

	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p01{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p02{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p03{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p04{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p05{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p06{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p07{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p08{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p09{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p10{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p11{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p12{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p13{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p14{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p15{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p16{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p17{01..45}██ | tr -d ' ')"

		### Reset formatting

	    echo ${x}

		unset b w l x z

		synthia-define_formatting

		### Print bottom padding

		yes '' | sed ${bottom_padding}q

		### Add delay

		sleep 2

		### Clear

		clear

	fi

}

aenigma-xmpp_intro() {

	dna-echo -m "First of all, a little introduction on how XMPP actually works"
	dna-echo -m "XMPP works very much like email. You can have a domain [amsterdamhacklab.xyz] and receive email for that domain on a server located at mx01.amsterdamhacklab.xyz, by using the appropriate DNS configuration, and also have other servers [webserver, mapserver, etc...] on other subdomains."
	dna-echo -m "In that case, a DNS MX record tells sending servers to direct mail intended for amsterdamhacklab.xyz to mx01.amsterdamhacklab.xyz."
	dna-echo -m "In the same way, the XMPP server for amsterdamhacklab.xyz can be located at ae01.amsterdamhacklab.xyz and a DNS SRV record tells any sending servers that XMPP for that domain [i.e. a message directed to mark@amsterdamhacklab.xyz] is handled by the server located at ae01.amsterdamhacklab.xyz."

	read -rp "${b-}[press enter to continue reading...]${x-}"
	clear

	dna-echo -m "$proj_name fully embraces this opportunity."
	dna-echo -m "The domain for which you're setting up your new $proj_name server can definitely be a domain connected to a bigger project, that already points to other servers, and for which XMPP is just another service."
	dna-echo -m "This will give you working @amsterdamhacklab.xyz JIDs [XMPP account addresses], but the $proj_name server will reside at ae01.amsterdamhacklab.xyz, as in the following example:"
	dna-echo -m "${o-}Domain:${n-}               ${y-}amsterdamhacklab.xyz.${n-}"
	dna-echo -m "${o-}Website:${n-}              ${y-}amsterdamhacklab.xyz${n-} / ${y-}www.amsterdamhacklab.xyz${n-} [hosted by another server]."
	dna-echo -m "${o-}Your JID format:${n-}      ${y-}mark@amsterdamhacklab.xyz.${n-}"
	dna-echo -m "${o-}XMPP server:${n-}          ${y-}xmpp.amsterdamhacklab.xyz${n-}"

	read -rp "${b-}[press enter to continue reading...]${x-}"
	clear

	### Add cluster info here

	dna-echo -m "Now that you know how XMPP works, let's get your brand new $proj_name server up and running!"

}

aenigma-set_secondary_node_hostname() {

	### Set hostname according to the node_number from the newly received config

	echo "ae${node_number}.${domain}" > "/etc/hostname"

	hostname="$(cat /etc/hostname)"

	hostname -F "/etc/hostname"

}

aenigma-provision_nginx() {

	############################################################################

	dna-get_hostname

	############################################################################

	### Stop SSLH to avoid any conflicts with a brand new nginx installation

	if systemctl is-active --quiet sslh
	then

		operation_message="stopping SSLH"
		dna-echo_operation -h

		service sslh stop

		dna-echo_operation -t

	fi

	### Install nginx and configure ejabberd admin panel reverse proxy site

	dna-install_nginx

	############################################################################

	### Create web locations and populate it

	mkdir -p "/var/www/${proj_name}/"
	chown -R "www-data:www-data" "/var/www/${proj_name}/"

	cp "${source_dir}/conf/web/global/index.html" "/var/www/${proj_name}/"

	############################################################################

	### Create and configure the $hostname website

	if [ -f "/etc/nginx/conf.d/default.conf" ]
	then
		rm "/etc/nginx/conf.d/default.conf"
	fi

	cp "${source_dir}/conf/nginx/domain" "/etc/nginx/conf.d/${domain}.conf"

	sed -i "s/hostname.xyz/${hostname}/g" "/etc/nginx/conf.d/${domain}.conf"
	sed -i "s/domain.xyz/${domain}/g" "/etc/nginx/conf.d/${domain}.conf"

	### Delete default_server setting in $domain nginx conf file in case .onion
	### nginx conf is present and already has default_server setting itslef

	if [ -f "/etc/nginx/conf.d/onion.conf" ]
	then

		if grep -q "default_server" "/etc/nginx/conf.d/onion.conf"
		then

			sed -i "s|443 default_server ssl|443 ssl|g" "/etc/nginx/conf.d/${domain}.conf"

		fi

	fi

	############################################################################

	if [ ! "${additional_domains-}" = "none" ]
	then

		additional_domains_array=(${additional_domains})
		for additional_domain in "${additional_domains_array[@]}"
	    do

			cp "${source_dir}/conf/nginx/additional_domain" "/etc/nginx/conf.d/${additional_domain}.conf"

			sed -i "s/additional_domain-var/${additional_domain}/g" "/etc/nginx/conf.d/${additional_domain}.conf"

			sed -i "s/hostname.xyz/${hostname}/g" "/etc/nginx/conf.d/${additional_domain}.conf"
			sed -i "s/domain.xyz/${domain}/g" "/etc/nginx/conf.d/${additional_domain}.conf"

	    done

	fi

	############################################################################

	### Start sslh back up if it's already installed

	operation_message="starting SSLH back up"
	dna-echo_operation -h

	if which sslh &> /dev/null
	then

		service sslh start

	fi

	dna-echo_operation -t

	### Start nginx back up

	operation_message="starting NGINX back up"
	dna-echo_operation -h

	service nginx restart || true

	dna-echo_operation -t

	############################################################################

}

aenigma-install_sslh() {

	dna-install_sslh

	### Customize config file for aenigma

	operation_message="customizing SSLH config for ${proj_name}"
	dna-echo_operation -h

	cp "${source_dir}/conf/sslh/etc-sslh.cfg" "/etc/sslh.cfg"

	dna-localize_sslh_install

	sed -i "s|domain-var|${domain}|g" "/etc/sslh.cfg"
	sed -i "s|hostname-var|${hostname}|g" "/etc/sslh.cfg"
	sed -i "s|ssh_port-var|${ssh_port}|g" "/etc/sslh.cfg"
	sed -i "s|xh.|xh${node_number}.|g" "/etc/sslh.cfg"

	if [ ! "${additional_domains-}" = "none" ]
	then

		> "${tmp_project_dir}/additional_domains_sslh_xh.txt"
		additional_domains_array=(${additional_domains})
		for additional_domain in "${additional_domains_array[@]}"
	    do
			echo "    { name: \"tls\"; host: \"localhost\"; port: \"5443\"; sni_hostnames: [ \"xh${node_number}.${additional_domain}\"]; log_level: 1; }," >> "${tmp_project_dir}/additional_domains_sslh_xh.txt"
	    done

		> "${tmp_project_dir}/additional_domains_sslh_ae.txt"
		additional_domains_array=(${additional_domains})
		for additional_domain in "${additional_domains_array[@]}"
	    do
			echo "    { name: \"tls\"; host: \"localhost\"; port: \"5223\"; sni_hostnames: [ \"ae${node_number}.${additional_domain}\" ]; log_level: 1; }," >> "${tmp_project_dir}/additional_domains_sslh_ae.txt"
	    done

		sed -i "/\"xh/ r ${tmp_project_dir}/additional_domains_sslh_xh.txt" "/etc/sslh.cfg"
		sed -i "/\"ae/ r ${tmp_project_dir}/additional_domains_sslh_ae.txt" "/etc/sslh.cfg"

	fi

	/usr/sbin/service sslh restart

	dna-echo_operation -t

}

aenigma-restart_ejabberd_if_running() {

	############################################################################

	### Restart ejabberd if it's already installed and running

	############################################################################

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then

		operation_message="restarting ejabberd"
		dna-echo_operation -h

		if service ejabberd restart
		then

			dna-echo_operation -t

		else

			echo
			dna-echo -e "ejabberd failed during restart"
			dna-echo -m "Continuing anyway as this should fix itself automatically by the end of the installation."
			sleep 3

		fi

	else

		dna-echo -m "ejabberd not running. Skipping restart."

	fi

	############################################################################

}

aenigma-start_ejabberd() {

	############################################################################

	### Start ejabberd if it's already installed

	############################################################################

	dna-get_hostname

	if dpkg -s ejabberd &> /dev/null
	then

		operation_message="starting ejabberd on node: | ${l-}${hostname}${n-} |."
		dna-echo_operation -h

		service ejabberd start

		dna-wait -s "16" -d "Now allowing ejabberd to start up correctly..."

		/usr/sbin/ejabberdctl status
		echo

		dna-echo_operation -t

	else

		dna-echo -m "ejabberd not installed on node: | ${l-}${hostname}${n-} |."
		dna-echo -m "not going to start its service"

	fi

}

aenigma-stop_ejabberd() {

	############################################################################

	### Stop ejabberd if it's already installed and running

	############################################################################

	dna-get_hostname

	if dpkg -s ejabberd &> /dev/null
	then

		if systemctl is-active --quiet ejabberd
		then

			operation_message="stopping ejabberd on node: | ${l-}${hostname}${n-} |."
			dna-echo_operation -h

			service ejabberd stop &> /dev/null || true

			dna-wait -s "4" -d "Now allowing ejabberd to shut down correctly..."

			dna-echo_operation -t

		else

			dna-echo -s "ejabberd already stopped on node: | ${l-}${hostname}${n-} |."

			service ejabberd stop &> /dev/null || true

		fi

	else

		dna-echo -m "ejabberd not installed on node: | ${l-}${hostname}${n-} |."
		dna-echo -m "no need to stop its service"

	fi

}

aenigma-start_patroni() {

	############################################################################

	### Start patroni if it's already installed

	############################################################################

	dna-get_hostname

	if dpkg -s python-pip &> /dev/null && pip list 2> /dev/null | grep -q patroni && [ -f "/etc/systemd/system/patroni.service" ]
	then

		operation_message="starting patroni on node: | ${l-}${hostname}${n-} |."
		dna-echo_operation -h

		service patroni start

		dna-wait -s "16" -d "Now allowing patroni to start up correctly..."

		dna-echo_operation -t

	else

		dna-echo -m "patroni not installed on node: | ${l-}${hostname}${n-} |."
		dna-echo -m "not going to start its service"

	fi

}

aenigma-stop_patroni() {

	############################################################################

	### Stop patroni if it's already installed and running

	############################################################################

	dna-get_hostname

	if dpkg -s python-pip &> /dev/null && pip list 2> /dev/null | grep -q patroni && [ -f "/etc/systemd/system/patroni.service" ]
	then

		if systemctl is-active --quiet ejabberd
		then

			operation_message="stopping patroni on node: | ${l-}${hostname}${n-} |."
			dna-echo_operation -h

			service patroni stop &> /dev/null || true

			dna-wait -s "4" -d "Now allowing patroni to shut down correctly..."

			dna-echo_operation -t

		else

			dna-echo -s "patroni already stopped on node: | ${l-}${hostname}${n-} |."

			service patroni stop &> /dev/null || true

		fi

	else

		dna-echo -m "patroni not installed on node: | ${l-}${hostname}${n-} |."
		dna-echo -m "no need to stop its service"

	fi

}

aenigma-stop_ejabberd_patroni() {

	############################################################################
	############################################################################

	### Stop ejabberd and subsequently patroni on all nodes of the cluster
	### if they're already installed and running

	############################################################################
	############################################################################

	### ejabberd

	############################################################################

	### Stop ejabberd locally

	aenigma-stop_ejabberd

	############################################################################

	### Stop ejabberd on secondary nodes

	aenigma-get_nodes_online

	aenigma-exec() {

		### Define the commands that will be passed to the aenigma-exec script on the remote machine to be run, one per line between the quotes.

		bash openspace42/aenigma/tools/aenigma-exec -c "
aenigma-stop_ejabberd
"

	}

	############################################################################

	for online_node_ipv4 in $(cat < "${nodes_db_online_path}")
	do
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${online_node_ipv4}" = "${public_ipv4}" ]
		then
			### SSH into the secondary node, declare the aenigma-exec function, and run it inside of the subshell.
			ssh -tt -p42022 -o "BatchMode=yes" -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${online_node_ipv4}" "$(declare -f aenigma-exec); export -f aenigma-exec; exec bash -li" <<END
set -eu
. /root/openspace42/aenigma/functions
synthia-source_dna
synthia-define_vars
dna-read_conf_settings
aenigma-exec
exit
END
		fi
		echo
	done
	unset online_node_ipv4

	############################################################################
	############################################################################

	### patroni

	############################################################################

	### Stop ejabberd locally

	aenigma-stop_patroni

	############################################################################

	### Stop patroni on secondary nodes

	aenigma-get_nodes_online

	aenigma-exec() {

		### Define the commands that will be passed to the aenigma-exec script on the remote machine to be run, one per line between the quotes.

		bash openspace42/aenigma/tools/aenigma-exec -c "
aenigma-stop_patroni
"

	}

	############################################################################

	for online_node_ipv4 in $(cat < "${nodes_db_online_path}")
	do
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${online_node_ipv4}" = "${public_ipv4}" ]
		then
			### SSH into the secondary node, declare the aenigma-exec function, and run it inside of the subshell.
			ssh -tt -p42022 -o "BatchMode=yes" -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${online_node_ipv4}" "$(declare -f aenigma-exec); export -f aenigma-exec; exec bash -li" <<END
set -eu
. /root/openspace42/aenigma/functions
synthia-source_dna
synthia-define_vars
dna-read_conf_settings
aenigma-exec
exit
END
		fi
		echo
	done
	unset online_node_ipv4

	############################################################################
	############################################################################

}

aenigma-add_ejabberd_repo() {

	############################################################################

	### Install dependencies

	dna-install_wget

	############################################################################

	### Add repo

	dna-check_dpkg_availability
	dna-install_dependencies -p "apt-transport-https"

	### Add the apt.jabber.at repo

	dna-get_distro_codename

	echo "deb https://apt.jabber.at ${distro_codename} ejabberd" > "/etc/apt/sources.list.d/jabber.at.list"

	### Pin this repo at max priority in Debian in case testing/unstable repos are enabled

	dna-get_distro_name

	if [ "${distro_name}" = "debian" ]
	then
		touch "/etc/apt/preferences"
		if ! grep -q "apt.jabber.at" "/etc/apt/preferences"
		then
			cat <<EOF >> "/etc/apt/preferences"

Package: *
Pin: origin "apt.jabber.at"
Pin-Priority: 1000

EOF
		fi
	fi

	### Add key

	if ! apt-key list 2> /dev/null | grep "jabber.at" &> /dev/null
	then
		wget -qO- https://apt.jabber.at/gpg-key | apt-key add -
		apt-get update
	fi

	############################################################################

}

aenigma-get_ejabberd_installed_version() {

	if dpkg -s ejabberd &> /dev/null
	then
		ejabberd_installed_version="$(dpkg -s ejabberd | grep '^Version:' | sed "s|Version: ||" | cut -d ':' -f 2 | cut -f1 -d'-')"
	else
		ejabberd_installed_version=none
	fi

}

aenigma-get_ejabberd_candidate_version() {

	dna-apt_update

	ejabberd_candidate_version="$(apt-cache show ejabberd | grep Version | head -1 | sed "s|Version: ||" | cut -d ':' -f 2 | cut -f1 -d'-')"

}

aenigma-install_ejabberd_config() {

	############################################################################

	dna-echo -m "Now creating ejabberd directory and setting custom aenigma config..."

	aenigma-get_ejabberd_candidate_version

	ejabberd_candidate_config_version="$(echo ${ejabberd_candidate_version} | head -c 5)"

	source_ejab_conf_file="${source_dir}/conf/ejabberd/ejabberd-${ejabberd_candidate_config_version}.yml"

	if [ ! -f "${source_ejab_conf_file}" ]
	then

		### Fallback to ejabberd.yml for v18.12 in case the ejabberd candidate install version isn't among the ones we have config files for
		source_ejab_conf_file="${source_dir}/conf/ejabberd/ejabberd-18.12.yml"

	fi

	mkdir -p "/etc/ejabberd/"
	cp "${source_ejab_conf_file}" "/etc/ejabberd/ejabberd.yml"

	### Install captcha script

	dna-install_dependencies -p "imagemagick"

	if [ -f "/etc/ejabberd/captcha.sh" ]
	then
		rm "/etc/ejabberd/captcha.sh"
	fi

	curl "https://raw.githubusercontent.com/processone/ejabberd/master/tools/captcha.sh" > "/etc/ejabberd/captcha.sh"
	chmod +x "/etc/ejabberd/captcha.sh"
	echo

	############################################################################

	dna-echo -s "Finished creating ejabberd directory and setting custom aenigma config."

}

aenigma-set_permissions() {

	### Set permissions globally

	############################################################################

	dna-echo -m "Now setting permissions..."

	############################################################################

	### Create the aenigma group if it doesn't exist

	if ! grep -q "aenigma" "/etc/group"
	then
		addgroup aenigma
		echo
	fi

	############################################################################
	############################################################################

	### ~/.ssh/

	if [ -d "/root/.ssh/" ]
	then
		chmod 755 "/root/.ssh/"
	fi

	if [ -f "/root/.ssh/authorized_keys" ]
	then
		chown "root:root" "/root/.ssh/authorized_keys"
		chmod 600 "/root/.ssh/authorized_keys"
	fi

	############################################################################
	############################################################################

	### ejabberd

	############################################################################

	### /var/lib/ejabberd/

	if id "ejabberd" &> /dev/null
	then
		chown -R "ejabberd:ejabberd" "/var/lib/ejabberd/uploads/"
		chmod 2750 "/var/lib/ejabberd/uploads/"
		if [ -f "/var/lib/ejabberd/.erlang.cookie" ]
		then
			chown "ejabberd:ejabberd" "/var/lib/ejabberd/.erlang.cookie"
		fi
	fi

	### /var/www/ejabberd

	if id "ejabberd" &> /dev/null
	then
		usermod -aG aenigma ejabberd
		chown -R "ejabberd:ejabberd" "/var/www/ejabberd/"
		chmod -R 755 "/var/www/ejabberd/"
	fi

	### /var/log/ejabberd

	if id "ejabberd" &> /dev/null
	then
		chown -R "ejabberd:adm" "/var/log/ejabberd/"
		chmod -R 755 "/var/log/ejabberd/"
	fi

	############################################################################
	############################################################################

	### $tls_project_dir

	### Assign new permissions to tls_project_dir so that postgresql and etcd
	### too can read from it, if ejabberd doesn't exist yet at least set group.

	if id "ejabberd" >/dev/null 2>&1
	then
		chown -R "ejabberd:aenigma" "${tls_project_dir}"
	else
		chown -R "root:aenigma" "${tls_project_dir}"
	fi

	chmod -R 770 "${tls_project_dir}"

	############################################################################
	############################################################################

	### /data/

	mkdir -p "/data/"

	if id "postgres" &>/dev/null
	then
		chown -R postgres:postgres "/data/"
	fi

	chmod -R 700 "/data/"

	############################################################################
	############################################################################

	dna-echo -m "${g-}Finished setting permissions."

}

aenigma-create_ejabberd_locations() {

	### Create ejabberd uploads directory

	dna-echo -m "Now creating uploads directory..."
	mkdir -p "/var/lib/ejabberd/uploads/"
	dna-echo -m "${g-}Finished creating uploads directory."

	### Create HTTP uploads directory

	dna-echo -m "Now creating HTTP fileserver directory..."
	mkdir -p "/var/www/ejabberd/"
	dna-echo -m "${g-}Finished creating HTTP fileserver directory."

	### Create logfile

	dna-echo -m "Now creating logfile..."
	mkdir -p "/var/log/ejabberd/"
	touch "/var/log/ejabberd/www_access.log"
	dna-echo -m "${g-}Finished creating logfile."

	### Set permissions

	aenigma-set_permissions

}

aenigma-install_ejabberd() {

	### Ensure DPKG is available before proceeding.

	dna-check_dpkg_availability

	### Inhibit ejabberd from starting after install as permissions won't be already correct

	echo exit 101 > "/usr/sbin/policy-rc.d"
	chmod +x "/usr/sbin/policy-rc.d"

	### Proceed

	dna-echo -m "Now installing ejabberd..."

	export DEBIAN_FRONTEND=noninteractive ; apt-get install -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --force-yes ejabberd || true
	echo

	### Remove autostart inhibition

	rm "/usr/sbin/policy-rc.d"

	dna-echo -s "Finished installing ejabberd."
}

aenigma-localize_ejabberd_install() {

	############################################################################

	dna-get_hostname

	############################################################################

	### Stop ejabberd if it's already installed and running

	aenigma-stop_ejabberd

	### Set permissions now that user ejabberd exists while ejabberd has still not started yet

	aenigma-set_permissions

	### Perform customizations on the ejabberd config files.

	if [ ! "${additional_domains-}" = "none" ]
	then

		> "${tmp_project_dir}/additional_domains_ejabberd.txt"
		additional_domains_array=(${additional_domains})
		for additional_domain in "${additional_domains_array[@]}"
	    do
			echo "  - \"${additional_domain}\"" >> "${tmp_project_dir}/additional_domains_ejabberd.txt"
		done

		sed -i "/  - \"domain.xyz\"/ r ${tmp_project_dir}/additional_domains_ejabberd.txt" "/etc/ejabberd/ejabberd.yml"

	fi

	sed -i "s/domain.xyz/${domain}/g" "/etc/ejabberd/ejabberd.yml"
	sed -i "s/hostname.xyz/${hostname}/g" "/etc/ejabberd/ejabberd.yml"

	sed -i "s/public_ipv4-var/${public_ipv4}/g" "/etc/ejabberd/ejabberd.yml"

	sed -i "s/admin_mail/${admin_mail}/g" "/etc/ejabberd/ejabberd.yml"

	sed -i "s/xe.@/xe${node_number}.@/g" "/etc/ejabberd/ejabberd.yml"
	sed -i "s/xh.@/xh${node_number}.@/g" "/etc/ejabberd/ejabberd.yml"
	sed -i "s/xm.@/xm${node_number}.@/g" "/etc/ejabberd/ejabberd.yml"
	sed -i "s/xp.@/xp${node_number}.@/g" "/etc/ejabberd/ejabberd.yml"
	sed -i "s/xv.@/xv${node_number}.@/g" "/etc/ejabberd/ejabberd.yml"

	sed -i "s/ejabberd-psql-user-password-var/${patroni_ejabberd_password}/g" "/etc/ejabberd/ejabberd.yml"

	sed -i "/INET_DIST_INTERFACE=/c\INET_DIST_INTERFACE=${public_ipv4}" "/etc/default/ejabberd"

	if [ "${set_erlang_node_to_hostname-}" = "ok" ]
	then
		sed -i "/# ERLANG_NODE/d" /etc/default/ejabberd
		sed -i "/ERLANG_NODE=/c\ERLANG_NODE=ejabberd@${hostname}" /etc/default/ejabberd
	fi

	if [ "${wipe_var_lib_ejabberd-}" = "ok" ] && [ ! "${set_erlang_node_to_hostname-}" = "not_necessary" ]
	then

		dna-echo -e "Now wiping ejabberd to prepare for the new installation..."
		dna-echo -e "This is your final warning: if you're not absolutely sure your data is safe, abort the installation now!"

		dna-wait -s "11" -d "Counting down to full ejabberd wipe on this machine..."

		/usr/sbin/service ejabberd stop 2> /dev/null || true
		( cd /var/lib/ejabberd/ && find -maxdepth 1 ! -name .erlang.cookie ! -name uploads ! -name . -exec rm -rv {} \; ) > /dev/null

	fi

	dna-echo -m "Now finally starting up ejabberd..."

	aenigma-start_ejabberd

	############################################################################

}

aenigma-create_domains_db() {

	if [ -f "${domains_db_path}" ]
	then
		rm "${domains_db_path}"
		touch "${domains_db_path}"
	fi

	echo "${domain}" > "${domains_db_path}"

	if [ ! "${additional_domains-}" = "none" ]
	then

		additional_domains_array=(${additional_domains})
		for additional_domain in "${additional_domains_array[@]}"
	    do
			echo "${additional_domain}" >> "${domains_db_path}"
		done

	fi

}

aenigma-create_nodes_db_numbered() {

	### Create a node-numbered version of "nodes_db"

	if [ -f "${nodes_db_numbered_path}" ]
	then
		rm "${nodes_db_numbered_path}"
		touch "${nodes_db_numbered_path}"
	fi

	array_iter=1
	IFS=$'\n'
	set -f
	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
	do
		array_iter_padded="$(echo ${array_iter} | xargs printf %02d)"
		echo -e "${node_ipv4}\tae${array_iter_padded}.${domain}" >> "${nodes_db_numbered_path}"
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4
	IFS=$' \t\n'
	set +f

}

aenigma-create_nodes_db_initial() {

	cp "${nodes_db_numbered_path}" "${nodes_db_initial_path}"

}

aenigma-compare_nodes_db_initial() {

	if diff "${nodes_db_numbered_path}" "${nodes_db_initial_path}" > /dev/null
	then
	    export nodes_db_initial_diff="same"
	else
	    export nodes_db_initial_diff="diff"
	fi

}

aenigma-initialize_nodes_db_files() {

	mkdir -p "${conf_cluster_nodes_dir}"

	dna-get_public_ipv4 -s

	dna-check_ipv6_connectivity -s

	### IPv4

	touch "${nodes_db_ipv4_path}"

	if [ -s "${nodes_db_ipv4_path}" ]
	then
		### File is not empty, alter first line.
		sed -i "1s/.*/${public_ipv4}/" "${nodes_db_ipv4_path}"
	else
		### File is empty, write to it.
		echo "${public_ipv4}" > "${nodes_db_ipv4_path}"
	fi

	### IPv6

	touch "${nodes_db_ipv6_path}"

	if [ -s "${nodes_db_ipv6_path}" ]
	then

		### File is not empty, alter first line.

		if [ "${ipv6_available}" = "y" ]
		then
			sed -i "1s/.*/${this_ipv6}/" "${nodes_db_ipv6_path}"
		else
			sed -i "1s/.*/null/" "${nodes_db_ipv6_path}"
		fi

	else

		### File is empty, write to it.

		if [ "${ipv6_available}" = "y" ]
		then
			echo "${this_ipv6}" > "${nodes_db_ipv6_path}"
		else
			echo "null" > "${nodes_db_ipv6_path}"
		fi

	fi

	aenigma-create_nodes_db_numbered

}

aenigma-get_ejabberd_cluster_size() {

	ejabberd_cluster_size="$(wc -l < ${nodes_db_ipv4_path})"

}

aenigma-wipe_old_ufw_cluster_rules() {

	### Remove any and all UFW rules related to old cluster nodes

	############################################################################

	### Only do this check if ufw has actually been initialized

	if systemctl is-active --quiet ufw
	then

		### Get "ufw allow from x.x.x.x" rules previously set by us

		ufw show added | grep "ufw allow from" | grep -oE '((1?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9][0-9]?|2[0-4][0-9]|25[0-5])' > "${tmp_project_dir}/ufw_previous_cluster_rules" || true

		### Check every item from previous command output to see if those IPv4s
		### are still part of the cluster and if not remove those rules

		while read line
		do

			if [ ! "${line}" = "" ]
			then

				if ! grep -qr "${line}" "${conf_cluster_nodes_dir}"
				then

					ufw --force delete "$(ufw status | grep -E ' (ALLOW|LIMIT) ' | grep -n ${line} | cut -f1 -d":")"

				fi

			fi

		done < "${tmp_project_dir}/ufw_previous_cluster_rules"

		unset line

		rm "${tmp_project_dir}/ufw_previous_cluster_rules"

	fi

	############################################################################

}

aenigma-update_routing_info() {

	### Wipe any old cluster-related UFW rule

	aenigma-wipe_old_ufw_cluster_rules

	### Set UFW rules on this node according to the updated nodes_db

	array_iter=1
	IFS=$'\n'
	set -f
	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
	do
		/usr/sbin/ufw insert "${array_iter}" allow from "${node_ipv4}"
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4 array_iter
	IFS=$' \t\n'
	set +f
	echo

	### Import nodes_db to /etc/hosts to provide ejabberd with a locally resolved list of nodes to cluster with

	if ! grep -q "### aenigma nodes list start" /etc/hosts
	then
		echo >> /etc/hosts
		echo "### aenigma nodes list start" >> /etc/hosts
	fi

	if ! grep -Pzoq '### aenigma nodes list start(?:.*\n)*?\K### aenigma nodes list end' /etc/hosts
	then
		echo "### aenigma nodes list end" >> /etc/hosts
	fi

	sed -i '/### aenigma nodes list start/,/### aenigma nodes list end/{//!d}' /etc/hosts
	sed -i "/### aenigma nodes list start/ r ${nodes_db_numbered_path}" /etc/hosts

}

aenigma-refresh_nodes_db_online() {

	############################################################################

	### This function will always get invoked at the beginning push_routing_info() in the later event that an existing node cannot be reached at the time of running a new clusterization.
	### It will create a copy of nodes_db_ipv4 and nodes that appear to be offline will be removed from it, for use by subsequent functions, until the end of the clusterize script.

	############################################################################

	### Touch temp dir

	dna-touch_tmp_project_dir

	############################################################################

	if [ -f "${nodes_db_online_path}" ]
	then
		rm "${nodes_db_online_path}"
		touch "${nodes_db_online_path}"
	fi

	############################################################################

	cp "${nodes_db_ipv4_path}" "${nodes_db_online_path}"

	############################################################################

}

aenigma-get_nodes_online() {

	############################################################################

	### Generate a list of online nodes by opening SSH sessions to other nodes.
	### If any nodes are offline, remove them from nodes_db_online.

	aenigma-refresh_nodes_db_online

	array_iter=1
	IFS=$'\n'
	set -f

	touch "${tmp_dir}/online_test_token"

	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")							### Do NOT escape this variable
	do
		current_node_number="$(echo ${array_iter} | xargs printf %02d)"
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${node_ipv4}" = "${public_ipv4}" ]
		then
			if ! /usr/bin/scp -P42022 -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" -r "${tmp_dir}/online_test_token" "root@${node_ipv4}:${tmp_dir}/online_test_token"
			then
				echo
				dna-echo -e "Existing node number | ${n-}${current_node_number}${r-} | is not responding at IPv4 address | ${n-}${node_ipv4}${r-} |."
				dna-echo -m "It is NOT reccommended to continue the installation as the node in question will not be informed of the new node we're setting up right now."
				dna-echo -m "However, you can continue running the installation now and re-run the installation script at at a later time."
	            dna-ask_for_boolean -d "y" -q "Continue anyway?"
	            if [ "${boolean_output}" = "y" ]
	            then
					dna-echo -n -m "Ok, continuing..."
					### Remove node from nodes_db_online
					sed -i "/^${node_ipv4}$/d" "${nodes_db_online_path}"
				else
					dna-echo -m "Ok, aborting..."
					dna-exit
				fi
			fi
		fi
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4
	IFS=$' \t\n'
	set +f

}

aenigma-check_ip_info_current() {

	if [ ! -f "${nodes_db_ipv4_path}" ] || [ ! -f "${nodes_db_ipv6_path}" ]
    then
		dna-echo -m "Not all nodes_db files found or none at all. Skipping IP change checks."
        return 0
    fi

	### Fetch IP addresses for this machine

	dna-get_public_ipv4

	dna-check_ipv6_connectivity

	### Check to see if this machine's IPs have changed since last install / clusterization

	this_registered_ipv4="$(cat ${nodes_db_ipv4_path} | head -1 | xargs)"

	this_registered_ipv6="$(cat ${nodes_db_ipv6_path} | head -1 | xargs)"

	if [ ! "${public_ipv4}" = "${this_registered_ipv4}" ]
	then
		dna-echo -e "The public IPv4 address for this machine appears to have changed since the last install or the last run of the clusterize script."
		dna-echo -m "It now appears to be: | ${y-}${public_ipv4}${n-} |."
		dna-echo -m "This node, however, appears to be registered with the following: | ${y-}${this_registered_ipv4}${n-} |."
		dna-echo -m "Please re-run the installation to update the records for this machine on the nodes database."
		dna-exit
	fi

	if [ ! "${this_ipv6}" = "${this_registered_ipv6}" ]
	then
		dna-echo -e "The public IPv6 address for this machine appears to have changed since the last install or the last run of the clusterize script."
		dna-echo -m "It now appears to be: | ${y-}${this_ipv6}${n-} |."
		dna-echo -m "This node, however, appears to be registered with the following: | ${y-}${this_registered_ipv6}${n-} |."
		dna-echo -m "Please re-run the installation to update the records for this machine on the nodes database."
		dna-exit
	fi

}

aenigma-push_routing_info() {

	############################################################################

	### Push nodes_db files to all secondary nodes for /etc/hosts and ufw rules configuration.
	### At the same time, check to see if any existing secondary nodes are offline, and, if so, remove them from nodes_db_online.

	aenigma-refresh_nodes_db_online

	array_iter=1
	IFS=$'\n'
	set -f

	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")							### Do NOT escape this variable
	do
		current_node_number="$(echo ${array_iter} | xargs printf %02d)"
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${node_ipv4}" = "${public_ipv4}" ]
		then
			if ! /usr/bin/scp -P42022 -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i /root/.ssh/aenigma_cluster -r "${conf_cluster_nodes_dir}" "root@${node_ipv4}:${conf_cluster_dir}"
			then
				echo
				dna-echo -e "Existing node number | ${n-}${current_node_number}${r-} | is not responding at IPv4 address | ${n-}${node_ipv4}${r-} |."
				dna-echo -m "It is NOT reccommended to continue the installation as the node in question will not be informed of the new node we're setting up right now."
				dna-echo -m "However, you can continue running the installation now and run the | ${o-}push_routing_info${n-} | script at at a later time by executing:"
				dna-echo -m " | ${y-}bash ${tools_dir}/${proj_name}-push_routing_info${n-} | "
	            dna-ask_for_boolean -d "y" -q "Continue anyway?"
	            if [ "${boolean_output}" = "y" ]
	            then
					dna-echo -n -m "Ok, continuing..."
					### Remove node from nodes_db_online
					sed -i "/^${node_ipv4}$/d" "${nodes_db_online_path}"
				else
					dna-echo -m "Ok, aborting..."
					dna-exit
				fi
			fi
		fi
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4
	IFS=$' \t\n'
	set +f

	############################################################################

	aenigma-exec() {

		### Define the commands that will be passed to the aenigma-exec script on the remote machine to be run, one per line between the quotes.

        bash openspace42/aenigma/tools/aenigma-exec -c "
aenigma-update_routing_info
"

	}

	############################################################################

	for online_node_ipv4 in $(cat < "${nodes_db_online_path}")
	do
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${online_node_ipv4}" = "${public_ipv4}" ]
		then
			### SSH into the secondary node, declare the aenigma-exec function, and run it inside of the subshell.
	        ssh -tt -p42022 -o "BatchMode=yes" -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${online_node_ipv4}" "$(declare -f aenigma-exec); export -f aenigma-exec; exec bash -li" <<END
set -eu
. /root/openspace42/aenigma/functions
synthia-source_dna
synthia-define_vars
dna-read_conf_settings
aenigma-exec
exit
END
		fi
		echo
	done
	unset online_node_ipv4

	############################################################################

}

aenigma-push_certs() {

	############################################################################

	### Push LetsEncrypt TLS certificate files to all secondary nodes.
	### At the same time, check to see if any existing secondary nodes are offline, and, if so, remove them from nodes_db_online.

	aenigma-refresh_nodes_db_online

	array_iter=1
	IFS=$'\n'
	set -f

	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")							### Do NOT escape this variable
	do
		current_node_number="$(echo ${array_iter} | xargs printf %02d)"
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${node_ipv4}" = "${public_ipv4}" ]
		then
			if ! /usr/bin/scp -P42022 -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i /root/.ssh/aenigma_cluster -r "${tls_project_dir}" "root@${node_ipv4}:${tls_dir}"
			then
				echo
				dna-echo -e "Node number | ${n-}${current_node_number}${r-} | is not responding at IPv4 address | ${n-}${node_ipv4}${r-} |."
				dna-echo -m "Ensure such node is actually online and when it is execute this script again by running:"
				dna-echo -m " | ${y-}${tools_dir}/${proj_name}-create-push-certs${n-} | "
				if [ "${interactive}" = "y" ]
				then
		            dna-ask_for_boolean -d "y" -q "Continue anyway with all other nodes now?"
		            if [ "${boolean_output}" = "y" ]
		            then
						dna-echo -n -m "Ok, continuing..."
						### Remove node from nodes_db_online
						sed -i "/^${node_ipv4}$/d" "${nodes_db_online_path}"
					else
						dna-echo -m "Ok, aborting..."
						dna-exit
					fi
				else
					dna-echo -e "Skipping node | ${n-}${current_node_number}${r-} | and continuing with all others now."
					### Send an alert email.
			        dna-send_mail -s "aenigma: node: | ${current_node_number} | offline" \
			        -b "Automated post-renewal LetsEncrypt TLS certificate files push to node: | ${current_node_number} | has failed, as it appears to be offline. Look into the situation and when the node is back online simply log into your primary node [the machine sending this very notification] and execute: | ${tools_dir}/${proj_name}-create-push-certs |." \
			        -r "${admin_mail}"
				fi
			fi
		fi
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4
	IFS=$' \t\n'
	set +f

	############################################################################

	aenigma-exec() {

		### Define the commands that will be passed to the aenigma-exec script on the remote machine to be run, one per line between the quotes.

        bash openspace42/aenigma/tools/aenigma-exec -c "
set +e
chown -R "ejabberd:ejabberd" "${tls_project_dir}"
set -e
chmod -R 700 "${tls_project_dir}"
/usr/sbin/service ejabberd restart
"

	}

	############################################################################

	for online_node_ipv4 in $(cat < "${nodes_db_online_path}")
	do
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${online_node_ipv4}" = "${public_ipv4}" ]
		then
			### SSH into the secondary node, declare the aenigma-exec function, and run it inside of the subshell.
	        ssh -tt -p42022 -o "BatchMode=yes" -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${online_node_ipv4}" "$(declare -f aenigma-exec); export -f aenigma-exec; exec bash -li" <<END
set -eu
. /root/openspace42/aenigma/functions
synthia-source_dna
synthia-define_vars
dna-read_conf_settings
aenigma-exec
exit
END
		fi
		echo
	done
	unset online_node_ipv4

	############################################################################

}

aenigma-test_online_nodes() {

	############################################################################

	dna-echo -m "This function attempts to connect to every node in your cluster, and checks for consistency across all nodes' ejabberd's cluster synchronization state."
	dna-echo -m "If a node is found to be offline, you will have the choice to remove it from your primary node [this machine]'s database of nodes."
	dna-press_to_continue

	############################################################################

	### Check to see if any existing secondary nodes are offline, and, if so, remove them from nodes_db_online

	aenigma-refresh_nodes_db_online

	array_iter=1
	IFS=$'\n'
	set -f

	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")							### Do NOT escape this variable
	do
		current_node_number="$(echo ${array_iter} | xargs printf %02d)"
		### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${node_ipv4}" = "${public_ipv4}" ]
		then
			if /usr/bin/ssh -p42022 -o "BatchMode=yes" -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${node_ipv4}" exit
			then
				dna-echo -s "Node number: | ${n-}${current_node_number}${g-} | is responding at IPv4 address: | ${n-}${node_ipv4}${g-} |."
			else
				echo
				dna-echo -e "Node number: | ${n-}${current_node_number}${r-} | is NOT responding at IPv4 address | ${n-}${node_ipv4}${r-} |."
				dna-echo -m "If you have decommissioned this server or intend to do so, you can remove this node from this primary node's configuration about the cluster."
				dna-echo -m "Data on such secondary node will not be affected in any way, but this primary node won't consider it part of the cluster during future operations."
				dna-echo -m "If somehow such secondary node is still running, even though we cannot reach it right now, it will still actually take part in the ejabberd cluster."
	            dna-ask_for_boolean -d "n" -q "Would you like to remove this node from the cluster database now?"
	            if [ "${boolean_output}" = "y" ]
	            then
					dna-echo -m "Ok, removing node now..."
					/usr/sbin/ejabberdctl --no-timeout leave_cluster "ejabberd@ae${current_node_number}.${domain}" || true
					dna-echo -m "Now restarting ejabberd..."
					/usr/sbin/service ejabberd restart
					initial_last_node_number=$(wc -l < "${nodes_db_ipv4_path}" | xargs printf %02d)
					if [ "${current_node_number}" = "${initial_last_node_number}" ]
					then
						### Remove node from nodes_db files
						sed -i "${current_node_number}d" "${nodes_db_ipv4_path}"
						sed -i "${current_node_number}d" "${nodes_db_ipv6_path}"
						aenigma-create_nodes_db_numbered
						aenigma-push_routing_info
						dna-echo -s "Node deleted successfully."
						node_removed="y"
					else
						dna-echo -m "Performing this removal would leave an empty space for node number | ${o-}${current_node_number}${n-} |."
						dna-echo -m "To remove it from our cluster configuration it is required to reconfigure the last numbered node: [number | ${o-}${initial_last_node_number}${n-} |] to take the place of the newly removed node."
						dna-echo -m "If you do not want to proceed with this operation, the removal will be aborted."
						dna-ask_for_boolean -d "y" -q "Would you like to reconfigure node number | ${o-}${initial_last_node_number}${n-} | now?"
						if [ "${boolean_output}" = "y" ]
						then
							dna-echo -m "Ok, reconfiguring node now..."
							/usr/sbin/ejabberdctl --no-timeout leave_cluster "ejabberd@ae${initial_last_node_number}.${domain}" || true
							dna-echo -m "Now restarting ejabberd..."
							/usr/sbin/service ejabberd restart
							### Get the last node in nodes_db_ipv4
							target_node_ipv4=$(cat ${nodes_db_ipv4_path} | sed -n "${initial_last_node_number}"p)
							### Copy its IPv4 to the line of the node to be removed
							sed -i "${current_node_number}s/.*/${target_node_ipv4}/" "${nodes_db_ipv4_path}"
							### Delete the reconfigured node's initial line
							sed -i "${initial_last_node_number}d" "${nodes_db_ipv4_path}"
							### Get the last node in nodes_db_ipv6
							target_node_ipv6=$(cat ${nodes_db_ipv6_path} | sed -n "${initial_last_node_number}"p)
							### Copy its IPv6 to the line of the node to be removed
							sed -i "${current_node_number}s/.*/${target_node_ipv6}/" "${nodes_db_ipv6_path}"
							### Delete the reconfigured node's initial line
							sed -i "${initial_last_node_number}d" "${nodes_db_ipv6_path}"
							aenigma-create_nodes_db_numbered
							dna-echo -s "Node number: | ${n-}${initial_last_node_number}${g-} | successfully changed to number: | ${n-}${current_node_number}${g-} |."
							node_removed="y"
							launch_node_reinstallation="y"
						else
							dna-echo -m "Ok, aborting node removal."
						fi
					fi
					if [ "${launch_node_reinstallation-}" = "y" ]
					then
						dna-echo -m "Having re-ordered what is now node number | ${o-}${current_node_number}${n-} | it's time to re-configure it and notify it of the change."
						dna-echo -m "Open a new shell to it [located at IP: | ${y-}${target_node_ipv4}${n-} |] and run the installer from there now. Then come back here."
						dna-press_to_continue
						dna-echo -n -m "Ok, now launching | ${c-}${proj_name}-clusterize${n-} | script..."
						bash "${tools_dir}/${proj_name}-clusterize"
					fi
				else
					dna-echo -m "Ok, skipping node removal."
					dna-exit
				fi
			fi
		fi
		array_iter=$((array_iter + 1))
		if [ "${node_removed}" = "y" ]
		then
			dna-echo -e "Interrupting | ${n-}test_online_nodes${r-} | function execution."
			dna-echo -m "Having removed a node, if you want to keep testing online nodes, given the new node arrangement, simply re-run the script."
			dna-press_to_continue
			break
		fi
	done
	unset node_ipv4
	IFS=$' \t\n'
	set +f

	############################################################################

	dna-echo -m "Now pushing routing info..."

	aenigma-push_routing_info

	############################################################################

}

aenigma-perform_dns_checks() {

	### Perform DNS checks. They must only be run by the primary node.

	############################################################################

	dna-echo -m "Performing DNS checks for the following domains:"
	dna-echo -m "${y-}$(cat ${domains_db_path})"

	if [ "${cluster_enabled}" = "cluster" ]
	then

		dna-echo -m "Performing DNS checks for the following nodes:"
		dna-echo -m "${y-}$(cat ${nodes_db_numbered_path})"

	fi

	############################################################################

	for this_domain in $(cat < "${domains_db_path}")
	do

		### Perform checks in both IPv4 and IPv6. If this node [or a node in case of a cluster] doesn't have IPv6 connectivity its IPv6 check will be ignored locally.

		declare -a ip_version_array=(
			"4"
			"6"
		)

		aenigma-calculate_ip_version_vars() {

			if [ "${ip_version}" = "4" ]
			then
				nodes_db_path="${nodes_db_ipv4_path}"
				address_type="a"
			elif [ "${ip_version}" = "6" ]
			then
				nodes_db_path="${nodes_db_ipv6_path}"
				address_type="aaaa"
			fi

		}

		########################################################################

		### Check hostnames.

		for ip_version in "${ip_version_array[@]}"
		do

			aenigma-calculate_ip_version_vars

			array_iter=1
			IFS=$'\n'
			set -f

			for node_ip in $(cat < "${nodes_db_path}")
			do

				current_node_number="$(echo ${array_iter} | xargs printf %02d)"
				dna-check_dns_record -n "ae${current_node_number}.${this_domain}" -t "${address_type}" -r "${node_ip}"
				array_iter=$((array_iter + 1))

			done

			unset array_iter
			IFS=$' \t\n'
			set +f

		done

		########################################################################

		### Now check that "ae.$this_domain" points to all nodes in a round-robin fashion.

		for ip_version in "${ip_version_array[@]}"
		do

			aenigma-calculate_ip_version_vars

			dna-check_dns_record -n "ae.${this_domain}" -t "${address_type}" -r "${nodes_db_path}"

		done

		########################################################################

		### Check XMPP services records

		### First check services that need to point to each node respectively

		for ip_version in "${ip_version_array[@]}"
		do

			aenigma-calculate_ip_version_vars

			array_iter=1
			IFS=$'\n'
			set -f

			for node_ip in $(cat < "${nodes_db_path}")
			do

				current_node_number="$(echo ${array_iter} | xargs printf %02d)"

				declare -a xmpp_service_array=(
					"xe"
					"xh"
					"xm"
					"xp"
					"xv"
				)

				for xmpp_service in "${xmpp_service_array[@]}"
				do

					dna-check_dns_record -n "${xmpp_service}${current_node_number}.${this_domain}" -t "${address_type}" -r "${node_ip}"

				done

				array_iter=$((array_iter + 1))

			done

			unset array_iter
			IFS=$' \t\n'
			set +f

		done

		### Then check "xc.$this_domain" as it should not be a set of numbered records [xc01, xc02...] but instead be only one record pointing to all nodes in a round-robin fashion

		for ip_version in "${ip_version_array[@]}"
		do

			aenigma-calculate_ip_version_vars

			dna-check_dns_record -n "xc.${this_domain}" -t "${address_type}" -r "${nodes_db_path}"

		done

		########################################################################

		### Check SRV records

		#### SRV client records

		dna-check_dns_record -n "_xmpps-client._tcp.${this_domain}" -t "srv" -r "5 1 5223 ae.${this_domain}.,15 1 443 ae.${this_domain}."
		dna-check_dns_record -n "_xmpp-client._tcp.${this_domain}" -t "srv" -r "10 1 5222 ae.${this_domain}.,20 1 443 ae.${this_domain}."

		#### SRV server records

		declare -a srv_record_array=(
			"_jabber._tcp"
			"_xmpp-server._tcp"
		)

		for srv_record in "${srv_record_array[@]}"
		do

			dna-check_dns_record -n "${srv_record}.${this_domain}" -t "srv" -r "0 0 5269 ae.${this_domain}."

		done

		########################################################################

		unset dns_checks_outcome

		########################################################################

	done

}

################################################################################
################################################################################

### Postgresql

aenigma-install_postgresql_dependencies() {

	dna-install_dependencies -p "python python-pip python-psycopg2 libpq-dev"
	pip install --upgrade setuptools
	pip install python-etcd
	pip uninstall --yes requests || true
	pip install requests
	pip install docopt
	echo

}

aenigma-wipe_etcd() {

	### Stop etcd if it's already installed

	if dpkg -s etcd &> /dev/null
	then
		service etcd stop || true
	fi

	### Purge etcd

	apt-get -y purge etcd

	### Delete any previous etcd data in case it gets left over by apt

	if [ -d "/var/lib/etcd/default/" ]
	then
		rm -r "/var/lib/etcd/default/"
	fi

}

aenigma-install_etcd() {

	############################################################################

	### Install etcd

	### !!! This function is only intended to be ran by the primary node !!! ###

	############################################################################
	############################################################################

	### Install dependencies required for postgresql cluster

	aenigma-install_postgresql_dependencies

	### Apply permissions

	aenigma-set_permissions

	############################################################################
	############################################################################

	### Delete all etcd data to start fresh

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		########################################################################

		### This only applies to primary nodes, so that an initial wipe will
		### occur only once at the same time during primary node installation.
		### Secondary nodes will skip this when running on their own as the
		### primary node will already have remotely performed this onto them as
		### well.

		aenigma-wipe_etcd

		### Delete any previous etcd data on secondary nodes

		########################################################################

		aenigma-exec() {

			### Define the commands that will be passed to the aenigma-exec script on the remote machine to be run, one per line between the quotes.

	        bash openspace42/aenigma/tools/aenigma-exec -c "
aenigma-wipe_etcd
"

		}

		########################################################################

		for online_node_ipv4 in $(cat < "${nodes_db_online_path}")
		do
			### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
			if [ ! "${online_node_ipv4}" = "${public_ipv4}" ]
			then
				### SSH into the secondary node, declare the aenigma-exec function, and run it inside of the subshell.
		        ssh -tt -p42022 -o "BatchMode=yes" -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${online_node_ipv4}" "$(declare -f aenigma-exec); export -f aenigma-exec; exec bash -li" <<END
set -eu
. /root/openspace42/aenigma/functions
synthia-source_dna
synthia-define_vars
dna-read_conf_settings
aenigma-exec
exit
END
			fi
			echo
		done
		unset online_node_ipv4

		########################################################################

	else

		### This is a secondary node, wipe etcd locally before localizing it
		### and starting it back up.

		aenigma-wipe_etcd

	fi

	############################################################################
	############################################################################

	### Perform the installation

	############################################################################

	### Inhibit etcd from starting after install

	echo exit 101 > "/usr/sbin/policy-rc.d"
	chmod +x "/usr/sbin/policy-rc.d"

	### Proceed

	dna-install_etcd

	### Remove autostart inhibition

	rm "/usr/sbin/policy-rc.d"

	### Add etcd user to aenigma group for correct tls_project_dir permissions

	usermod -aG aenigma etcd

	############################################################################
	############################################################################

	### Set config file

	cat <<EOF > "/etc/default/etcd"
ETCD_HEARTBEAT_INTERVAL="100"
ETCD_ELECTION_TIMEOUT="1000"
ETCD_LISTEN_PEER_URLS="https://public_ipv4-var:2380"
ETCD_LISTEN_CLIENT_URLS="http://localhost:2379,http://public_ipv4-var:2379"
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://public_ipv4-var:2380"
ETCD_INITIAL_CLUSTER="hostname-var=https://hostname-var:2380,"
ETCD_INITIAL_CLUSTER_STATE="new"
ETCD_INITIAL_CLUSTER_TOKEN="aenigma"
ETCD_ADVERTISE_CLIENT_URLS="http://public_ipv4-var:2379"
ETCD_PEER_CERT_FILE="/etc/ssl/aenigma/domain-var.d/fullchain.pem"
ETCD_PEER_KEY_FILE="/etc/ssl/aenigma/domain-var.d/privkey.pem"
#ETCD_CERT_FILE="/etc/ssl/aenigma/domain-var.d/fullchain.pem"
#ETCD_KEY_FILE="/etc/ssl/aenigma/domain-var.d/privkey.pem"
EOF

	### Add cluster nodes to config file

	aenigma-get_ejabberd_cluster_size

	if [ ! "${ejabberd_cluster_size}" = "1" ]
	then

		for node in $(seq 1 $ejabberd_cluster_size)
		do

			node_number_padded="$(echo ${node} | xargs printf %02d)"

			if [ ! "${node_number_padded}" = "${node_number}" ]
			then

				sed -i "6s/.$/ae${node_number_padded}.${domain}=https:\/\/ae${node_number_padded}.${domain}:2380,&/" "/etc/default/etcd"

			fi

		done

	fi

	### Replace vars in config file

	dna-get_hostname

	sed -i "s|hostname-var|${hostname}|g" "/etc/default/etcd"
	sed -i "s|domain-var|${domain}|g" "/etc/default/etcd"
	sed -i "s|public_ipv4-var|${public_ipv4}|g" "/etc/default/etcd"

	operation_message="starting etcd on node: | ${l-}${hostname}${n-} |."
	dna-echo_operation -h

	update-rc.d etcd enable

	systemctl restart etcd &

	sleep 3

	dna-wait -s "8" -d "Now allowing etcd to start up correctly..."

	dna-echo_operation -t

	############################################################################
	############################################################################

}

aenigma-install_etcd_cluster() {

	############################################################################

	### Install etcd all at once on all nodes

	############################################################################

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		########################################################################

		### Ensure routing info is up-to-date on all nodes or else etcd will
		### fail.

		aenigma-push_routing_info

		### Ensure no old nodes can connect to any current nodes or else their
		### etcd might connect to the latter and make etcd fail

		aenigma-wipe_old_ufw_cluster_rules

		########################################################################

		### Stop ejabberd and patroni cluster-wide

		aenigma-stop_ejabberd_patroni

		########################################################################

		### Install etcd locally while performing a cluster-wide etcd wipe

		aenigma-install_etcd

		########################################################################

		### At this point etcd will be installed locally on this primary node
		### and we can proceed to install it on any secondary nodes.

		########################################################################

		aenigma-get_nodes_online

		aenigma-exec() {

			### Define the commands that will be passed to the aenigma-exec script on the remote machine to be run, one per line between the quotes.

			bash openspace42/aenigma/tools/aenigma-exec -c "
aenigma-install_etcd
"

		}

		########################################################################

		for online_node_ipv4 in $(cat < "${nodes_db_online_path}")
		do
			### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
			if [ ! "${online_node_ipv4}" = "${public_ipv4}" ]
			then
				### SSH into the secondary node, declare the aenigma-exec function, and run it inside of the subshell.
				ssh -tt -p42022 -o "BatchMode=yes" -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${online_node_ipv4}" "$(declare -f aenigma-exec); export -f aenigma-exec; exec bash -li" <<END
set -eu
. /root/openspace42/aenigma/functions
synthia-source_dna
synthia-define_vars
dna-read_conf_settings
aenigma-exec
exit
END
			fi
			echo
		done
		unset online_node_ipv4

		########################################################################

	fi

}

aenigma-apply_and_restart_patroni_haproxy_ejabberd() {

	############################################################################

	### Run this function after re-installing or clusterizing
	### to apply new configs updated with new nodes to patroni and haproxy
	### and restart these two services plus ejabberd

	############################################################################

	while getopts ":e:r" arguments
	do
        case $arguments in
            e)	excluded_node="${OPTARG}"
	            ;;
			r)	remote_only="yes"
	            ;;
            \?)	dna-echo -e "Invalid option | ${n-}-${OPTARG}${r-} | for function | ${n-}${FUNCNAME[0]}${r-} |."
	            dna-exit
	            ;;
        esac
    done
    OPTIND=1

	############################################################################
	############################################################################

	### Localhost

	############################################################################

	if [ ! "${remote_only-}" = "yes" ]
	then

		### Update patroni config now that we have a new node

		aenigma-apply_patroni_config

		aenigma-start_patroni

		### Update haproxy config now that we have a new node

		aenigma-apply_haproxy_config

		### Restart ejabberd

		aenigma-start_ejabberd

	fi

	############################################################################
	############################################################################

	### Secondary nodes

	############################################################################

	aenigma-get_nodes_online

	aenigma-exec() {

		### Define the commands that will be passed to the aenigma-exec script on the remote machine to be run, one per line between the quotes.

		bash openspace42/aenigma/tools/aenigma-exec -c "
aenigma-apply_patroni_config
aenigma-start_patroni
aenigma-apply_haproxy_config
aenigma-start_ejabberd
"

	}

	############################################################################

	for online_node_ipv4 in $(cat < "${nodes_db_online_path}")
	do

		### Ensure we don't try connecting to ourselves [therefore ignore
		### the first line of nodes_db_ipv4] or to the excluded node.

		if [ ! "${online_node_ipv4}" = "${public_ipv4}" ] && [ ! "${online_node_ipv4}" = "${excluded_node-}" ]
		then

			### SSH into the secondary node, declare the aenigma-exec function,
			### and run it inside of the subshell.

			ssh -tt -p42022 -o "BatchMode=yes" -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${online_node_ipv4}" "$(declare -f aenigma-exec); export -f aenigma-exec; exec bash -li" <<END
set -eu
. /root/openspace42/aenigma/functions
synthia-source_dna
synthia-define_vars
dna-read_conf_settings
aenigma-exec
exit
END

		fi

		echo

	done

	unset online_node_ipv4

	############################################################################
	############################################################################

	unset exclude_node remote_only

	############################################################################
	############################################################################

}

aenigma-migrate-mnesia-postgresql() {

	### !!! Only run this after install_patroni_postgresql and on the primary node !!! ####

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		### Insert the new_sql_schema directive in a random point of the config without enabling SQL yet

		operation_message="applying new_sql_schema directive"
		dna-echo_operation -h

		sed -i "s|## fqdn: \"server3.example.com\"|new_sql_schema: true|g" "/etc/ejabberd/ejabberd.yml"

		service ejabberd restart

		dna-echo_operation -t

		### Alert about migration

		dna-echo -m "We're now migrating this ejabberd instance from using the mnesia DB to PostgreSQL."
		dna-echo -m "We will now proceed with exporting and re-importing all ejabberd data on this instance."

		### Close firewall ports to effectively terminate the service for users and avoid collecting data that would not be migrated if generated after the export

		ufw delete allow 5222
		ufw delete allow 5223
		ufw delete allow 5444
		echo

		### Export data for every ejabberd domain

		operation_message="exporting data from the ejabberd mnesia database"
		dna-echo_operation -h

		ejabberdctl export2sql "${domain}" "aenigma-ejabberd-export-${domain}.sql"
		mv "/var/lib/ejabberd/aenigma-ejabberd-export-${domain}.sql" "${tmp_dir}/aenigma-ejabberd-export-${domain}.sql"
		chmod 777 "${tmp_dir}/aenigma-ejabberd-export-${domain}.sql"

		additional_domains_array=(${additional_domains})
		for additional_domain in "${additional_domains_array[@]}"
		do
			ejabberdctl export2sql "${additional_domain}" "aenigma-ejabberd-export-${additional_domain}.sql"
			mv "/var/lib/ejabberd/aenigma-ejabberd-export-${additional_domain}.sql" "${tmp_dir}/aenigma-ejabberd-export-${additional_domain}.sql"
			chmod 777 "${tmp_dir}/aenigma-ejabberd-export-${additional_domain}.sql"
		done

		dna-echo_operation -t

		### Import to psql

		operation_message="importing data into PSQL"
		dna-echo_operation -h

		for export in ${tmp_dir}/aenigma-ejabberd-export*.sql
		do
			PGPASSWORD="${patroni_ejabberd_password}" psql -h "${hostname}" -p "5432" -U ejabberd ejabberd < "${export}"
			echo
		done

		dna-echo_operation -t

		psql_migration_status="complete"

	fi

}

aenigma-get_postgresql_bin_dir_path() {

	postgresql_bin_dir_path="$(find /usr/lib/postgresql/ -name bin)"

}

aenigma-apply_patroni_config() {

	############################################################################

	### Install and localize patroni config

	############################################################################

	### Install patroni config

	cat <<EOF > "/etc/patroni.yml"
scope: aenigma
name: postgresql-node_number-var

restapi:
  listen: public_ipv4-var:8008
  connect_address: public_ipv4-var:8008
  certfile: /etc/ssl/aenigma/domain-var.d/fullchain.pem
  keyfile: /etc/ssl/aenigma/domain-var.d/privkey.pem
#  authentication:
#    username: username
#    password: password

ctl:
  insecure: false # Allow connections to SSL sites without certs
  certfile: /etc/ssl/aenigma/domain-var.d/fullchain.pem
  keyfile: /etc/ssl/aenigma/domain-var.d/privkey.pem

etcd:
  host: public_ipv4-var:2379

bootstrap:
  dcs:
    ttl: 30
    loop_wait: 10
    retry_timeout: 10
    maximum_lag_on_failover: 1048576
    postgresql:
      use_pg_rewind: true
      use_slots: true
      parameters:
        wal_level: replica
        hot_standby: "on"
        wal_keep_segments: 8
        max_wal_senders: 5
        max_replication_slots: 5
        checkpoint_timeout: 30

  initdb:
  - encoding: UTF8
#  - data-checksums

  pg_hba:
  - host all postgres all md5
  - host replication repl all md5
  - host replication replicator public_ipv4-var/32 md5
  - host all all 0.0.0.0/0 md5

  users:
    postgres:
      password: patroni_postgres_password-var
      options:
        - createrole
        - createdb
    repl:
      password: patroni_repl_password-var
      options:
        - replication

postgresql:
  listen: public_ipv4-var:5432
  connect_address: public_ipv4-var:5432
  data_dir: /data/postgresql
  config_dir: /data/postgresql
  bin_dir: postgresql_bin_dir_path-var
  authentication:
    replication:
      username: repl
      password: patroni_repl_password-var
    superuser:
      username: postgres
      password: patroni_postgres_password-var
  parameters:
    unix_socket_directories: '/tmp'
EOF

	############################################################################

	### Add other cluster nodes to the patroni config

	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
	do
		### Ensure we don't add ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${node_ipv4}" = "${public_ipv4}" ]
		then
			sed -i "/replicator public_ipv4-var/a \  - host replication replicator ${node_ipv4}\/0 md5" "/etc/patroni.yml"
		fi
	done
	unset node_ipv4

	############################################################################

	### Localize vars in patroni config

	sed -i "s|public_ipv4-var|${public_ipv4}|g" "/etc/patroni.yml"
	sed -i "s|node_number-var|${node_number}|g" "/etc/patroni.yml"
	sed -i "s|domain-var|${domain}|g" "/etc/patroni.yml"

	aenigma-get_postgresql_bin_dir_path

	sed -i "s|postgresql_bin_dir_path-var|${postgresql_bin_dir_path}|g" "/etc/patroni.yml"

	############################################################################

	### Apply passwords to the postgresql/patroni config

	sed -i "s|patroni_postgres_password-var|${patroni_postgres_password}|g" "/etc/patroni.yml"
	sed -i "s|patroni_repl_password-var|${patroni_repl_password}|g" "/etc/patroni.yml"

	############################################################################

}

aenigma-install_postgresql_patroni() {

	############################################################################

	### Install postgresql and patroni

	############################################################################

	### Install dependencies required for postgresql cluster

	aenigma-install_postgresql_dependencies

	### Apply permissions

	aenigma-set_permissions

	############################################################################

	### Get hostname

	dna-get_hostname

	### Get public IPv4

	dna-get_public_ipv4

	############################################################################

	### Install postgresql

	operation_message="installing PostgreSQL"
	dna-echo_operation -h

	dna-install_postgresql

	### Install erlang-p1-pgsql

	dna-get_distro_name

	if [ "${distro_name}" = "debian" ]
	then
		dna-enable_debian_testing_repo
	fi

	dna-install_dependencies -p "erlang-p1-pgsql"

	### Link psql bins

	if [ -d "/usr/lib/postgresql/" ]
	then

		aenigma-get_postgresql_bin_dir_path

		ln -s ${postgresql_bin_dir_path}/* "/usr/sbin/" || true
		echo

	fi

	### Add postgres user to aenigma group for correct tls_project_dir permissions

	usermod -aG aenigma postgres

	### Finish

	dna-echo_operation -t

	############################################################################

	### Stop and disable psql as patroni will now be managing DBs

	if systemctl is-active --quiet postgresql
	then
		service postgresql stop
	fi

	if [ -f "/etc/init.d/postgresql" ]
	then
		systemctl disable postgresql
	fi

	############################################################################

	### Install patroni

	pip install patroni
	echo

	############################################################################

	### Generate random passwords for the postgresql/patroni config if this is a primary node

	############################################################################

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		### Generate a random password for the postgres psql user

		if [ -z "${patroni_postgres_password-}" ]
		then
			dna-echo -m "Generating password for the postgresql/patroni postgres user"
			patroni_postgres_password="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)"
			dna-set_option -o "patroni_postgres_password" -p "postgresql" -s "${patroni_postgres_password}"
		fi

		### Generate a random password for the repl psql user

		if [ -z "${patroni_repl_password-}" ]
		then
			dna-echo -m "Generating password for the postgresql/patroni repl user"
			patroni_repl_password="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)"
			dna-set_option -o "patroni_repl_password" -p "postgresql" -s "${patroni_repl_password}"
		fi

	fi

	############################################################################

	### Apply patroni config

	aenigma-apply_patroni_config

	############################################################################

	aenigma-set_permissions

	############################################################################

	### Create patroni systemd service

	cat <<EOF > "/etc/systemd/system/patroni.service"
[Unit]
Description=Runners to orchestrate a high-availability PostgreSQL
After=syslog.target network.target

[Service]
Type=simple

User=postgres
Group=postgres

ExecStart=/usr/local/bin/patroni /etc/patroni.yml

KillMode=process

TimeoutSec=30

Restart=no

[Install]
WantedBy=multi-user.target
EOF

	systemctl daemon-reload

	systemctl enable patroni

	systemctl start patroni

	############################################################################

	operation_message="starting patroni on node: | ${l-}${hostname}${n-} |."
	dna-echo_operation -h

	dna-wait -s "11" -d "Now allowing patroni to start up correctly..."

	dna-echo_operation -t

	############################################################################

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		########################################################################

		### Create the ejabberd role and database in postgresql/patroni

		########################################################################

		### Generate a random password for the ejabberd psql user

		if [ -z "${patroni_ejabberd_password-}" ]
		then
			dna-echo -m "Generating password for the ejabberd postgresql/patroni user"
			patroni_ejabberd_password="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)"
			dna-set_option -o "patroni_ejabberd_password" -p "postgresql" -s "${patroni_ejabberd_password}"
		fi

		### Create ejabberd postgresql/patroni user

		if ! PGPASSWORD="${patroni_postgres_password}" psql -h "${hostname}" -p "5432" -U "postgres" -c "\du" 2> /dev/null | grep -q ejabberd
		then
			dna-echo -m "Creating the ejabberd postgresql/patroni user"
			PGPASSWORD="${patroni_postgres_password}" psql -h "${hostname}" -p "5432" -U "postgres" -c "create role ejabberd"
			echo
			patroni_ejabberd_role_previous_state="nx"
		fi

		### Assign the generated password to the user if we've just created it

		if [ "${patroni_ejabberd_role_previous_state-}" = "nx" ]
		then
			dna-echo -m "Assigning password to the ejabberd postgresql/patroni user"
			PGPASSWORD="${patroni_postgres_password}" psql -h "${hostname}" -p "5432" -U "postgres" -c "alter user ejabberd with encrypted password '$patroni_ejabberd_password'"
			echo
		fi

		### Allow the ejabberd postgresql/patroni user to log in with password if we've just created it

		if [ "${patroni_ejabberd_role_previous_state-}" = "nx" ]
		then
			dna-echo -m "Assigning password to the ejabberd postgresql/patroni user"
			PGPASSWORD="${patroni_postgres_password}" psql -h "${hostname}" -p "5432" -U "postgres" -c "alter role ejabberd with login"
			echo
		fi

		### Create the ejabberd postgresql/patroni database

		if ! PGPASSWORD="${patroni_postgres_password}" psql -h "${hostname}" -p "5432" -U "postgres" -c "\l" 2> /dev/null | grep -q ejabberd
		then
			dna-echo -m "Creating PSQL database"
			PGPASSWORD="${patroni_postgres_password}" psql -h "${hostname}" -p "5432" -U "postgres" -c "create database ejabberd"
			patroni_ejabberd_db_previous_state="nx"
		fi

		### Make the ejabberd postgresql/patroni user the owner of its database

		if [ "${patroni_ejabberd_role_previous_state-}" = "nx" ]
		then
			dna-echo -m "Assigning password to the ejabberd postgresql/patroni user"
			PGPASSWORD="${patroni_postgres_password}" psql -h "${hostname}" -p "5432" -U "postgres" -c "alter database ejabberd owner to ejabberd;"
			echo
		fi

		########################################################################

		### Import ejabberd psql schema

		########################################################################

		### Import ejabberd psql schema if the db was just created

		if [ "${patroni_ejabberd_db_previous_state-}" = "nx" ]
		then

			### Download ejabberd psql schema

			curl "https://raw.githubusercontent.com/processone/ejabberd/master/sql/pg.new.sql" > "${tmp_project_dir}/pg.new.sql"
			chmod 777 "${tmp_project_dir}/pg.new.sql"
			echo

			### Import into postgresql

			dna-echo -m "Importing PSQL default schema"
			PGPASSWORD="${patroni_ejabberd_password}" psql -h "${hostname}" -p "5432" -U ejabberd ejabberd < "/tmp/aenigma/pg.new.sql"
			echo

		fi

		########################################################################

		### Migrate mnesia to psql if necessary

		########################################################################

		if [ "${psql_migration_required-}" = "true" ]
		then

			### Start ejabberd

			aenigma-start_ejabberd

			### This is an old instance, start the migration

			aenigma-migrate-mnesia-postgresql

		fi

		########################################################################

	fi

}

aenigma-apply_haproxy_config() {

	############################################################################

	### Apply haproxy config

	############################################################################

	cat <<EOF > "/etc/haproxy/haproxy.cfg"
global
    maxconn 100

defaults
    log global
    mode tcp
    retries 2
    timeout client 30m
    timeout connect 4s
    timeout server 30m
    timeout check 5s

listen stats
    mode http
    bind *:7000
    stats enable
    stats uri /

listen postgres
    bind *:5000
    option httpchk
    http-check expect status 200
    default-server inter 3s fall 3 rise 2 on-marked-down shutdown-sessions
    server postgresql_public_ipv4-var_5432 public_ipv4-var:5432 maxconn 100 check check-ssl verify none port 8008
EOF

	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
	do
		### Ensure we don't add ourselves [therefore ignore the first line of nodes_db_ipv4].
		if [ ! "${node_ipv4}" = "${public_ipv4}" ]
		then
			sed -i "/5432 public_ipv4-var/a \    server postgresql_${node_ipv4}_5432 ${node_ipv4}:5432 maxconn 100 check check-ssl verify none port 8008" "/etc/haproxy/haproxy.cfg"
		fi
	done
	unset node_ipv4

	sed -i "s|public_ipv4-var|${public_ipv4}|g" "/etc/haproxy/haproxy.cfg"

	############################################################################

	operation_message="restarting haproxy on node: | ${l-}${hostname}${n-} |."
	dna-echo_operation -h

	systemctl restart haproxy

	dna-wait -s "4" -d "Now allowing haproxy to start up correctly..."

	dna-echo_operation -t

	############################################################################

}

aenigma-install_haproxy() {

	############################################################################

	### Install dependencies required for postgresql cluster

	aenigma-install_postgresql_dependencies

	############################################################################

	### Install haproxy

	dna-install_dependencies -p "haproxy"

	############################################################################

	### Apply haproxy config

	aenigma-apply_haproxy_config

	############################################################################

}

aenigma-provision_onion_tls_certificate() {

	### Provision self_signed wildcard certificate for $tor_hidden_service_hostname

	dna-provision_self_signed_wildcard_cert -d "${tor_hidden_service_hostname}"

	### Set permissions on for the new certs in $tls_project_dir

	aenigma-set_permissions

	### developing

}

aenigma-provision_tor() {

	### Make server reachable via tor

	############################################################################
	############################################################################

	### Get hostname

	dna-get_hostname

	############################################################################
	############################################################################

	### Install tor

	dna-install_tor

	operation_message="enabling Tor Hidden Service"
	dna-echo_operation -h

	dna-tor_enable_hidden_service

	sed -i '/############### This section is just for location-hidden services ###/,/################ This section is just for relays #####################/{//!d}' "/etc/tor/torrc"
	sed -i "/############### This section is just for location-hidden services ###/ r ${source_dir}/conf/tor/hidden_service" "/etc/tor/torrc"

	sed -i "s|public_ipv4-var|${public_ipv4}|g" "/etc/tor/torrc"

	dna-echo_operation -t

	operation_message="restarting Tor"
	dna-echo_operation -h

	service tor restart

	dna-echo_operation -t

	############################################################################
	############################################################################

	### TLS

	############################################################################

	### Provision self_signed wildcard certificate for $tor_hidden_service_hostname

	if [ ! -f "${tls_project_dir}/${tor_hidden_service_hostname}.cert.pem" ] || [ ! -f "${tls_project_dir}/${tor_hidden_service_hostname}.privkey.pem" ]
	then

		aenigma-provision_onion_tls_certificate

	fi

	############################################################################
	############################################################################

	### NGINX

	############################################################################

	### Increase names_hash_bucket_size to 128 in nginx config
	### as the .onion hostname is really long

	dna-nginx_increase_names_hash_bucket_size_128

	### Install conf for onion hostname

	operation_message="applying NGINX config for Tor"
	dna-echo_operation -h

	cp "${source_dir}/conf/nginx/onion" "/etc/nginx/conf.d/onion.conf"

	sed -i "s/tor_hidden_service_hostname-var/${tor_hidden_service_hostname}/g" "/etc/nginx/conf.d/onion.conf"

	sed -i "s/hostname.xyz/${hostname}/g" "/etc/nginx/conf.d/onion.conf"
	sed -i "s/domain.xyz/${domain}/g" "/etc/nginx/conf.d/onion.conf"

	dna-echo_operation -t

	### Make onion the default_server in nginx to avoid domain leaks in case of domains mismatches

	operation_message="applying NGINX config for Tor"
	dna-echo_operation -h

	sed -i "s|443 default_server ssl|443 ssl|g" "/etc/nginx/conf.d/${domain}.conf"
	sed -i "s|443 ssl|443 default_server ssl|g" "/etc/nginx/conf.d/onion.conf"

	dna-echo_operation -t

	### Restart nginx

	operation_message="restarting NGINX"
	dna-echo_operation -h

	service nginx restart

	dna-echo_operation -t

	############################################################################
	############################################################################

	### Allow .onion JID registrations and federate with other XMPP servers hosted inside the Tor network on hidden services via Tor itself [https://www.grepular.com/Transparent_Access_to_Tor_Hidden_Services]

	operation_message="adding .onion hostname to ejabberd hosts"
	dna-echo_operation -h

	if ! grep -q "${tor_hidden_service_hostname}" "/etc/ejabberd/ejabberd.yml"
	then
		sed -i "/^hosts:$/a \  - \"${tor_hidden_service_hostname}\"" "/etc/ejabberd/ejabberd.yml"
	fi

	dna-echo_operation -t

	operation_message="adding .onion hostname to SSLH config"
	dna-echo_operation -h

	if ! grep -q "xh${node_number}.${tor_hidden_service_hostname}" "/etc/sslh.cfg"
	then
		sed -i "/xmpp-client/a \    { name: \"tls\"; host: \"localhost\"; port: \"5443\"; sni_hostnames: [ \"xh${node_number}.$tor_hidden_service_hostname\" ]; log_level: 1; }," "/etc/sslh.cfg"
	fi

	if ! grep -q "ae${node_number}.${tor_hidden_service_hostname}" "/etc/sslh.cfg"
	then
		sed -i "/spdy/a \    { name: \"tls\"; host: \"localhost\"; port: \"5223\"; sni_hostnames: [ \"ae${node_number}.$tor_hidden_service_hostname\" ]; log_level: 1; }," "/etc/sslh.cfg"
	fi

	dna-echo_operation -t

	operation_message="restarting ufw"
	dna-echo_operation -h

	service ufw restart

	dna-echo_operation -t

	operation_message="restarting ejabberd"
	dna-echo_operation -h

	service ejabberd restart

	dna-echo_operation -t

	operation_message="enabling Tor DNS resolution for .onion domains"
	dna-echo_operation -h

	### Tor

	if ! grep -q "DNSPort   0.0.0.0:5300" "/etc/tor/torrc"
    then
        cat <<EOF >> "/etc/tor/torrc"
DNSPort   0.0.0.0:5300
VirtualAddrNetworkIPv4 10.192.0.0/11
AutomapHostsOnResolve 1

TransPort 9040
EOF
    fi

	service tor restart

	dna-echo_operation -t

	### Unbound

	operation_message="installing unbound local DNS server"
	dna-echo_operation -h

	dna-install_dependencies -p "unbound"

	cat <<EOF > "/etc/unbound/unbound.conf.d/tor.conf"
server:

domain-insecure: "onion"
private-domain: "onion"
do-not-query-localhost: no
local-zone: "onion." nodefault

forward-zone:
    name: "onion"
    forward-addr: 127.0.0.1@5300
EOF

	service unbound restart

	dna-echo_operation -t

	### Enable unbound as the system-wide dns resolver.

	echo "127.0.0.1" > "/etc/resolv.conf"

	### UFW / IPTABLES

	operation_message="configuring IPtables for Tor routing"
	dna-echo_operation -h

	if ! grep -q "DNSPort   0.0.0.0:5300" "/etc/ufw/before.rules"
	then
		cat <<EOF >> "/etc/ufw/before.rules"
*nat
-A INPUT      -p tcp --dport 9040     -j ACCEPT
-A PREROUTING -p tcp -d 10.192.0.0/11 -j REDIRECT --to-port 9040
-A OUTPUT     -p tcp -d 10.192.0.0/11 -j REDIRECT --to-port 9040
COMMIT
EOF
	fi

	service ufw restart

	sleep 1

	ufw disable && ufw --force enable

	echo

	dna-echo_operation -t

	dna-echo -s "Tor successfully provisioned!"

	############################################################################
	############################################################################

	### Create alternate webroot for onion specific customizations and converse

	############################################################################

	### Create web locations and populate it

	mkdir -p "/var/www/onion/"
	chown -R "www-data:www-data" "/var/www/onion/"

	cp "${source_dir}/conf/web/global/index.html" "/var/www/${proj_name}/"

	############################################################################
	############################################################################

}

aenigma-provision_conversejs() {

	### Provision conversejs

	############################################################################

	### Install dependencies

	dna-install_nodejs

	############################################################################

	### Clone and build

	if [ -d "/var/www/${proj_name}/xmpp/" ]
	then
		if [ -d "/var/www/${proj_name}/xmpp-old/" ]
		then
			rm -rf "/var/www/${proj_name}/xmpp-old/"
		fi
		mv "/var/www/${proj_name}/xmpp/" "/var/www/${proj_name}/xmpp-old/"
	fi

	git clone https://github.com/conversejs/converse.js "/var/www/${proj_name}/xmpp/"

	( cd "/var/www/${proj_name}/xmpp/" && make dev && make dist )

	echo

	### Install libsignal dependency

	( cd "/var/www/${proj_name}/xmpp/" && mkdir -p "3rdparty" && curl "https://raw.githubusercontent.com/signalapp/libsignal-protocol-javascript/master/dist/libsignal-protocol.js" > "./3rdparty/libsignal-protocol.js" )

	echo

	### Move fullscreen.html to index.html

	mv "/var/www/${proj_name}/xmpp/fullscreen.html" "/var/www/${proj_name}/xmpp/index.html"

	### Localize sources

	sed -i "s|https://cdn.conversejs.org/4.2.0/css/converse.min.css|dist/converse.min.css|g" "/var/www/${proj_name}/xmpp/index.html"
	sed -i "s|https://cdn.conversejs.org/3rdparty/libsignal-protocol.min.js|3rdparty/libsignal-protocol.js|g" "/var/www/${proj_name}/xmpp/index.html"
	sed -i "s|https://cdn.conversejs.org/4.2.0/dist/converse.min.js|dist/converse.min.js|g" "/var/www/${proj_name}/xmpp/index.html"

	### Remove analytics

	sed -i "/inverse-analytics.js/d" "/var/www/${proj_name}/xmpp/index.html"
	sed -i "/stats.opkode.com\/piwik.php/d" "/var/www/${proj_name}/xmpp/index.html"

	### Use our own ejabberd websocket service

	sed -i "s|bosh_service_url|websocket_url|g" "/var/www/${proj_name}/xmpp/index.html"
	sed -i "s|https://conversejs.org/http-bind/|wss://xh${node_number}.${domain}/ws/|g" "/var/www/${proj_name}/xmpp/index.html"

	### Remove test bosh service warning

	sed -i "s|, // Please use this connection manager only for testing purposes|,|g" "/var/www/${proj_name}/xmpp/index.html"

	### Set permissions

	chown -R www-data:www-data "/var/www/${proj_name}/xmpp/"

	############################################################################

	### Also make Converse available over Tor in its alternate webroot

	rsync -aAXXz "/var/www/${proj_name}/xmpp/" "/var/www/onion/xmpp/"

	### Use onion-specific websocket

	sed -i "s|wss://xh${node_number}.${domain}/ws/|wss://${tor_hidden_service_hostname}/ws/|g" "/var/www/onion/xmpp/index.html"

	### Remove test bosh service warning from onion-specific config

	sed -i "s|, // Please use this connection manager only for testing purposes|,|g" "/var/www/onion/xmpp/index.html"

	############################################################################
	############################################################################

}

backup_locally_loop() {

	if [ "${cluster_mode-}" = "secondary" ]
	then
		echo "${r-}${b-}The backup script is only intended to run on the primary node.${x-}"
		echo
		echo "${b-}The primary node will take care of backing up the ejabberd uploads directory of the secondary nodes. No further backup is required on secondary nodes.${x-}"
		echo
		dna-exit
	fi

	cp -r "${conf_dir}" "${tmp_backup_dir}"/conf/
	mkdir -p "${tmp_backup_dir}"/data/
	/usr/sbin/ejabberdctl backup ejabberd-mnesia-backup
	mv /var/lib/ejabberd/ejabberd-mnesia-backup "${tmp_backup_dir}"/data/ejabberd-mnesia-backup
	cp -r /etc/ejabberd/ "${tmp_backup_dir}"/data/etc-ejabberd/
	cp -r /var/lib/ejabberd/ "${tmp_backup_dir}"/data/var-lib-ejabberd/

	if [ "${cluster_enabled}" = "y" ]
	then
		for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
		do
			### Ensure we don't try connecting to ourselves [therefore ignore the first line of nodes_db_ipv4].
			if [ ! "${node_ipv4}" = "${public_ipv4}" ]
			then
				mkdir -p "${tmp_backup_dir}"/data/${node_ipv4}/"
				/usr/bin/scp -P42022 -o "ConnectTimeout=8" -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@ae${node_ipv4}:/var/lib/ejabberd/uploads/" "${tmp_backup_dir}"/data/${node_ipv4}/"
			fi
		done
		unset node_ipv4
	fi

}

restore_loop() {

	echo "${b-}1] Now restoring aenigma config directory...${x-}"
	echo

	rsync -aAXx --delete $restore_file_path/conf/ $conf_dir/

	echo "${b-}2] Now restoring ejabberd database...${x-}"
	echo

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
	        echo "${g-}${b-}ejabberd is already running. Continuing...${x-}"
	        echo
	else
	        echo "${r-}${b-}ejabberd NOT running. Starting it now...${x-}"
	        echo
	        echo "${b-}Now starting ejabberd ...${x-}"
	        /usr/sbin/service ejabberd start
	        echo
	        dna-wait -s "8" -d "Now allowing ejabberd to start up correctly..."
	        /usr/sbin/ejabberdctl
	        echo
	        sleep 1
	fi

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
	        cd $restore_file_path/data/
		cp ./ejabberd-mnesia-backup /var/lib/ejabberd/
	        /usr/sbin/ejabberdctl restore ejabberd-mnesia-backup
		rm /var/lib/ejabberd/ejabberd-mnesia-backup
	        echo "${b-}Successfully restored ejabberd database...${x-}"
	        echo
	        dna-wait -s "8" -d "Now allowing ejabberd sync the database..."
	else
	        echo "${r-}${b-}ERROR: ejabberd STILL NOT running. Unable to restore database from backup.${x-}"
	        echo
	        dna-exit
	fi

	echo "${b-}Now restoring ejabberd directories...${x-}"
	echo

	echo "${b-}Now stopping ejabberd for directory restore...${x-}"
	echo
	/usr/sbin/service ejabberd stop
	dna-wait -s "8" -d "Now allowing ejabberd to shut down correctly..."

	echo "${b-}3] Now syncing ejabberd directories...${x-}"
	echo

	rsync -aAXx --delete $restore_file_path/data/etc-ejabberd/ /etc/ejabberd/
	rsync -aAXx --delete $restore_file_path/data/var-lib-ejabberd/ /var/lib/ejabberd/

	aenigma-set_permissions

	echo "${b-}Now starting ejabberd...${x-}"
	/usr/sbin/service ejabberd start
	echo
	dna-wait -s "8" -d "Now allowing ejabberd to start up correctly..."
	/usr/sbin/ejabberdctl status
	echo
	sleep 1

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then

	        echo "${g-}${b-}Restore complete!${x-}"
	        echo
	        echo "${b-}Now please verify your aenigma instance is running correctly and has everything you except it to.${x-}"
	        echo

	        read -p "${b-}Has your previous instance of aenigma been restored correctly? (Y/n): ${x-}" -n 1 -r
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
	                echo "${g-}${b-}Ok, all done!${x-}"
	                echo
	                if [ -f $conf_dir/blocks3backups ]
	                then
				rm $conf_dir/blocks3backups
	                        echo "${b-}Removing S3 backups lock since your restore has been successful.${x-}"
	                        echo
	                        echo "${r-}${b-}This machine will now pick up where the old one left off and start backing up again to S3 and will overwrite all previous data stored on S3.${x-}"
	                        echo
	                        echo "${b-}If you've changed your mind and are NOT yet sure this restore was completely successful, simply:${x-}"
	                        echo
	                        echo "${b-} | touch $conf_dir/blocks3backups |"
	                        echo
	                        echo "${b-}And remember to remove it as soon as you're done verifying this restored instance to then resume backups to S3!${x-}"
	                        echo
	                        echo "${g-}${b-}All done for now.${x-}"
	                        echo
	                fi
	        else
	                echo
	                echo "${b-}Sorry about that, please collect all evidence you can find so and simply file an issue report at:${x-}"
		        	echo
		        	echo "${b-} | ${git_host}/${author_name}/${project_name}/issues |${x-}"
		        	echo
		        	echo "${b-}Thank you in advance!${x-}"
	                echo
	        fi

	else

	        echo "${r-}${b-}ERROR: ejabberd not running after restore. Please check ejabberd directories.${x-}"
	        echo
	        echo "${b-}Please collect all evidence you can find so and simply file an issue report at:${x-}"
	        echo
	        echo "${b-} | https://github.com/openspace42/aenigma/issues |${x-}"
	        echo
	        echo "${b-}Thank you in advance!${x-}"
	        echo
	        echo "${b-}Exiting...${x-}"
	        echo
	        exit

	fi

	if [ -d "$restores_dir/local/" ]
	then
		rm -r "$restores_dir/local/"
	fi

	if [ -d "/root/${proj_name}-restore/" ]
	then
		rm -r "/root/${proj_name}-restore/"
	fi

	if [ -d "$tmpdir" ]
	then
		rm -r "${tmpdir:?}"
	fi

	if [ $bootstrapmode = "on" ]
	then
		echo "${b-}Now that we're finished with the initial restore, it's time to re-run the install script and get this machine up and running with your old instance's files and settings${x-}"
		echo
		echo "${b-}Running install script now.${x-}"
		echo
		echo "${r-}${b-}Should you exit the install script during its runtime, you can re-run it manually with:${x-}"
		echo
		echo "${b-} | bash $sourcedir/install.sh | ${x-}"
		cd
		bash $sourcedir/install.sh
	fi

}

################################################################################
################################################################################
################################################################################

synthia-perform_installation() {

	############################################################################
	################### Add your install-time functions here ###################
	############################################################################

	### Display aenigma logo

	aenigma-display_logo

	############################################################################

	### Link tools in $PATH

	dna-link_tools

	############################################################################

	### Display intro

	if [ "${skip_intro}" = "n" ]
	then
	    aenigma-xmpp_intro
	fi

	############################################################################

	if ! dna-check_distro_ubuntu_18 && ! dna-check_distro_debian_9
	then
		dna-echo -e "${proj_name} only runs on Ubuntu 18.04 LTS [bionic] or Debian 9 [stretch]."
		dna-echo -m "This is due - among other factors - to the fact that the ejabberd version installed by our APT repo of choice on previous releases is too old."
		dna-echo -m "You can edit out this check to proceed at your own risk."
		dna-exit
	fi

	############################################################################

	dna-abort_on_sslh_session

	dna-inception -h -m -p

	############################################################################

	dna-refresh_tmp_project_dir

	mkdir -p "${tls_project_dir}"

	############################################################################

	### globally allow APT to fail during the course of the installation until the final check round

	export dna_global_allow_apt_errors="y"

	############################################################################

	### Legacy fixes and migration detections

	if [ -f "${tls_project_dir}/dh.pem" ]
	then
		rm "${tls_project_dir}/dh.pem"
	fi

	if dpkg -s ejabberd &> /dev/null
	then
		if ! grep -q "default_db: sql" "/etc/ejabberd/ejabberd.yml"
		then
			export psql_migration_required="true"
		fi
	fi

	if [ -f "/etc/nginx/conf.d/aenigma.conf" ]
	then
		rm "/etc/nginx/conf.d/aenigma.conf"
	fi

	############################################################################

	clear

	### Ask user if this aenigma node is going to be part of a cluster

	describe_setting() {

		dna-echo -m "${proj_name} can be setup to run in a cluster of multiple servers, all working together to make your instance run smoothly, robustly, and be fault-tolerant and load-balancing."
		dna-echo -m "If you wish to setup ${proj_name} in a cluster configuration, you must specify so now."

	}

	validate_input() {

		case $input in
			single)		valid="y"
						;;
			cluster)	valid="y"
						;;
			*)			dna-echo -e "Invalid setting for | ${n-}cluster_enabled${r-} | in function | ${n-}${FUNCNAME[0]}${r-} |."
						valid="n"
						;;
		esac

	}

	dna-set_option -o "cluster_enabled" -p "cluster" -d "y" -c "[single/cluster]" -v "y"

	if [ "${cluster_enabled}" = "cluster" ]
	then

		describe_setting() {

			dna-echo -m "Having chosen to run ${proj_name} in a cluster of servers, you must now designate your master node that will be performing some special operations to lead the cluster."

		}

		validate_input() {

			case $input in
				primary)	valid="y"
							;;
				secondary)	valid="y"
							;;
				*)			dna-echo -e "Invalid setting for | ${n-}cluster_enabled${r-} | in function | ${n-}${FUNCNAME[0]}${r-} |."
							valid="n"
							;;
			esac

		}

		dna-set_option -o "cluster_mode" -p "cluster" -d "y" -c "[primary/secondary]" -v "y"

		if [ "${cluster_mode-}" = "primary" ]
		then
			dna-echo -m "Having chosen that this server will be your primary node for your ${proj_name} installation, we can carry on with the standard installation."
		else
			dna-echo -m "Having chosen that this server will be a secondary node for your ${proj_name} installation, we first need to make sure that there is an already running primary node that is already up and running and perfectly configured."
            dna-ask_for_boolean -d "y" -q "Is the primary node for this ${proj_name} already up and running and perfectly configured?"
            if [ "${boolean_output}" = "y" ]
            then
				dna-echo -m "Ok, let's then continue on with the configuration of this secondary node and proceed to have it join the cluster lead by your already running primary node..."
            else
				dna-echo -m "Ok, no problem. Please proceed with the full installation and configuration of your primary node on its respective server by following the same ${proj_name} install and selecting the | ${y-}primary${n-} | node option when prompted."
				dna-echo -m "Only then will we be able to continue with the installation of this secondary node."
				dna-echo -m "Aborting installation for now."
                dna-exit
            fi
		fi

	fi

	############################################################################
	############################################################################

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		########################################################################

		### Start creating the nodes_db files and print this machine [the primary node]'s public IPv4 and IPv6 [if available] to the first line of each
		### We create the nodes_db file independently of whether clusterization is enabled or not.

		if [ "${cluster_enabled}" = "single" ]
		then

			### Clusterization has been turned off. Delete the conf_nodes directory if present.

			if [ -d "${conf_cluster_nodes_dir}" ]
			then
				rm -rf "${conf_cluster_nodes_dir}"
			fi

		fi

		########################################################################

		### Set XMPP domain

	    describe_setting() {

	        dna-echo -m "Now specify your top level domain, which will become the part after the @ in your JIDs [XMPP account addresses]."
			dna-echo -m "In the next step you'll be able to specify additional domains for which all XMPP services will be fully provided just like this one."
			dna-echo -m "The domain you'll be specifying right now will simply be the administrative domain for this and any other machines part of this ${proj_name} instance."

	    }

		validate_input() {

			dna-validate_domain -std "${input}"

			if [ "${domain_is_valid}" = "y" ]
			then
				valid="y"
			else
				dna-echo -m "Check the syntax to ensure it is in fact a top-level domain and try again."
				valid=n
			fi

			unset silent

		}

	    dna-set_option -o "domain" -p "xmpp" -d "y" -v "y"

	    if [ "${previous_value_outcome}" = "not-kept" ]
	    then

	        dna-echo -m "- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -"
	        dna-echo -e "WARNING:"
	        dna-echo -e "Changing domains will not preserve any user accounts or data. It will revert this ejabberd instance to a fresh install."
	        dna-echo -m "In the future, all user accounts and data for the previous domain might be recovered automatically if you ever re-run this install and select the old domain, but this hasn't been thoroughly tested yet."
	        dna-echo -m "If you answer no to the following question, nothing will be deleted."
	        dna-echo -m "- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -"

            dna-ask_for_boolean -d "n" -q "Are you absolutely sure you want to change the XMPP domain now?"
            if [ "${boolean_output}" = "y" ]
            then
	            dna-echo -m "Ok, proceeding..."
	        else
	            dna-echo -m "Ok, setting your domain back to the previous value | ${y-}${previous_value}${n-} |..."
	            domain="${previous_value}"
	            echo "${previous_value}" > "${opt_path}"
	        fi

	    fi

		########################################################################

		### Set additioanl XMPP domains

	    describe_setting() {

	        dna-echo -m "Now specify any additional domains, for which XMPP services will be provided alongside your main domain."
			dna-echo -m "Domains must be inputted in space separated format, such as: | ${y-}abc.com xyz.org 123.net${n-} |."
			dna-echo -m "If you don't wish to specify any additional domains, simply type: | ${y-}none${n-} |."

	    }

		validate_input() {

			if [ "${input}" = "none" ]
			then

				valid="y"

			else

				additional_domains_array=(${input})
				for additional_domain in "${additional_domains_array[@]}"
			    do

					dna-validate_domain -std "${additional_domain}"

					if [ "${domain_is_valid}" = "y" ]
					then
						valid="y"
					else
						dna-echo -m "Check the syntax to ensure it is in fact a top-level domain and try again."
						valid=n
						break
					fi

				done

				unset silent

			fi

		}

	    dna-set_option -o "additional_domains" -p "xmpp" -d "y" -v "y"

	    if [ "${previous_value_outcome}" = "not-kept" ]
	    then

	        dna-echo -m "- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -"
	        dna-echo -e "WARNING:"
	        dna-echo -e "If you are removing any additional domains, this operation will not preserve any user accounts or data related to such domains."
	        dna-echo -m "In the future, all user accounts and data for the previous domains might be recovered automatically if you ever re-run this install and specify the same additional domains as before, but this hasn't been thoroughly tested yet."
	        dna-echo -m "If you answer no to the following question, nothing will be deleted."
			dna-echo -m "This only applies to removed domains and you can ignore this warning entirely if you are NOT removing any domain [but only adding]."
	        dna-echo -m "- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -"

            dna-ask_for_boolean -d "n" -q "Are you absolutely sure you want to change your additional XMPP domains now?"
            if [ "${boolean_output}" = "y" ]
            then
	            dna-echo -m "Ok, proceeding..."
	        else
	            dna-echo -m "Ok, setting your additional domains back to the previous value | ${y-}${previous_value}${n-} |..."
	            additional_domains="${previous_value}"
	            echo "${previous_value}" > "${opt_path}"
	        fi

	    fi

		########################################################################

		### Review and set machine hostname

		curr_host_name="$(cat /etc/hostname)"

	    if [ "${curr_host_name}" = "ae01.${domain}" ]
	    then

			dna-echo -s "Your hostname is already correctly set to: | ${n-}ae01.${domain}${g-} |."

		else

			dna-echo -m "This machine's hostname must become: | ${y-}ae01.${domain}${n-} |."
			dna-echo -m "This allows for a correct setup of ejabberd that will make it possible in the future to turn this instance of ${proj_name} into a cluster should you ever choose to do so."
			dna-echo -m "Your current hostname is:"
			dna-echo -m " | ${y-}${curr_host_name}${n-} | "
            dna-ask_for_boolean -d "y" -q "Do you want to correctly set your hostname automatically?"
            if [ "${boolean_output}" = "y" ]
            then
			    dna-echo -m "Ok, setting hostname to: | ${y-}ae01.${domain}${n-} |."
			    echo "ae01.${domain}" > "/etc/hostname"
			else
			    dna-echo -m "Ok, not changing hostname."
				dna-exit
			fi

	    fi

		dna-get_hostname

		hostname -F "/etc/hostname"

		########################################################################

		### Review domain and hostname to see if the user approves

		dna-echo -m "----------------------------------------------------------------"

		dna-echo -m "To make sure everything is correct:"

		dna-echo -m "----------------------------------------------------------------"

		dna-echo -m "1] Your primary | ${o-}domain${n-} | [the part after the @ in your XMPP account addresses] will be:"
		dna-echo -m " | ${y-}${domain}${n-} | "
		dna-echo -m "2] And therefore your | ${o-}JIDs [XMPP account addresses]${n-} | will look as follows:"
		dna-echo -m " | ${y-}aurora@${domain}${n-} | "
		dna-echo -m "3] Your | ${o-}hostname${n-} | [the location on the internet of this server] will be:"
		dna-echo -m " | ${y-}${hostname}${n-} | "
		dna-echo -m "4] And therefore your | ${o-}${proj_name} admin panel${n-} | will be located at:"
		dna-echo -m " | ${y-}https://${hostname}${n-} | "

		dna-echo -m "----------------------------------------------------------------"

		if [ ! "${additional_domains-}" = "none" ]
		then

			dna-echo -m "5] In addition, your | ${o-}additional domains${n-} | will be:"
			dna-echo -m " | ${y-}${additional_domains}${n-} | "

			dna-echo -m "----------------------------------------------------------------"

		fi

		dna-ask_for_boolean -d "y" -q "Does everything look all right?"
		if [ "${boolean_output}" = "y" ]
		then
		    dna-echo -m "Ok, continuing."
		else
		    dna-echo -m "Ok, no worries. You can re-run this script right now and make the correct choices. Exiting..."
		    dna-exit
		fi

		########################################################################

		### Set node_number to 01 as this is the primary node

		dna-set_option -o "node_number" -p "cluster" -s "01"

		### Initialize nodes_db files

		aenigma-initialize_nodes_db_files

		### Update routing info

		aenigma-update_routing_info

		########################################################################

	fi

	############################################################################
	############################################################################

	### Set admin email address

	dna-set_admin_email

	############################################################################

	### Check internet connectivity and get public IP addresses

	dna-get_public_ipv4

	dna-check_ipv6_connectivity

	############################################################################

	### Create the necessary files and directories for ejabberd

	aenigma-create_ejabberd_locations

	### Create the $conf_xmpp_dir

	mkdir -p "${conf_xmpp_dir}"

	############################################################################

	if [ "${cluster_enabled}" = "cluster" ]
	then

		### Add cronjob for resync_cluster script

		dna-add_cron_job -n "${proj_name}-resync_cluster" -t "@reboot" -c "bash /root/openspace42/${proj_name}/tools/${proj_name}-resync_cluster --return-check"

	fi

	############################################################################
	############################################################################

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		### Create domains_db

		aenigma-create_domains_db

		### Proceed with primary node installation

		aenigma-perform_dns_checks

		########################################################################

		### Install certbot preemtively to then correctly place the post renewal hook

		dna-install_certbot

		#### Copy the LetsEncrypt post-renewal script to its location and actually run it now to be ready for the installation

		cp "${source_dir}/conf/letsencrypt/post-renewal-hook" "/etc/letsencrypt/renewal-hooks/post/${proj_name}-create-push-certs"

		### Execute the post-renewal script now to generate the all-in-one TLS cert for ejabberd

		bash "${tools_dir}/${proj_name}-create-push-certs"

		clear

		########################################################################

		### Setup backup restore

		dna-setup_backup_restore

		########################################################################

	else

		### Proceed with secondary node installation

		########################################################################

		### Clear any letsencrypt post-renewal-hook if present from a previous installation in primary node mode

		if [ -f "/etc/letsencrypt/renewal-hooks/post/${proj_name}-create-push-certs" ]
		then
			rm "/etc/letsencrypt/renewal-hooks/post/${proj_name}-create-push-certs"
		fi

		########################################################################

		### Generate token [or use the public IPv6 address of this machine if available] as visual fingerprint for user connection checking.

		if [ "${ipv6_available}" = "y" ]
		then
			echo "${this_ipv6}" > "${tmp_project_dir}/aenigma-cluster-token"
		else
			aenigma_cluster_token="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)"
			echo "${aenigma_cluster_token}" > "${tmp_project_dir}/aenigma-cluster-token"
		fi

		########################################################################

		### Temporarily allow incoming connections on port 42022 *without limit* on UFW to avoid locking out the primary node during installation.

		/usr/sbin/ufw allow 42022
		echo

		########################################################################

		dna-echo -m "This is the public IPv4 for this machine:"
		dna-echo -m " | ${y-}$public_ipv4${n-} | "
		dna-echo -m "Enter it on the primary node when prompted to do so, then follow the instructions from there."

		sleep 1

		########################################################################

		if [ -f "${ssh_auth_keys_file}" ]
		then
	        dna-echo -s "SSH Authorized Keys file found."
		else
			dna-echo -m "SSH Authorized Keys file NOT found. Creating it now."
			mkdir -p "/root/.ssh/"
	        touch "${ssh_auth_keys_file}"
		fi

		########################################################################

		if grep -q "ae01." "${ssh_auth_keys_file}"
		then

			dna-echo -s "An SSH public key generated by the primary node was already previously saved on this server."

			####################################################################

			check_condition() {

				if [ -f "${tmp_project_dir}/aenigma-cluster-ssh-connection-successful" ]
				then
					condition_verified="y"
				fi

			}

			dna-wait_for -m "32" -d "Now looking to see if the primary node is already able to connect to this node..."

			if [ "${wait_output}" = "ok" ]
			then
				dna-echo -s "Primary node SSH connection to this node succeeded. Continuing installation..."
				primary_node_ssh_connection="ok"
				rm -r "${tmp_project_dir}/aenigma-cluster-ssh-connection-successful"
			else
				dna-echo -e "The primary node was not able to connect to this node with the SSH public key already saved on this machine."
				dna-echo -m "You will now need to specify the SSH public key displayed on your primary node."
				dna-echo -m "[or if it manages to connect in the mean time, simply type: | ${y-}skip${n-} |]"
				primary_node_ssh_connection="attempted"
			fi

			unset wait_output

			####################################################################

		fi

		if [ ! "${primary_node_ssh_connection-}" = "ok" ]
		then

			validate_input() {

				if [ "${input}" = "skip" ]
				then

					if [ -f "${tmp_project_dir}/aenigma-cluster-ssh-connection-successful" ]
					then
						valid="y"
					else
						dna-echo -e "The primary node still does NOT appear to have been able to successfully connect to this node."
						dna-echo -m "Ensure its connection to this machine has actually succeeded and, if not, specify the public SSH key it will display shortly."
						valid=n
					fi

				else

					dna-validate_ssh_pubkey -s -k "${input}"

					if [ "${key_is_valid}" = "y" ]
					then
						valid="y"
					else
						dna-echo -e "The key you specified does NOT appear to be a valid SSH Public Key."
						valid="n"
					fi

					unset silent

				fi

			}

			if [ "${primary_node_ssh_connection-}" = "attempted" ]
			then
				dna-set_value -d "Now specify the public SSH key [or write | ${y-}skip${n-} | if the connection was already successful]:" -v "y"
			else
				dna-set_value -d "Now specify the public SSH key that will be displayed shortly on the primary node:" -v "y"
			fi

			cluster_ssh_pubkey="${value}"

			if [ ! "${value}" = "skip" ]
			then

				if ! grep -q "${cluster_ssh_pubkey}" "${ssh_auth_keys_file}"
				then
					echo "$cluster_ssh_pubkey" >> "${ssh_auth_keys_file}"
				fi

			fi

			unset value

		fi

		################################################################################

		### Print clusterization token and instructions

		dna-echo -m "A token has been generated to verify a correct connection to this machine from the primary node."
		dna-echo -m "You'll be asked to verify it matches with the one that will shortly be displayed on the primary node."
		dna-echo -m "Its value is: | ${y-}$(cat ${tmp_project_dir}/aenigma-cluster-token)${n-} |."

		dna-echo -m "After that, continue the setup on the primary node and come back here when finished."

		sleep 1

		########################################################################

		check_condition() {

			if [ -f "${tmp_project_dir}/aenigma-cluster-primary-node-setup-complete" ]
			then
				condition_verified="y"
			fi

		}

		dna-wait_for -d "Now waiting for setup on the primary node to be complete..."
		rm -r "${tmp_project_dir}/aenigma-cluster-primary-node-setup-complete"
		dna-echo -s "Primary node setup complete. Now continuing installation..."
		unset wait_output
		sleep 1

		########################################################################

		### Re-limit port 42022 on UFW

		/usr/sbin/ufw limit 42022
		echo

		########################################################################

		### Read newly received config

		dna-read_conf_settings

		aenigma-set_secondary_node_hostname

		########################################################################

	fi

	############################################################################
	############################################################################

	### UFW

	############################################################################

	### Set UFW rules

	operation_message="setting UFW rules"
	dna-echo_operation -h

	ufw allow 5222
	ufw allow 5223
	ufw allow 5269
	ufw allow 5443
	ufw allow 80
	ufw allow 443

	echo

	dna-echo_operation -t

	############################################################################
	############################################################################

	### NGINX

	aenigma-provision_nginx

	############################################################################
	############################################################################

	### Install mail notifications

	dna-install_mail_notifications -f

	### Install SSLH

	aenigma-install_sslh

	############################################################################
	############################################################################

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		### Determine if this is a fresh install

		if [ ! -f "/var/lib/ejabberd/LATEST.LOG" ]
		then

			### This is a fresh install, we can proceed with customizing the ERLANG_NODE value in the /etc/default/ejabberd config file and wiping the data directory after installing ejabberd.

			set_erlang_node_to_hostname="ok"
			wipe_var_lib_ejabberd="ok"

		else

			### This is a re-install.

			wipe_var_lib_ejabberd="no"

			### Check to see if config file already exists.

			if [ -f "/etc/default/ejabberd" ]
			then

				### The config file is in place. Check to see if the ERLANG_NODE value is already correct.

				if grep -q "^ERLANG_NODE=ejabberd@${hostname}$" "/etc/default/ejabberd"
				then

					### The configuration is already correct, the existing data in /var/lib/ejabberd will work fine.

					set_erlang_node_to_hostname="not_necessary"

				else

					### Check to see if the ERLANG_NODE line exists

					if ! grep -q "ERLANG_NODE=ejabberd@" "/etc/default/ejabberd"
					then

						dna-echo -e "There is an error in your existing | ${n-}/etc/default/ejabberd${r-} | file as the | ${n-}ERLANG_NODE${r-} | setting is missing."
						dna-echo -m "The installation will continue without any issues, but ejabberd might refuse to start at the end if your existing data in | ${y-}/var/lib/ejabberd/${n-} | indicates that ejabberd was previously running under a different ERLANG_NODE value."
						dna-echo -m "If this is the case, after the installation is complete, edit the | ${y-}/etc/default/ejabberd${n-} | file and set the ERLANG_NODE value back to whatever you were using before [likely | ${y-}ERLANG_NODE=ejabberd@localhost${n-} |]."
						dna-echo -m "Keep in mind, though, that altering the ERLANG_NODE value will make it impossible to turn this instance of $proj_name into a cluster in the future."
						dna-echo -m "To do that, you will have to start fresh by deleting the | ${y-}/var/lib/ejabberd/${n-} | directory and run an re-install in order to start using the brand new instance from scratch."
						read -rp "${b-}Press enter to continue...${x-}"
						echo

						set_erlang_node_to_hostname="ok"

					else

						### Check to see if the ERLANG_NODE line is commented or its value is set to localhost

						if grep -q "#ERLANG_NODE=ejabberd@" "/etc/default/ejabberd" || grep -q "^ERLANG_NODE=ejabberd@localhost$" "/etc/default/ejabberd"
						then

							dna-echo -e "Your existing | ${n-}/etc/default/ejabberd${r-} | config file indicates that you were previously using this instance with a previous version of ${proj_name}."

						else

							dna-echo -e "Your existing | ${n-}/etc/default/ejabberd${r-} | config file indicates that you were previously using this instance of ${proj_name} with a different hostname than the current one."

						fi

						dna-echo -m "If you choose to continue with the upgrade/re-install, the installation will continue without any issues, but it will be impossible to turn this instance of $proj_name into a cluster in the future."
						dna-echo -m "To do that, you will have to start fresh by deleting the | ${y-}/var/lib/ejabberd/${n-} | directory and run an re-install in order to start using the brand new instance from scratch."
						read -rp "${b-}Press enter to continue...${x-}"
						echo

						set_erlang_node_to_hostname="skip"

					fi

				fi

			else

				### It's possible the installation was never completed in the first place, this might explain the lack of a configuration file.

				if [ -f "${conf_dir}/version/version_installed" ]
				then

					### An installation was actually completed at some point. Proceed with warning the user.

					dna-echo -e "The | ${n-}/etc/default/ejabberd${r-} | configuration file of this existing installation of ${proj_name} is missing."
					dna-echo -m "The installation will continue without any issues, but ejabberd might refuse to start at the end if your existing data in | ${y-}/var/lib/ejabberd/${n-} | indicates that ejabberd was previously running under a different ERLANG_NODE value."
					dna-echo -m "If this is the case, after the installation is complete, edit the | ${y-}/etc/default/ejabberd${n-} | file and set the ERLANG_NODE value back to whatever you were using before [likely | ${y-}ERLANG_NODE=ejabberd@localhost${n-} |]."
					dna-echo -m "Keep in mind, though, that altering the ERLANG_NODE value will make it impossible to turn this instance of $proj_name into a cluster in the future."
					dna-echo -m "To do that, you will have to start fresh by deleting the | ${y-}/var/lib/ejabberd/${n-} | directory run an re-install in order to and start using the brand new instance from scratch."
					read -rp "${b-}Press enter to continue...${x-}"
					echo

				fi

				set_erlang_node_to_hostname="ok"

			fi

		fi

	else

		### As this is a secondary node, we need to join an existing ejabberd cluster and therefore start clean and remove any ejabberd data already present on this server.

		if [ -f "/etc/default/ejabberd" ]
		then

			### This is a re-install, as the config file is already in place. Check to see if the ERLANG_NODE value is already correct.

			if ! grep -q "^ERLANG_NODE=ejabberd@${hostname}$" "/etc/default/ejabberd"
			then

				### The ERLANG_NODE value is incorrect. Therefore, this instance was either previously installed in single [non-cluster] mode or was part of a different cluster. Alert the user of the imminent wipe.

				dna-echo -e "It appears this machine has an existing ejabberd installation."
				dna-echo -e "Proceeding with this installation as a secondary node will wipe anything and everything that might already present on this [and only this] server."
				dna-echo -m "If this node is currently part of a cluster, data on other nodes will NOT be affected."
				dna-echo -m "If however you've previously used this machine to host a standalone installation or not-yet-clusterized data, this will be permanently lost."
				dna-echo -m "Please ensure there is no UNIQUE [as in non-clustered] and VALUABLE [as in you don't want to lose] data on this machine before continuing."

				dna-ask_for_boolean -d "n" -q "Proceed with wiping any ejabberd-related data on this server during the course of this installation?"
				if [ "${boolean_output}" = "y" ]
				then

					### As the user has consented to a full wipe, we can therefore proceed with customizing the ERLANG_NODE value in the ejabberdctl.cfg config file and wiping the data directory after installing ejabberd.

					dna-echo -m "Ok, proceeding with ejabberd wipe at the end of this installation..."

					set_erlang_node_to_hostname="ok"
					wipe_var_lib_ejabberd="ok"

				else

					dna-echo -m "Ok, skipping ejabberd wipe and aborting installation."
					dna-exit

				fi

			else

				### The existing configuration is already correct, therefore the existing data is compatible with this re-clusterization.

				set_erlang_node_to_hostname="not_necessary"
				wipe_var_lib_ejabberd="no"

			fi

		else

			### There is no existing ejabberd installation, therefore proceed with wiping any leftover data without asking.

			set_erlang_node_to_hostname="ok"
			wipe_var_lib_ejabberd="ok"

		fi

	fi

	############################################################################
	############################################################################

	### Postgresql

	### Install etcd

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		aenigma-install_etcd_cluster

		aenigma-apply_and_restart_patroni_haproxy_ejabberd -r

	fi

	### Install haproxy

	aenigma-install_haproxy

	### Install PostgreSQL / Patroni

	aenigma-install_postgresql_patroni

	############################################################################
	############################################################################

	### Prepare APT for ejabberd installation.

	aenigma-add_ejabberd_repo

	############################################################################

	### Check the current status of ejabberd on this machine

	aenigma-get_ejabberd_installed_version

	if [ ! "${ejabberd_installed_version}" = "none" ]
	then

		### ejabberd is currently installed. Check if an ejabberd upgrade is going to be performed.

		aenigma-get_ejabberd_candidate_version

		if [ ! "${ejabberd_candidate_version}" = "${ejabberd_installed_version}" ]
		then

			dna-echo -s "A new version of ejabberd is available from the APT repository. Upgrading it now..."

			### Upgrade ejabberd by non-interactively installing the new config files
			### [which we'll the re-replace later in the installation anyway].

			export DEBIAN_FRONTEND=noninteractive ; apt-get install -y -o Dpkg::Options::="--force-confnew" --force-yes --only-upgrade ejabberd || true

		fi

	else

		### Remove the "ejabberd_admin_password_set" file if it exists as ejabberd was not currently installed

		if [ -f "${conf_xmpp_dir}/ejabberd_admin_password_set" ]
		then
			rm "${conf_xmpp_dir}/ejabberd_admin_password_set"
		fi

	fi

	############################################################################

	if [ "${psql_migration_required-}" = "true" ]
	then

		### Empty the /var/lib/ejabberd/ directory as we're now migrating to psql

		### Stop ejabberd

		service ejabberd stop

		### Copy dir to backup location

		rsync -aAXxz /var/lib/ejabberd/ /var/lib/ejabberd-before-psql-migration

		### Empty the dir

		rm -r /var/lib/ejabberd/*

		### Restore the uploads dir

		rsync -aAXxz /var/lib/ejabberd-before-psql-migration/uploads/ /var/lib/ejabberd/uploads/

	fi


	### Install the aenigma ejabberd config.

	aenigma-install_ejabberd_config

	### Perform a full APT upgrade

	dna-apt_full_upgrade -e

	### Actually install ejabberd.

	aenigma-install_ejabberd

	### Localize ejabberd configuration and restart it

	aenigma-localize_ejabberd_install

	### Only for psql migration

	if [ "${psql_migration_status-}" = "complete" ]
	then
		ufw allow 5222
		ufw allow 5223
		ufw allow 5444
		echo
	fi

	############################################################################
	############################################################################

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		### Add backup script to crontab

		dna-add_cron_job -n ${proj_name}-backup -t "8 4 * * *" -c "bash /root/openspace42/${proj_name}/tools/${proj_name}-backup"

		### Add create_push_certs script to crontab for monthly LE autorenewal and distribution to other nodes

		dna-add_cron_job -n ${proj_name}-backup -t "8 4 2 * *" -c "bash /root/openspace42/${proj_name}/tools/${proj_name}-create_push_certs"

		### Register ejabberd admin user

		dna-echo -m "Now registering ejabberd admin user [if it doesn't yet exist]..."
		ejab_admin_pw="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)"
		/usr/sbin/ejabberdctl register admin "$domain" "$ejab_admin_pw" &> /dev/null || true
		dna-echo -s "Finished registering ejabberd admin user."

		if [ -f "${conf_xmpp_dir}/ejabberd_admin_password_set" ]
		then
            dna-ask_for_boolean -d "y" -q "Leave ejabberd admin user password the same as previously set?"
            if [ "${boolean_output}" = "y" ]
            then
		        dna-echo -m "Ok, skipping ejabberd admin user password reset."
		        ejab_admin_pwreset="n"
		    else
		        dna-echo -m "Ok, resetting ejabberd admin user password to: | ${y-}${ejab_admin_pw}${n-} |."
		        /usr/sbin/ejabberdctl change_password admin "${domain}" "${ejab_admin_pw}"
		        ejab_admin_pwreset="y"
		    fi
		else
		    touch "${conf_xmpp_dir}/ejabberd_admin_password_set"
		    ejab_admin_pwreset="y"
		fi

		### Update ejabberd's module repo

		dna-echo -m "Now updating ejabberd's module repo..."
		set +e
		/usr/sbin/ejabberdctl modules_update_specs
		set -e
		dna-echo -s "Finished updating ejabberd's module repo..."

		### Create shared roster groups

		dna-echo -m "Now creating 'ADMIN:EVERYBODY' and 'ADMIN:ONLINE' shared roster groups [admin@${domain} can see 'everybody' and 'all online']..."
		/usr/sbin/ejabberdctl srg_create everybody "$domain" "everybody [$domain]" "This aenigma group includes every user on this domain" ""
		/usr/sbin/ejabberdctl srg-user-add @all@ localhost everybody "$domain"
		/usr/sbin/ejabberdctl srg_create online "$domain" "online [$domain]" "This aenigma group includes every user who is online on this domain" ""
		/usr/sbin/ejabberdctl srg-user-add @online@ localhost online "$domain"
		/usr/sbin/ejabberdctl srg_create admin "$domain" admin "This is a shared roster group set by aenigma" "everybody\\nonline"
		/usr/sbin/ejabberdctl srg-user-add admin "$domain" admin "$domain"
		dna-echo -s "Finished creating shared roster groups."

	fi

	############################################################################
	############################################################################

	### Run some generic operations to catch services status output and alert the user if something has gone wrong.

	declare -A service_checker_array=(
			[APT]="apt-get -y upgrade"
			[NGINX]="/usr/sbin/service nginx restart"
			[SSLH]="/usr/sbin/service sslh restart"
		)

	add_service_check_bottom_spacing() {

		if [ "${service}" = "APT" ]
		then
			echo
		fi

	}

	for service in "${!service_checker_array[@]}"
	do

		set +e

		if ${service_checker_array[$service]}
		then
			add_service_check_bottom_spacing
			dna-echo -s "All | ${n-}${service}${g-} | operations completed successfully."
		else
			add_service_check_bottom_spacing
			dna-echo -e "An error has occured during | ${n-}${service}${r-} | operations."
			dna-echo -m "This was one of the last steps in this installation, so it's possible that your end result is at least partially working."
			dna-echo -m "Review the output above and try running the installation again."
			dna-press_to_continue
		fi

		set -e

	done

	############################################################################
	############################################################################

	if [ ! "${cluster_mode-}" = "secondary" ]
	then

		### Pring login information and credentials

		dna-echo -s "You can finally log in to your web administration panel:"
		dna-echo -m " | ${y-}https://${hostname}${n-} | "
		dna-echo -m " | ${y-}admin@${domain}${n-} | "

		if [ "${ejab_admin_pwreset}" = "y" ]
		then
		    dna-echo -m " | ${y-}${ejab_admin_pw}${n-} | "
		else
		    dna-echo -m " | ${y-}[your previously set password]${n-} | "
		fi

		dna-press_to_continue

		if [ "${cluster_enabled-}" = "cluster" ]
		then

			dna-echo -m "It's now time to run the | ${o-}clusterize${n-} | script to start adding [or updating] your secondary nodes."
            dna-ask_for_boolean -d "y" -q "Are you ready to do so now [definitely proceed if you've just updated]?"
            if [ "${boolean_output}" = "y" ]
            then

				dna-echo -n -m "Ok, running the | ${o-}clusterize${n-} | script now..."
				bash "${tools_dir}/${proj_name}-clusterize"

				while [ ! "${exit_clusterization_loop-}" = "y" ]
				do

					dna-ask_for_boolean -d "y" -q "Would you like to clusterize another node now?"
					if [ "${boolean_output}" = "y" ]
					then

						dna-echo -n -m "Ok, running the | ${o-}clusterize${n-} | script again now..."
						bash "${tools_dir}/${proj_name}-clusterize"

					else

						dna-echo -m "Ok, exiting clusterization phase."
						exit_clusterization_loop="y"

					fi

				done

			else

				dna-echo -m "Ok, you can run the | ${o-}clusterize${n-} | script at any time by executing:"
				dna-echo -m " | ${y-}bash ${tools_dir}/${proj_name}-clusterize${n-} | "
				read -rp "${b-}[press enter to continue reading...]${x-}"
				echo

			fi

		fi

	else

		########################################################################

		dna-echo -m "Now joining ejabberd cluster by connecting to the primary node..."

		if /usr/sbin/ejabberdctl --no-timeout join_cluster "ejabberd@ae01.${domain}"
		then
			dna-echo -s "The ejabberd cluster was successfully joined!"
		else
			dna-echo -e "The ejabberd cluster join operation failed."
			dna-echo -m "Inspect the | ${y-}/var/log/ejabberd/error.log${n-} | logfile for more information."
			dna-exit
		fi

		########################################################################

	fi

	############################################################################
	############################################################################

	### Provision Tor

	dna-echo -m "aenigma can also provision a Tor hidden service on this machine to make it reachable entirely inside the Tor network."
	dna-echo -m "You will be able to connect to the | ${o-}.onion${n-} | address that will be generated to access all services [XMPP, web, SSH, etc...]"

	dna-ask_for_boolean -d "y" -q "Would you like to provision Tor now?"

	if [ "${boolean_output}" = "y" ]
	then
		aenigma-provision_tor
	fi

	############################################################################

	### Provision Converse.js

	dna-echo -m "aenigma can also provision a Converse.js instance on this machine to allow you and this instance's users to have your own XMPP web client always available from anywhere."
	dna-echo -m "You will be able to connect to it at | ${o-}https://${hostname}/xmpp/${n-} | from any device."
	dna-echo -m "This operation will take about 5 minutes to complete."

	dna-ask_for_boolean -d "y" -q "Would you like to provision Converse.js now?"

	if [ "${boolean_output}" = "y" ]
	then
		aenigma-provision_conversejs
	fi

	############################################################################
	############################################################################

	### Generate aenigma-specific DHparam file

	dna-generate_dhparam

	### If DHparam file was found or generated, amend the config file to include them:

	if [ "${dh_param_status}" = "ok" ]
	then

		if grep -q "### dhfile" "/etc/ejabberd/ejabberd.yml"
		then

			sed -i "s|### dhfile: 'DHFILE'|dhfile: 'DHFILE'|g" "/etc/ejabberd/ejabberd.yml"
			sed -i "s|### s2s_dhfile: 'DHFILE'|s2s_dhfile: 'DHFILE'|g" "/etc/ejabberd/ejabberd.yml"

			dna-echo -m "Now restarting ejabberd..."

			service ejabberd restart

		fi

	fi

	############################################################################

	dna-remove_tmp_project_dir

	############################################################################
	############################################################################
	############################################################################

}

################################################################################
