#!/usr/bin/env bash

### openspace synthia bootstrap framework v0.2.1 [https://github.com/openspace42/synthia]

os_dna_version=0.2.6

################################################################################

define_vars() {

	############################################################################
	#################### Insert your initial variables here ####################
	############################################################################

	proj_name="aenigma"
	short_name="aenigma"
	author_name="openspace42"
	git_host="https://github.com/"

	### Set this to `y` if your project stores no data on end users' machines that could go lost during a re-install or update
	skip_install_time_backup=n

	### Set this to the directory that has the most impactful size when performing a backup [such as `/var/www/` for nginx-related projects]
	backup_ref_dir="/var/lib/ejabberd"

	############################################################################
	############################################################################
	############################################################################

	### Do NOT edit the following line

	dna-define_vars

	############################################################################
	################## Insert your additional variables here ###################
	############################################################################

	### Set the paths to the cluster / nodes conf dirs

	conf_cluster_dir="${conf_dir}/cluster"
	conf_cluster_nodes_dir="${conf_cluster_dir}/nodes"

	conf_xmpp_dir="${conf_dir}/xmpp"

	### Set the paths to the nodes_db files

	nodes_db_ipv4_path="${conf_cluster_nodes_dir}/nodes_db_ipv4"
	nodes_db_ipv6_path="${conf_cluster_nodes_dir}/nodes_db_ipv6"
	nodes_db_numbered_path="${conf_cluster_nodes_dir}/nodes_db_numbered"
	nodes_db_online_path="${temp_dir}/nodes_db_online"

	############################################################################
	############################################################################
	############################################################################

}

################################################################################

check_root() {

	if [[ $EUID -ne 0 ]]
	then
		echo "This script must be run as root."
		echo
		echo "Exiting..."
		echo
		exit 1
	fi

}

download_os_dna() {

	clone_host="https://github.com"
	clone_author="openspace42"
	clone_name="dna"

	clone_base_dir=/root/$clone_author
	clone_dir=$clone_base_dir/$clone_name

	mkdir -p $clone_base_dir

	if [ -d $clone_dir ]
	then
		rm -r ${clone_dir:?}
	fi

	( cd "$clone_base_dir" && git clone "$clone_host/$clone_author/$clone_name" && cd "$clone_name" && \
		if [ ! "${custom_dna_version-null}" = "b" ]; \
		then \
			git checkout "tags/v$os_dna_version" && \
			echo "$os_dna_version" > "./version_installed"; \
		else \
			clone_latest_commit="$(git log -n 1 --pretty=format:"%H"  | cut -c1-7)" && \
			echo "bleeding-edge-$clone_latest_commit" > "./version_installed"; \
		fi &> /dev/null \
	)

}

source_os_dna() {

	for f in /root/openspace42/dna/functions/*
	do
		. $f
	done

}

################################################################################

################################################################################
######################## Insert project functions here #########################
################################################################################

aenigma-display_logo() {

	### Determine terminal window size

	columns_number="$(tput cols)"
	rows_number="$(tput lines)"

	### Check that the terminal window is large enough to display the logo

	if [ "${columns_number}" -ge "93" ] && [ "${rows_number}" -ge "24" ]
	then

	    ### Determine terminal window center

	    columns_median="$(echo $((columns_number / 2)))"

	    ### The aenigma logo is 45 pixels and therefore 90 columns wide, therefore...

	    base_column="$(echo $((columns_median - 45)))"

	    ### Set colors

	    b=$'\e[38;5;16m'
	    w=$'\e[38;5;15m'

	    l=$'\e[38;5;33m'

	    x=$'\e[0m'
	    z=$'\e[8m'

	    ### Set white base for all lines
	    set p02{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p03{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p04{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p05{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p06{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p07{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p08{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p09{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p10{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p11{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p12{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p13{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p14{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p15{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p16{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item
	    set p17{01..45} && array="$@" && for item in $array; do eval $item='$w'; done && unset array item

	    ### Line 03

	    eval p0319='$b'

	    ### Line 06

	    eval p06{03..09}='$l'
	    eval p06{11..17}='$b'
	    eval p0619='$b'
	    eval p06{21..27}='$b'
	    eval p06{29..35}='$b'
	    eval p06{38..43}='$b'

	    ### Lines {07..08}

	    eval p{07..08}06='$l'
	    eval p{07..08}09='$l'
	    eval p{07..08}11='$b'
	    eval p{07..08}17='$b'
	    eval p{07..08}19='$b'
	    eval p{07..08}21='$b'
	    eval p{07..08}27='$b'
	    eval p{07..08}29='$b'
	    eval p{07..08}32='$b'
	    eval p{07..08}35='$b'
	    eval p{07..08}43='$b'

	    ### Line 09

	    eval p09{03..09}='$l'
	    eval p0911='$b'
	    eval p0917='$b'
	    eval p0919='$b'
	    eval p0921='$b'
	    eval p0927='$b'
	    eval p0929='$b'
	    eval p0932='$b'
	    eval p0935='$b'
	    eval p09{37..43}='$b'

	    ### Lines {10..11}

	    eval p{10..11}03='$l'
	    eval p{10..11}06='$l'
	    eval p{10..11}11='$b'
	    eval p{10..11}17='$b'
	    eval p{10..11}19='$b'
	    eval p{10..11}21='$b'
	    eval p{10..11}27='$b'
	    eval p{10..11}29='$b'
	    eval p{10..11}32='$b'
	    eval p{10..11}35='$b'
	    eval p{10..11}37='$b'
	    eval p{10..11}43='$b'

	    ### Line 12

	    eval p12{03..09}='$l'
	    eval p1211='$b'
	    eval p1217='$b'
	    eval p1219='$b'
	    eval p12{21..27}='$b'
	    eval p1229='$b'
	    eval p1232='$b'
	    eval p1235='$b'
	    eval p12{37..43}='$b'

	    ### Lines {13..14}

	    eval p{13..14}27='$b'

	    ### Line 15

	    eval p15{22..27}='$b'

	    ### Set borders

	    set p01{01..45} && array="$@" && for item in $array; do eval $item='$b'; done && unset array item
	    set p17{01..45} && array="$@" && for item in $array; do eval $item='$b'; done && unset array item
	    eval p{01..17}01='$b'
	    eval p{01..17}45='$b'

	    ### Print

	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p01{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p02{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p03{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p04{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p05{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p06{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p07{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p08{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p09{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p10{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p11{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p12{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p13{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p14{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p15{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p16{01..45}██ | tr -d ' ')"
	    echo "$(eval $(echo printf '" %0.s"' {1..$base_column}))${x}$(echo $p17{01..45}██ | tr -d ' ')"

	    echo ${x}

		unset b w l x z

		dna-define_formatting

	fi

}

aenigma-xmpp_intro() {

	echo "0] First of all, a little introduction on how XMPP actually works"
	echo
	echo "XMPP works a little bit like email. You can have a domain [amsterdamhacklab.xyz] and receive email for that domain on a server located at mx01.amsterdamhacklab.xyz, by using the appropriate DNS configuration, and also have other servers [webserver, mapserver, etc...] on other subdomains. In that case, a DNS MX record tells sending servers to direct mail intended for amsterdamhacklab.xyz to mx01.amsterdamhacklab.xyz."
	echo
	echo "In the same way, the XMPP server for amsterdamhacklab.xyz can be located at xmpp.amsterdamhacklab.xyz and a DNS SRV record tells any sending servers that XMPP for that domain [i.e. a message directed to mark@amsterdamhacklab.xyz] is handled by the server located at xmpp.amsterdamhacklab.xyz."
	echo
	read -rp "${b-}[press enter to continue reading...]${x-}"
	clear

	echo "1] Now, if the domain for which you're setting up your new aenigma server is a domain connected to a bigger project, for which XMPP is just another way of getting in touch with you, definitely set things up like this by using the first option."
	echo
	echo "This will give you working @domain.tld xmpp account addresses, but the aenigma server will reside at subdomain.domain.tld, as in the following example."
	echo
	echo "Main domain:          amsterdamhacklab.xyz."
	echo "Website:              amsterdamhacklab.xyz / www.amsterdamhacklab.xyz [hosted by another server]."
	echo "Your XMPP address:    mark@amsterdamhacklab.xyz."
	echo "XMPP server:          xmpp.amsterdamhacklab.xyz"
	echo
	echo "PROs:                 a] clean addresses [no mark@xmpp.amsterdamhacklab.xyz stuff]"
	echo "                      b] more logical setup."
	echo "CONs:                 a] requires TLS [SSL] certificate for the top level domain [amsterdamhacklab.xyz]"
	echo "                         to be copied over to your new aenigma server [not hard at all, can be automated, see below]"
	echo
	read -rp "${b-}[press enter to continue reading...]${x-}"
	clear

	echo "2] If instead your domain [i.e. aenigmapod42.im] is only intended to be used for your shiny new aenigma server, and you don't need other, different servers [a webserver for instance] managing different aspects of your project, you can do as so:"
	echo
	echo "Set your aenigma server to be located directly at your top level domain, therefore responding directly to amsterdamhacklab.xyz."
	echo
	echo "Your server hostname:  aenigmapod42.im"
	echo "Your addresses:        mark@aenigmapod42.im."
	echo
	echo "PROs:                  a] clean addresses"
	echo "                       b] no separate TLS certificate needed."
	echo "CONs:                  a] your domain must be logically dedicated to your aenigma server"
	echo "                          and not to a wider project."
	echo
	read -rp "${b-}[press enter to continue reading...]${x-}"
	clear

	echo "3] In a third, although NOT suggested case, if you have a domain tied to a wider project [i.e. amsterdamhacklab.xyz] but you don't mind having longer and more complex XMPP account addresses [like mark@xmpp.amsterdamhacklab.xyz], you can choose the third option."
	echo
	echo "Your server hostname:  subdomain.domain.tld"
	echo "Your addresses:        mark@subdomain.domain.tld."
	echo
	echo "PROs:                  a] domain can be logically connected to other stuff and different servers"
	echo "                          with no separate TLS certificate needed."
	echo "CONs:                  a] longer and more complex addresses"
	echo "                       b] not logically 'clean'."
	echo
	read -rp "${b-}[press enter to continue reading...]${x-}"
	clear

	echo "Now that you know how XMPP works, make your choice and let's get your brand new aenigma server up and running!"
	echo
	echo "----------------"
	echo

}

aenigma-install_sslh() {

	### Install SSLH

	dna-echo -m "Now installing SSLH..."
	/usr/sbin/service sslh stop &> /dev/null || true
	ssh_port="$(cat $os_base_dir/inception/ssh-port)"
	apt-get -y install libwrap0-dev libconfig-dev || true
	rm -r "$temp_dir/sslh" &> /dev/null || true
	git clone https://github.com/yrutschle/sslh "$temp_dir/sslh"
	( cd "$temp_dir/sslh" && make install && make && cp sslh-select /usr/local/sbin/sslh )
	sed -i "s|this_ipv4-var|${this_ipv4}|g" $source_dir/conf/sslh/etc-sslh.cfg
	if [ $ipv6_available = "y" ]
	then
		sed -i "s|#ipv6_comma|,|g" $source_dir/conf/sslh/etc-sslh.cfg
		sed -i "s|#ipv6_line||g" $source_dir/conf/sslh/etc-sslh.cfg
		sed -i "s|this_ipv6-var|${this_ipv6}|g" $source_dir/conf/sslh/etc-sslh.cfg
	else
		sed -i "s|#ipv6_comma||g" $source_dir/conf/sslh/etc-sslh.cfg
		sed -i "s|#ipv6_line|#|g" $source_dir/conf/sslh/etc-sslh.cfg
	fi
	sed -i "s|domain-var|${domain}|g" $source_dir/conf/sslh/etc-sslh.cfg
	sed -i "s|ssh_port-var|${ssh_port}|g" $source_dir/conf/sslh/etc-sslh.cfg
	sed -i "s|xu.@|xu${node_number}.@|g" $source_dir/conf/sslh/etc-sslh.cfg
	cp $source_dir/conf/sslh/etc-sslh.cfg /etc/sslh.cfg
	cp $source_dir/conf/sslh/etc-init.d.sslh /etc/init.d/sslh
	chmod +x /etc/init.d/sslh
	update-rc.d sslh defaults
	systemctl daemon-reload
	rm -r "$temp_dir/sslh"
	mkdir -p /var/run/sslh
	touch /var/run/sslh/sslh.pid
	service sslh restart || true
	echo
	dna-echo -m "${g-}Finished installing SSLH."

}

aenigma-add_ejabberd_repo() {

	currdistro="$(lsb_release --codename | cut -f2)"
	apt-get -y install apt-transport-https || true
	echo "deb https://apt.jabber.at $currdistro ejabberd" > /etc/apt/sources.list.d/jabber.at.list
	wget -qO- https://apt.jabber.at/gpg-key | apt-key add -
	apt-get update
	echo

}

aenigma-get_ejabberd_candidate_version() {

	ejabberd_candidate_version="$(apt-cache show ejabberd | grep Version | head -1 | sed "s|Version: ||" | cut -d ':' -f 2 | cut -f1 -d'-')"

}

aenigma-get_ejabberd_installed_version() {

	if dpkg -s ejabberd &> /dev/null
	then
		ejabberd_installed_version="$(dpkg -s ejabberd | grep '^Version:' | sed "s|Version: ||" | cut -d ':' -f 2 | cut -f1 -d'-')"
	else
		ejabberd_installed_version=none
	fi

}

aenigma-install_ejabberd_config() {

	dna-echo -m "Now creating ejabberd directory and setting custom aenigma config..."

	aenigma-get_ejabberd_candidate_version

	source_ejab_conf_file="$source_dir/conf/ejabberd/ejabberd-$ejabberd_candidate_version.yml"

	if [ ! -f $source_ejab_conf_file ]
	then
		### Fallback to ejabberd.yml for v18.06 in case the ejabberd candidate install version isn't among the ones we have config files for
		source_ejab_conf_file="$source_dir/conf/ejabberd/ejabberd-18.06.yml"
	fi

	mkdir -p /etc/ejabberd/
	cp "$source_ejab_conf_file" "/etc/ejabberd/ejabberd.yml"
	sed -i "s/domain.xyz/${domain}/g" "/etc/ejabberd/ejabberd.yml"
	sed -i "s/hostname.xyz/${hostname}/g" "/etc/ejabberd/ejabberd.yml"

	dna-echo -s "Finished creating ejabberd directory and setting custom aenigma config."

}

aenigma-set_permissions() {

	dna-echo -m "Now setting permissions..."

	### /var/lib/ejabberd/

	if id "ejabberd" >/dev/null 2>&1
	then
		chown -R "ejabberd:ejabberd" "/var/lib/ejabberd/uploads/"
		chmod 2750 "/var/lib/ejabberd/uploads/"
		if [ -f "/var/lib/ejabberd/.erlang.cookie" ]
		then
			chown "ejabberd:ejabberd" "/var/lib/ejabberd/.erlang.cookie"
		fi
	fi

	### /var/www/ejabberd

	if id "ejabberd" >/dev/null 2>&1
	then
		chown -R "ejabberd:ejabberd" "/var/www/ejabberd/"
		chmod -R 755 "/var/www/ejabberd/"
	fi

	### /var/log/ejabberd

	if id "ejabberd" >/dev/null 2>&1
	then
		chown -R "ejabberd:adm" "/var/log/ejabberd/"
		chmod -R 755 "/var/log/ejabberd/"
	fi

	### $tls_dir

	if id "ejabberd" >/dev/null 2>&1
	then
		chown -R "ejabberd:ejabberd" "${tls_dir}"
		chmod -R 700 "${tls_dir}"
	fi

	### ~/.ssh/

	chown "root:root" "/root/.ssh/authorized_keys" 2> /dev/null || true
	chmod 755 "/root/.ssh/" 2> /dev/null || true
	chmod 600 "/root/.ssh/authorized_keys" 2> /dev/null || true

	dna-echo -m "${g-}Finished setting permissions."

}

aenigma-create_ejabberd_locations() {

	### Create ejabberd uploads directory

	dna-echo -m "Now creating uploads directory..."
	mkdir -p "/var/lib/ejabberd/uploads/"
	dna-echo -m "${g-}Finished creating uploads directory."

	### Create HTTP uploads directory

	dna-echo -m "Now creating HTTP fileserver directory..."
	mkdir -p "/var/www/ejabberd/"
	dna-echo -m "${g-}Finished creating HTTP fileserver directory."

	### Create logfile

	dna-echo -m "Now creating logfile..."
	mkdir -p "/var/log/ejabberd/"
	touch "/var/log/ejabberd/www_access.log"
	dna-echo -m "${g-}Finished creating logfile."

	### Set permissions

	aenigma-set_permissions

}

aenigma-install_ejabberd() {

	### Ensure DPKG is available before proceeding.

	dna-check_dpkg_availability

	### Inhibit ejabberd from starting after install as permissions won't be already correct

	echo exit 101 > "/usr/sbin/policy-rc.d"
	chmod +x "/usr/sbin/policy-rc.d"

	### Proceed

	dna-echo -m "Now installing ejabberd..."

	export DEBIAN_FRONTEND=noninteractive ; apt-get install -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --force-yes ejabberd || true
	echo

	### Remove autostart inhibition

	rm "/usr/sbin/policy-rc.d"

	dna-echo -s "Finished installing ejabberd."
}

aenigma-create_nodes_db_numbered() {

	### Create a node-numbered version of "nodes_db"

	if [ -f "${nodes_db_numbered_path}" ]
	then
		rm "${nodes_db_numbered_path}"
		touch "${nodes_db_numbered_path}"
	fi

	array_iter=1
	IFS=$'\n'
	set -f
	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
	do
		array_iter_padded="$(echo ${array_iter} | xargs printf %02d)"
		echo -e "${node_ipv4}\tae${array_iter_padded}.${domain}" >> "${nodes_db_numbered_path}"
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4

}

aenigma-initialize_nodes_db_files() {

	mkdir -p "${conf_cluster_nodes_dir}"

	dna-get_public_ipv4 -s

	dna-check_ipv6_connectivity -s

	### IPv4

	touch "${nodes_db_ipv4_path}"

	if [ -s "${nodes_db_ipv4_path}" ]
	then
		### File is not empty, alter first line.
		sed -i "1s/.*/${this_ipv4}/" "${nodes_db_ipv4_path}"
	else
		### File is empty, write to it.
		echo "${this_ipv4}" > "${nodes_db_ipv4_path}"
	fi

	### IPv6

	touch "${nodes_db_ipv6_path}"

	if [ -s "${nodes_db_ipv6_path}" ]
	then

		### File is not empty, alter first line.

		if [ "${ipv6_available}" = "y" ]
		then
			sed -i "1s/.*/${this_ipv6}/" "${nodes_db_ipv6_path}"
		else
			sed -i "1s/.*/null/" "${nodes_db_ipv6_path}"
		fi

	else

		### File is empty, write to it.

		if [ "${ipv6_available}" = "y" ]
		then
			echo "${this_ipv6}" > "${nodes_db_ipv6_path}"
		else
			echo "null" > "${nodes_db_ipv6_path}"
		fi

	fi

	aenigma-create_nodes_db_numbered

}

aenigma-update_routing_info() {

	### Set UFW rules on this node according to the updated nodes_db

	array_iter=1
	IFS=$'\n'
	set -f
	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
	do
		/usr/sbin/ufw insert "${array_iter}" allow from "$node_ipv4"
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4 array_iter
	echo

	### Import nodes_db to /etc/hosts to provide ejabberd with a locally resolved list of nodes to cluster with

	if ! grep -q "### aenigma nodes list start" /etc/hosts
	then
		echo >> /etc/hosts
		echo "### aenigma nodes list start" >> /etc/hosts
	fi

	if ! grep -Pzoq '### aenigma nodes list start(?:.*\n)*?\K### aenigma nodes list end' /etc/hosts
	then
		echo "### aenigma nodes list end" >> /etc/hosts
	fi

	sed -i '/### aenigma nodes list start/,/### aenigma nodes list end/{//!d}' /etc/hosts
	sed -i "/### aenigma nodes list start/ r ${nodes_db_numbered_path}" /etc/hosts

}

aenigma-create_nodes_db_online() {

	### This function will always get invoked at the beginning push_routing_info() in the later event that an existing node cannot be reached at the time of running a new clusterization.
	### It will create a copy of nodes_db_ipv4 and nodes that appear to be offline will be removed fromit, for use by subsequent functions, until the end of the clusterize script.

	mkdir -p "${temp_dir}"

	if [ -f "${nodes_db_online_path}" ]
	then
		rm "${nodes_db_online_path}"
		touch "${nodes_db_online_path}"
	fi

	cp "${nodes_db_ipv4_path}" "${nodes_db_online_path}"

}

aenigma-push_routing_info() {

	############################################################################

	### Push nodes_db files to all secondary nodes for /etc/hosts and ufw rules configuration
	### At the same time, check to see if any existing secondary nodes are offline, and, if so, remove them from nodes_db_online

	aenigma-create_nodes_db_online

	array_iter=1
	IFS=$'\n'
	set -f

	for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
	do
		node_number="$(echo ${array_iter} | xargs printf %02d)"
		### Ensure we don't try connecting to ourselves [therefore ignoring the first line of nodes_db_ipv4].
		if [ ! "${node_ipv4}" = "${this_ipv4}" ]
		then
			if ! /usr/bin/scp -P42022 -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i /root/.ssh/aenigma_cluster -r "${conf_cluster_nodes_dir}" "root@${node_ipv4}:${conf_cluster_dir}"
			then
				echo
				dna-echo -e "Existing node number | ${n-}${node_number}${r-} | is not responding at IPv4 address | ${n-}${node_ipv4}${r-} |."
				dna-echo -m "It is NOT reccommended to continue the installation as the node in question will not be informed of the new node we're setting up right now."
				dna-echo -m "However, you can continue runing the installation now and run the | ${o-}push_routing_info${n-} | script at at a later time by executing:"
				dna-echo -m " | ${y-}bash ${tools_dir}/${short_name}-push_routing_info${n-} | "
				ask_for_boolean_question="Continue with installation anyway?"
	            dna-ask_for_boolean_def_yes
	            if [ "$ask_for_boolean_output" = "y" ]
	            then
					dna-echo -m "Ok, continuing..."
					### Remove node from nodes_db_online
					sed -i "/^${node_ipv4}$/d" "${nodes_db_online_path}"
				else
					dna-echo -m "Ok, aborting installation..."
					dna-exit
				fi
			fi
		fi
		array_iter=$((array_iter + 1))
	done
	unset node_ipv4

	############################################################################

	aenigma-exec() {

		### Define the commands that will be passed to the aenigma-exec script on the remote machine to be run, one per line between the quotes.

        bash openspace42/aenigma/tools/aenigma-exec -c "
aenigma-update_routing_info
"

	}

	############################################################################

	for online_node_ipv4 in $(cat < "${nodes_db_online_path}")
	do
		### Ensure we don't try connecting to ourselves [therefore ignoring the first line of nodes_db_ipv4].
		if [ ! "${online_node_ipv4}" = "${this_ipv4}" ]
		then
			### SSH into the secondary node, declare the aenigma-exec function, and run it inside of the subshell.
	        ssh -tt -p42022 -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@${online_node_ipv4}" "$(declare -f aenigma-exec); export -f aenigma-exec; exec bash -li" <<END
set -eu
aenigma-exec
exit
END
		fi
		echo
	done
	unset online_node_ipv4

	############################################################################

}

aenigma-perform_dns_checks() {

	### Perform DNS checks. They must only be run by the primary node.

	############################################################################

	if [ "${cluster_enabled-null}" = "cluster" ]
	then

		dna-echo -m "Performing DNS checks for the following nodes:"
		dna-echo -m "${y-}$(cat ${nodes_db_numbered_path})"

	fi

	############################################################################

	### Perform checks in both IPv4 and IPv6. If this node [or a node in case of a cluster] doesn't have IPv6 connectivity its IPv6 check will be ignored locally.

	declare -a ip_version_array=(
		"4"
		"6"
	)

	aenigma-calculate_ip_version_vars() {

		if [ "${ip_version}" = "4" ]
		then
			nodes_db_path="${nodes_db_ipv4_path}"
			address_type="a"
		elif [ "${ip_version}" = "6" ]
		then
			nodes_db_path="${nodes_db_ipv6_path}"
			address_type="aaaa"
		fi

	}

	############################################################################

	### Check hostnames.

	for ip_version in "${ip_version_array[@]}"
	do

		aenigma-calculate_ip_version_vars

		array_iter=1
		IFS=$'\n'
		set -f

		for node_ip in $(cat < "${nodes_db_path}")
		do

			node_number="$(echo ${array_iter} | xargs printf %02d)"
			dna-check_dns_record -n "ae${node_number}.${domain}" -t "${address_type}" -r "${node_ip}"
			array_iter=$((array_iter + 1))

		done

		unset array_iter

	done

	############################################################################

	### Now check that "ae.$domain" points to all nodes in a round-robin fashion.

	for ip_version in "${ip_version_array[@]}"
	do

		aenigma-calculate_ip_version_vars

		dna-check_dns_record -n "ae.${domain}" -t "${address_type}" -r "${nodes_db_path}"

	done

	############################################################################

	### Check XMPP services records

	### First check services that need to point to each node respectively

	for ip_version in "${ip_version_array[@]}"
	do

		aenigma-calculate_ip_version_vars

		array_iter=1
		IFS=$'\n'
		set -f

		for node_ip in $(cat < "${nodes_db_path}")
		do

			node_number="$(echo ${array_iter} | xargs printf %02d)"

			declare -a xmpp_service_array=(
				"xe"
				"xm"
				"xp"
				"xu"
			)

			for xmpp_service in "${xmpp_service_array[@]}"
			do

				dna-check_dns_record -n "${xmpp_service}${node_number}.${domain}" -t "${address_type}" -r "${node_ip}"

			done

			array_iter=$((array_iter + 1))

		done

		unset array_iter

	done

	### Then check "xc.$domain" as it should not be a set of numbered records [xc01, xc02...] but instead be only one record pointing to all nodes in a round-robin fashion

	for ip_version in "${ip_version_array[@]}"
	do

		aenigma-calculate_ip_version_vars

		dna-check_dns_record -n "xc.${domain}" -t "${address_type}" -r "${nodes_db_path}"

	done

	############################################################################

	### Check SRV records

	dna-check_dns_record -n "_xmpp-client._tcp.${domain}" -t "srv" -r "0 0 5222 ae.${domain}."

	declare -a srv_record_array=(
		"_jabber._tcp"
		"_xmpp-server._tcp"
	)

	for srv_record in "${srv_record_array[@]}"
	do

		dna-check_dns_record -n "${srv_record}.${domain}" -t "srv" -r "0 0 5269 ae.${domain}."

	done

	############################################################################

	unset dns_checks_outcome

}

backup_locally_loop() {

	if [ "${cluster_mode-null}" = "secondary" ]
	then
		echo "${r-}${b-}The backup script is only intended to run on the primary node.${x-}"
		echo
		echo "${b-}The primary node will take care of backing up the ejabberd uploads directory of the secondary nodes. No further backup is required on secondary nodes.${x-}"
		echo
		dna-exit
	fi

	cp -r "${conf_dir}" "${tmp_backup_dir}"/conf/
	mkdir -p "${tmp_backup_dir}"/data/
	/usr/sbin/ejabberdctl backup ejabberd-mnesia-backup
	mv /var/lib/ejabberd/ejabberd-mnesia-backup "${tmp_backup_dir}"/data/ejabberd-mnesia-backup
	cp -r /etc/ejabberd/ "${tmp_backup_dir}"/data/etc-ejabberd/
	cp -r /var/lib/ejabberd/ "${tmp_backup_dir}"/data/var-lib-ejabberd/

	if [ "${cluster_enabled}" = "y" ]
	then
		for node_ipv4 in $(cat < "${nodes_db_ipv4_path}")
		do
			### Ensure we don't try connecting to ourselves [therefore ignoring the first line of nodes_db_ipv4].
			if [ ! "${node_ipv4}" = "${this_ipv4}" ]
			then
				mkdir -p "${tmp_backup_dir}"/data/${node_ipv4}/"
				/usr/bin/scp -P42022 -o "LogLevel=ERROR" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i "/root/.ssh/aenigma_cluster" "root@ae${node_ipv4}:/var/lib/ejabberd/uploads/" "${tmp_backup_dir}"/data/${node_ipv4}/"
			fi
		done
		unset node_ipv4
	fi

}

restore_loop() {

	echo "${b-}1] Now restoring aenigma config directory...${x-}"
	echo

	rsync -aAXx --delete $restore_file_path/conf/ $conf_dir/

	echo "${b-}2] Now restoring ejabberd database...${x-}"
	echo

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
	        echo "${g-}${b-}ejabberd is already running. Continuing...${x-}"
	        echo
	else
	        echo "${r-}${b-}ejabberd NOT running. Starting it now...${x-}"
	        echo
	        echo "${b-}Now starting ejabberd ...${x-}"
	        /usr/sbin/service ejabberd start
	        echo
	        dna-wait -s "8" -d "Now allowing ejabberd to start up correctly..."
	        /usr/sbin/ejabberdctl
	        echo
	        sleep 1
	fi

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
	        cd $restore_file_path/data/
		cp ./ejabberd-mnesia-backup /var/lib/ejabberd/
	        /usr/sbin/ejabberdctl restore ejabberd-mnesia-backup
		rm /var/lib/ejabberd/ejabberd-mnesia-backup
	        echo "${b-}Successfully restored ejabberd database...${x-}"
	        echo
	        dna-wait -s "8" -d "Now allowing ejabberd sync the database..."
	else
	        echo "${r-}${b-}ERROR: ejabberd STILL NOT running. Unable to restore database from backup.${x-}"
	        echo
	        dna-exit
	fi

	echo "${b-}Now restoring ejabberd directories...${x-}"
	echo

	echo "${b-}Now stopping ejabberd for directory restore...${x-}"
	echo
	/usr/sbin/service ejabberd stop
	dna-wait -s "8" -d "Now allowing ejabberd to shut down correctly..."

	echo "${b-}3] Now syncing ejabberd directories...${x-}"
	echo

	rsync -aAXx --delete $restore_file_path/data/etc-ejabberd/ /etc/ejabberd/
	rsync -aAXx --delete $restore_file_path/data/var-lib-ejabberd/ /var/lib/ejabberd/

	aenigma-set_permissions

	echo "${b-}Now starting ejabberd...${x-}"
	/usr/sbin/service ejabberd start
	echo
	dna-wait -s "8" -d "Now allowing ejabberd to start up correctly..."
	/usr/sbin/ejabberdctl status
	echo
	sleep 1

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then

	        echo "${g-}${b-}Restore complete!${x-}"
	        echo
	        echo "${b-}Now please verify your aenigma instance is running correctly and has everything you except it to.${x-}"
	        echo

	        read -p "${b-}Has your previous instance of aenigma been restored correctly? (Y/n): ${x-}" -n 1 -r
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
	                echo "${g-}${b-}Ok, all done!${x-}"
	                echo
	                if [ -f $conf_dir/blocks3backups ]
	                then
				rm $conf_dir/blocks3backups
	                        echo "${b-}Removing S3 backups lock since your restore has been successful.${x-}"
	                        echo
	                        echo "${r-}${b-}This machine will now pick up where the old one left off and start backing up again to S3 and will overwrite all previous data stored on S3.${x-}"
	                        echo
	                        echo "${b-}If you've changed your mind and are NOT yet sure this restore was completely successful, simply:${x-}"
	                        echo
	                        echo "${b-} | touch $conf_dir/blocks3backups |"
	                        echo
	                        echo "${b-}And remember to remove it as soon as you're done verifying this restored instance to then resume backups to S3!${x-}"
	                        echo
	                        echo "${g-}${b-}All done for now.${x-}"
	                        echo
	                fi
	        else
	                echo
	                echo "${b-}Sorry about that, please collect all evidence you can find so and simply file an issue report at:${x-}"
	        	echo
	        	echo "${b-} | https://github.com/openspace42/aenigma/issues |${x-}"
	        	echo
	        	echo "${b-}Thank you in advance!${x-}"
	                echo
	        fi

	else

	        echo "${r-}${b-}ERROR: ejabberd not running after restore. Please check ejabberd directories.${x-}"
	        echo
	        echo "${b-}Please collect all evidence you can find so and simply file an issue report at:${x-}"
	        echo
	        echo "${b-} | https://github.com/openspace42/aenigma/issues |${x-}"
	        echo
	        echo "${b-}Thank you in advance!${x-}"
	        echo
	        echo "${b-}Exiting...${x-}"
	        echo
	        exit

	fi

	if [ -d "$restores_dir/local/" ]
	then
		rm -r "$restores_dir/local/"
	fi

	if [ -d "/root/${short_name}-restore/" ]
	then
		rm -r "/root/${short_name}-restore/"
	fi

	if [ -d "$tmpdir" ]
	then
		rm -r "${tmpdir:?}"
	fi

	if [ $bootstrapmode = "on" ]
	then
		echo "${b-}Now that we're finished with the initial restore, it's time to re-run the install script and get this machine up and running with your old instance's files and settings${x-}"
		echo
		echo "${b-}Running install script now.${x-}"
		echo
		echo "${r-}${b-}Should you exit the install script during its runtime, you can re-run it manually with:${x-}"
		echo
		echo "${b-} | bash $sourcedir/install.sh | ${x-}"
		cd
		bash $sourcedir/install.sh
	fi

}

################################################################################
################################################################################
################################################################################

perform_installation() {

	############################################################################
	################### Add your install-time functions here ###################
	############################################################################

	### Display aenigma logo

	aenigma-display_logo

	################################################################################

	dna-check_sslh_connection

	dna-check_distro_ubuntu_18

	dna-check_inception_run

	################################################################################

	### Copy files to destination

	rsync -aAXx "${source_dir}/" "${install_dir}/" --include=tools*** --include=functions --exclude="*"

	dna-echo -m $"${g-}Finished transferring files into installation directory."

	mkdir -p "${tls_dir}"

	mkdir -p "$temp_dir"

	################################################################################

	### Skip intro if requested by user

	if [ $skip_intro = "n" ]
	then
	    aenigma-xmpp_intro
	fi

	############################################################################

	### Ask user if this aenigma node is going to be part of a cluster

	describe_setting() {

		echo "${b-}${short_name} can be setup to run in a cluster of multiple servers, all working together to make your instance run smoothly, robustly, and be fault-tolerant and load-balancing.${x-}"
		echo
		echo "${b-}If you wish to setup ${short_name} in a cluster configuration, you must specify so now.${x-}"
		echo

	}

	validate_input() {

		case $input in
			single)		valid="y"
			;;
			cluster)	valid="y"
			;;
			*)	echo "${r-}${b-}Invalid setting for | ${n-}cluster_enabled${r-} | in function | ${n-}${FUNCNAME[0]}${r-} |.${x-}"
			echo
			valid="n"
			;;
		esac

	}

	dna-set_option -o "cluster_enabled" -p "cluster" -d y -c "[single/cluster]" -v y

	if [ "${cluster_enabled}" = "cluster" ]
	then

		describe_setting() {

			echo "${b-}Having chosen to run ${short_name} in a cluster of servers, you must now designate your master node that will be performing some special operations to lead the cluster.${x-}"
			echo

		}

		validate_input() {

			case $input in
				primary)		valid="y"
				;;
				secondary)		valid="y"
				;;
				*)	echo "${r-}${b-}Invalid setting for | ${n-}cluster_mode${r-} | in function | ${n-}${FUNCNAME[0]}${r-} |.${x-}"
				echo
				valid="n"
				;;
			esac

		}

		dna-set_option -o "cluster_mode" -p "cluster" -d y -c "[primary/secondary]" -v y

		if [ "${cluster_mode}" = "primary" ]
		then
			echo "${b-}Having chosen that this server will be your primary node for your ${short_name} installation, we can carry on with the standard installation.${x-}"
			echo
		else
			echo "${b-}Having chosen that this server will be a secondary node for your ${short_name} installation, we first need to make sure that there is an already running primary node that is already up and running and perfectly configured.${x-}"
			echo
			ask_for_boolean_question="Is the primary node for this ${short_name} already up and running and perfectly configured?"
            dna-ask_for_boolean_def_yes
            if [ "$ask_for_boolean_output" = "y" ]
            then
				echo "${b-}Ok, let's then continue on with the configuration of this secondary node and proceed to have it join the cluster lead by your already running primary node...${x-}"
				echo
            else
				echo "${b-}Ok, no problem. Please proceed with the full installation and configuration of your primary node on its respective server by following the same ${short_name} install and selecting the | primary | node option when prompted.${x-}"
				echo
				echo "${b-}Only then will we be able to continue with the installation of this secondary node.${x-}"
				echo
				echo "${b-}Aborting installation for now.${x-}"
				echo
                dna-exit
            fi
		fi
	fi

	############################################################################

	if [ ! "${cluster_mode-null}" = "secondary" ]
	then

		########################################################################

		### Start creating the nodes_db files and print this machine [the primary node]'s public IPv4 and IPv6 [if available] to the first line of each
		### We create the nodes_db file independently of whether clusterization is enabled or not.

		if [ "${cluster_enabled}" = "single" ]
		then

			### Clusterization has been turned off. Delete the conf_nodes directory if present.

			if [ -d "${conf_cluster_nodes_dir}" ]
			then
				rm -rf "${conf_cluster_nodes_dir}"
			fi

		fi

		########################################################################

		### Set xmpp domain

	    describe_setting() {

	        echo "${b-}Now specify your top level domain, which will become the part after the @ in your JIDs [XMPP account addresses]:${x-}"
	        echo

	    }

	    dna-set_option -o domain -v n -d y -p xmpp

	    if [ $previous_value_outcome = "not-kept" ]
	    then
	        echo "${b-}- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -${x-}"
	        echo
	        echo "${r-}${b-}WARNING:${x-}"
	        echo
	        echo "${r-}${b-}Changing domains will not preserve any user accounts or data. It will revert this server to a fresh install.${x-}"
	        echo
	        echo "${b-}In the future, all user accounts and data for the previous domain might be recovered automatically if you ever re-run the install and select the old domain, but this hasn't been thoroughly tested yet.${x-}"
	        echo
	        echo "${b-}If you abort the domain change operation now, nothing will be deleted.${x-}"
	        echo
	        echo "${b-}- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -${x-}"
	        echo
	        read -rp "${b-}Are you absolutely sure you want to change the XMPP domain now? (y/N): ${x-}" -n 1
	        echo
	        if [[ $REPLY =~ ^[Yy]$ ]]
	        then
	            echo "${b-}Ok, proceeding...${x-}"
	            echo
	        else
	            echo "${b-}Ok, setting your domain back to the previous value | $previous_value |...${x-}"
	            echo
	            domain="$previous_value"
	            echo "$previous_value" > "$opt_path"
	        fi
	    fi

		########################################################################

		### Review and set machine hostname

		curr_host_name="$(cat /etc/hostname)"

	    if [ "$curr_host_name" = "ae01.${domain}" ]
	    then
	        echo "${g-}${b-}Your hostname is already correctly set to: | ${x-}${b-}ae01.${domain}${g-} |.${x-}"
	        echo
	    else
			echo "${b-}This machine's hostname must become: | ae01.${domain} |.${x-}"
		    echo
			echo "${b-}This allows for a correct setup of ejabberd that will make it possible in the future to turn this instance of ${short_name} into a cluster should you ever choose to do so.${x-}"
			echo
		    echo "${b-}Your current hostname is:${x-}"
		    echo
		    echo " | $curr_host_name |"
	        echo
	        read -rp "${b-}Do you want to correctly set your hostname automatically? (Y/n): ${x-}" -n 1
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
	            echo "${b-}Ok, setting hostname to: | ae01.${domain} |.${x-}"
	            echo
	            echo "ae01.${domain}" > /etc/hostname
	        else
	            echo
	            echo "${b-}Ok, not changing hostname.${x-}"
	            echo
				dna-exit
	        fi
	    fi

		hostname="$(cat /etc/hostname)"

		########################################################################

		### Review domain and hostname to see if the user approves

		echo "----------------"
		echo
		echo "${b-}To make sure everything is correct:${x-}"
		echo
		echo "1] Your ${b-}XMPP domain${x-} [the part after the @ in your XMPP account addresses] will be:"
		echo
		echo "${b-} | ${g-}$domain${x-}${b-} | ${x-}"
		echo
		echo "2] And therefore an ${b-}XMPP account address${x-} will look as follows:"
		echo
		echo "${b-} | ${g-}mark@$domain${x-}${b-} | ${x-}"
		echo
		echo "3] Your ${b-}hostname${x-}, the location on the internet of this server, will be:"
		echo
		echo "${b-} | ${g-}$hostname${x-}${b-} | ${x-}"
		echo
		echo "4] And therefore your ${b-}aenigma admin panel${x-} will be located at:"
		echo
		echo "${b-} | ${g-}https://$hostname${x-}${b-} | ${x-}"
		echo
		echo "----------------"
		echo

		read -rp "${b-}Does everything look all right? (Y/n): ${x-}" -n 1
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]
		then
		    echo "${b-}Ok, continuing.${x-}"
		    echo
		    touch $conf_dir/domain
		    echo "$domain" > $conf_dir/domain
		else
		    echo
		    echo "${b-}Ok, no worries. You can re-run this script right now and make the correct choices. Exiting...${x-}"
		    echo
		    exit
		fi
		clear

		########################################################################

		### Set node_number to 01 as this is the primary node

		dna-set_option -o node_number -p cluster -s "01"

		### Initialize nodes_db files

		aenigma-initialize_nodes_db_files

		### Update routing info

		aenigma-update_routing_info

	else

		########################################################################

		### As this is a secondary node, we need to join an existing ejabberd cluster and therefore start clean and remove any ejabberd data already present on this server.

		dna-echo -m "${r-}Proceeding with this installation as a secondary node will wipe any and everything is already present on this [only this] server."
		dna-echo -m "If this node is currently part of a cluster, data on other nodes will NOT be affected, and this node will re-obtain all cluster data from other nodes upon completion of the installation."
		dna-echo -m "Please ensure there is no UNIQUE [as in non-clustered] and VALUABLE [as in you don't want to lose] data on this machine."

		ask_for_boolean_question="Proceed with wiping any ejabberd-related data on this server during the course of this installation?"
		dna-ask_for_boolean_def_no
		if [ "$ask_for_boolean_output" = "y" ]
		then
			dna-echo -m "Ok, proceeding with ejabberd wipe at the end of this installation..."
		else
			dna-echo -m "Ok, skipping ejabberd wipe and aborting installation."
			dna-exit
		fi

		########################################################################

	fi

	############################################################################

	### Set admin email address

	dna-set_admin_email

	############################################################################

	### Check internet connectivity and get public IP addresses

	dna-get_public_ipv4

	dna-check_ipv6_connectivity

	############################################################################

	### Create the necessary files and directories for ejabberd

	aenigma-create_ejabberd_locations

	############################################################################

	if [ ! "${cluster_mode-null}" = "secondary" ]
	then

		### Proceed with primary node installation

		aenigma-perform_dns_checks

		########################################################################

		### Provision the LetsEncrypt wildcard TLS certificate for $domain

	    echo "${b-}It's time to set up the LetsEncrypt wildcard TLS [SSL] certificate that will be valid for *.$domain.${x-}"
	    echo

		dna-provision_le_wildcard_cert -d "$domain"

		#### Copy the LetsEncrypt post-renewal script to its location and actually run it now to be ready for the installation

		cp "${source_dir}/conf/nginx/letsencrypt-ejabberd-post-renewal-hook" "/etc/letsencrypt/renewal-hooks/post"

		bash "/etc/letsencrypt/renewal-hooks/post/letsencrypt-ejabberd-post-renewal-hook"

	    if [ -f $tls_dir/$domain.pem ]
	    then
	        echo "${g-}${b-}External TLS certificate for $domain found in | $tls_dir/$domain.pem |."
	        echo
			sleep 1
	    else
	        echo "${r-}${b-}Something went wrong provisioning the wildcard TLS certificate for $domain.${x-}"
	        echo
	        dna-exit
	    fi

		########################################################################

		### Setup backup restore

		dna-setup_backup_restore

		########################################################################

	else

		### Proceed with secondary node installation

		########################################################################

		dna-echo -m "This is the public IPv4 for this machine:"
		dna-echo -m " | ${g-}$this_ipv4${n-} | "
		dna-echo -m "Enter it on the primary node when prompted to do so, then follow the instructions from there."

		sleep 1

		########################################################################

		if [ -f /root/.ssh/authorized_keys ]
		then
	        dna-echo -m "${g-}SSH Authorized Keys file found."
		else
			dna-echo -m "$SSH Authorized Keys file NOT found. Creating it now..."
			mkdir -p /root/.ssh/
	        touch /root/.ssh/authorized_keys
		fi

		########################################################################

		if grep -q "root@ae01." /root/.ssh/authorized_keys
		then

			dna-echo -m "${g-}An SSH public key generated by the primary node was already previously saved on this server."

			####################################################################

			check_condition() {

				if [ -f "/tmp/aenigma-cluster-ssh-connection-successful" ]
				then
					condition_verified=y
				fi

			}

			dna-wait_for -m 32 -d "Now looking to see if the primary node is already able to connect to this node..."

			if [ "${wait_output}" = "ok" ]
			then
				dna-echo -m "${g-}Primary node SSH connection to this node succeeded. Continuing installation..."
				primary_node_ssh_connection="ok"
				rm -r "/tmp/aenigma-cluster-ssh-connection-successful"
			else
				dna-echo -e "The primary node was not able to connect to this node with the SSH public key already saved on this machine."
				dna-echo -m "You will now need to specify the SSH public key displayed on your primary node."
				dna-echo -m "[or if it manages to connect in the mean time, simply type: | ${y-}skip${n-} |]"
				primary_node_ssh_connection="attempted"
			fi

			unset wait_output

			####################################################################

		fi

		if [ ! "${primary_node_ssh_connection-null}" = "ok" ]
		then

			validate_input() {

				if [ "${input}" = "skip" ]
				then

					if [ -f "/tmp/aenigma-cluster-ssh-connection-successful" ]
					then
						valid=y
					else
						dna-echo -e "The primary node still does NOT appear to have been able to successfully connect to this node."
						dna-echo -m "Ensure its connection to this machine has actually succeeded and, if not, specify the public SSH key it will display shortly."
						valid=n
					fi

				else

					dna-validate_ssh_pubkey -s -k "${input}"

					if [ "${key_is_valid}" = "y" ]
					then
						valid=y
					else
						dna-echo -e "The key you specified does NOT appear to be a valid SSH Public Key."
						valid=n
					fi

				fi

			}

			if [ "${primary_node_ssh_connection-null}" = "attempted" ]
			then
				dna-set_value -d "Now specify the public SSH key [or write | ${y-}skip${n-} | if the connection was already successful]:" -v y
			else
				dna-set_value -d "Now specify the public SSH key displayed that will be displayed shortly on the primary node:" -v y
			fi

			cluster_ssh_pubkey="${value}"

			if [ ! "${value}" = "skip" ]
			then

				if ! grep -q "${cluster_ssh_pubkey}" /root/.ssh/authorized_keys
				then
					echo "$cluster_ssh_pubkey" >> /root/.ssh/authorized_keys
				fi

			fi

		fi

		################################################################################

		### Generate token [or use the public IPv6 address of this machine if available] as visual fingerprint for user connection checking

		if [ $ipv6_available = "y" ]
		then
			echo "${this_ipv6}" > /tmp/aenigma-cluster-token
		else
			aenigma_cluster_token="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)"
			echo "${aenigma_cluster_token}" > /tmp/aenigma-cluster-token
		fi

		echo "${b-}A token has been generated to verify a correct connection to this machine from the primary node.${x-}"
		echo
		echo "${b-}You'll be asked to verify it matches with the one that will shortly be displayed on the primary node.${x-}"
		echo
		echo "${b-}Its value is: | ${y-}$(cat /tmp/aenigma-cluster-token)${n-} |.${x-}"
		echo

		dna-echo -m "After that, continue the setup on the primary node and come back here when finished."

		sleep 1

		########################################################################

		check_condition() {

			if [ -f "/tmp/aenigma-cluster-primary-node-setup-complete" ]
			then
				condition_verified=y
			fi

		}

		dna-wait_for -d "Now waiting for setup on the primary node to be complete..."
		rm -r "/tmp/aenigma-cluster-primary-node-setup-complete"
		dna-echo -m "${g-}Primary node setup complete. Now continuing installation..."
		unset wait_output
		sleep 1

		########################################################################

		### Read newly received config

		dna-read_conf_settings

		### Set hostname according to the node_number from the newly received config

		echo "ae${node_number}.${domain}" > /etc/hostname

		hostname="$(cat /etc/hostname)"

		clear

		########################################################################

	fi

	### Set UFW rules

	dna-echo -m "Now setting UFW rules..."

	ufw allow 5222
	ufw allow 5223
	ufw allow 5269
	ufw allow 5444
	ufw allow 80
	ufw allow 443

	echo
	dna-echo -m "${g-}Finished setting UFW rules."

	### Install and if necessary upgrade EasyEngine

	dna-install_easyengine

	### Stop SSLH to avoid conflicts between the time new EE sites are created + TLS-provisioned and the time they're made SSLH-compliant

	/usr/sbin/service sslh stop &> /dev/null || true

	############################################################################

	### Create and configure the $hostname website

	dna-echo -m "Now creating EasyEngine site for ${hostname}..."
	ee site create "${hostname}" || true
	echo
	dna-echo -m "${g-}Finished creating EasyEngine site for ${hostname}."

	dna-echo -m "Now setting custom nginx config for ${hostname}..."
	cp "${source_dir}/conf/nginx/hostname.conf" "/etc/nginx/sites-available/${hostname}"
	sed -i "s/hostname.xyz/${hostname}/g" "/etc/nginx/sites-available/${hostname}"
	dna-echo -m "${g-}Finished setting custom nginx config for ${hostname}."

	dna-echo -m "Now setting index.html in docroot for ${hostname}..."
	cp "${source_dir}/conf/web/hostname/index.html" "/var/www/${hostname}/htdocs/"
	dna-echo -m "${g-}Finished setting index.html in docroot for ${hostname}."

	dna-echo -m "${b-}Now adding HTTPS and IPv6 support to the ${hostname} site..."
	cp "${source_dir}/conf/nginx/ssl-hostname.conf" "/var/www/${hostname}/conf/nginx/ssl.conf"
	sed -i "s/domain.xyz/${domain}/g" "/var/www/${hostname}/conf/nginx/ssl.conf"
	dna-echo -m "${g-}Finished adding HTTPS and IPv6 support to the ${hostname} site..."

	dna-echo -m "Now adding HTTPS redirect for the ${hostname} site..."
	cp "${source_dir}/conf/nginx/force-ssl-hostname.conf" "/etc/nginx/conf.d/force-ssl-${hostname}.conf"
	sed -i "s/hostname.xyz/${hostname}/g" "/etc/nginx/conf.d/force-ssl-${hostname}.conf"
	dna-echo -m "${g-}Finished adding HTTPS redirect for the ${hostname} site..."

	service nginx reload || true

	############################################################################

	### Restart nginx

	/usr/sbin/service nginx restart || true

	############################################################################

	### Install SSLH

	aenigma-install_sslh

	############################################################################

	if [ ! "${cluster_mode-null}" = "secondary" ]
	then

		### Determine if this is a fresh install

		if [ ! -f /var/lib/ejabberd/LATEST.LOG ]
		then

			### This is a fresh install, we can proceed with customizing the ERLANG_NODE value in the /etc/default/ejabberd config file and wiping the data directory after installing ejabberd.

			set_erlang_node_to_hostname=ok
			wipe_var_lib_ejabberd=ok

		else

			### This is a re-install.

			wipe_var_lib_ejabberd=no

			### Check to see if config file already exists.

			if [ -f /etc/default/ejabberd ]
			then

				### The config file is in place. Check to see if the ERLANG_NODE value is already correct.

				if grep -q "^ERLANG_NODE=ejabberd@${hostname}$" "/etc/default/ejabberd"
				then

					### The configuration is already correct, the existing data in /var/lib/ejabberd will work fine.

					set_erlang_node_to_hostname=no

				else

					### Check to see if the ERLANG_NODE line exists

					if ! grep -q "ERLANG_NODE=ejabberd@" "/etc/default/ejabberd"
					then

						dna-echo -m "${r-}There is an error in your existing | ${n-}/etc/default/ejabberd${r-} | file as the | ${n-}ERLANG_NODE${r-} | setting is missing."
						dna-echo -m "The installation will continue without any issues, but ejabberd might refuse to start at the end if your existing data in | ${y-}/var/lib/ejabberd/${n-} | indicates that ejabberd was previously running under a different ERLANG_NODE value."
						dna-echo -m "If this is the case, after the installation is complete, edit the | ${y-}/etc/default/ejabberd${n-} | file and set the ERLANG_NODE value back to whatever you were using before [likely | ${y-}ERLANG_NODE=ejabberd@localhost${n-} |]."
						dna-echo -m "Keep in mind, though, that altering the ERLANG_NODE value will make it impossible to turn this instance of $short_name into a cluster in the future."
						dna-echo -m "To do that, you will have to start fresh by deleting the | ${y-}/var/lib/ejabberd/${n-} | directory and run an re-install in order to start using the brand new instance from scratch."
						read -rp "${b-}Press enter to continue...${x-}"
						echo

						set_erlang_node_to_hostname=ok

					else

						### Check to see if the ERLANG_NODE line is commented or its value is set to localhost

						if grep -q "#ERLANG_NODE=ejabberd@" "/etc/default/ejabberd" || grep -q "^ERLANG_NODE=ejabberd@localhost$" "/etc/default/ejabberd"
						then

							dna-echo -m "${r-}Your existing | ${n-}/etc/default/ejabberd${r-} | config file indicates that you were previously using this instance with a previous version of $short_name."

						else

							dna-echo -m "${r-}Your existing | ${n-}/etc/default/ejabberd${r-} | config file indicates that you were previously using this instance of $short_name with a different hostname than the current one."

						fi

						dna-echo -m "If you choose to continue with the upgrade/re-install, the installation will continue without any issues, but it will be impossible to turn this instance of $short_name into a cluster in the future."
						dna-echo -m "To do that, you will have to start fresh by deleting the | ${y-}/var/lib/ejabberd/${n-} | directory and run an re-install in order to start using the brand new instance from scratch."
						read -rp "${b-}Press enter to continue...${x-}"
						echo

						set_erlang_node_to_hostname=no

					fi

				fi

			else

				### It's possible the installation was never completed in the first place, this might explain the lack of a configuration file.

				if [ -f "${conf_dir}/version/version_installed" ]
				then

					### An installation was actually completed at some point. Proceed with warning the user.

					dna-echo -m "${r-}The | ${n-}/etc/default/ejabberd${r-} | configuration file of this existing installation of $short_name is missing."
					dna-echo -m "The installation will continue without any issues, but ejabberd might refuse to start at the end if your existing data in | ${y-}/var/lib/ejabberd/${n-} | indicates that ejabberd was previously running under a different ERLANG_NODE value."
					dna-echo -m "If this is the case, after the installation is complete, edit the | ${y-}/etc/default/ejabberd${n-} | file and set the ERLANG_NODE value back to whatever you were using before [likely | ${y-}ERLANG_NODE=ejabberd@localhost${n-} |]."
					dna-echo -m "Keep in mind, though, that altering the ERLANG_NODE value will make it impossible to turn this instance of $short_name into a cluster in the future."
					dna-echo -m "To do that, you will have to start fresh by deleting the | ${y-}/var/lib/ejabberd/${n-} | directory run an re-install in order to and start using the brand new instance from scratch."
					read -rp "${b-}Press enter to continue...${x-}"
					echo

				fi

				set_erlang_node_to_hostname=ok

			fi

		fi

	else

		### This is a secondary node install, the user has already consented to a full wipe, we can therefore proceed with customizing the ERLANG_NODE value in the ejabberdctl.cfg config file and wiping the data directory after installing ejabberd.

		set_erlang_node_to_hostname=ok
		wipe_var_lib_ejabberd=ok

	fi

	############################################################################
	############################################################################

	### Prepare APT for ejabberd installation.

	aenigma-add_ejabberd_repo

	############################################################################

	### Check the current status of ejabberd on this machine

	aenigma-get_ejabberd_installed_version

	if [ ! "${ejabberd_installed_version}" = "none" ]
	then

		### ejabberd is currently installed. Check if an ejabberd upgrade is going to be performed.

		aenigma-get_ejabberd_candidate_version

		if [ ! "${ejabberd_candidate_version}" = "${ejabberd_installed_version}" ]
		then

			dna-echo -s "A new version of ejabberd is available from the APT repository. Upgrading it now..."

			### Upgrade ejabberd by non-interactively installing the new config files
			### [which we'll the re-replace later in the installation anyway].

			export DEBIAN_FRONTEND=noninteractive ; apt-get install -y -o Dpkg::Options::="--force-confnew" --force-yes --only-upgrade ejabberd || true

		fi

	else

		### Remove the "ejabberd_admin_password_set" file if it exists as ejabberd was not currently installed

		if [ -f "${conf_xmpp_dir}/ejabberd_admin_password_set" ]
		then
			rm "${conf_xmpp_dir}/ejabberd_admin_password_set"
		fi

	fi

	############################################################################

	### Install the aenigma ejabberd config.

	aenigma-install_ejabberd_config

	### Perform a full APT upgrade

	dna-apt_full_upgrade -e

	### Actually install ejabberd.

	aenigma-install_ejabberd

	############################################################################

	### Stop ejabberd if it's already running [i.e. because it was already installed]

	if systemctl is-active --quiet ejabberd
	then

		dna-echo -m "Now stopping ejabberd..."
		/usr/sbin/service ejabberd stop
		dna-wait -s "4" -d "Now allowing ejabberd to shut down correctly..."
		dna-echo -s "Finished stopping ejabberd."

	fi

	### Set permissions now that user ejabberd exists while ejabberd has still not started yet

	aenigma-set_permissions

	### Perform some changes on the ejabberd config files.

	sed -i "s/xe.@/xe${node_number}.@/g" /etc/ejabberd/ejabberd.yml
	sed -i "s/xm.@/xm${node_number}.@/g" /etc/ejabberd/ejabberd.yml
	sed -i "s/xp.@/xp${node_number}.@/g" /etc/ejabberd/ejabberd.yml
	sed -i "s/xu.@/xu${node_number}.@/g" /etc/ejabberd/ejabberd.yml

	sed -i "/INET_DIST_INTERFACE=/c\INET_DIST_INTERFACE=${this_ipv4}" /etc/default/ejabberd

	if [ "${set_erlang_node_to_hostname}" = "ok" ]
	then
		sed -i "/# ERLANG_NODE/d" /etc/default/ejabberd
		sed -i "/ERLANG_NODE=/c\ERLANG_NODE=ejabberd@${hostname}" /etc/default/ejabberd
	fi

	if [ "${wipe_var_lib_ejabberd}" = "ok" ]
	then

		/usr/sbin/service ejabberd stop 2> /dev/null || true
		( cd /var/lib/ejabberd/ && find -maxdepth 1 ! -name .erlang.cookie ! -name uploads ! -name . -exec rm -rv {} \; ) > /dev/null

	fi

	dna-echo -m "Now finally starting up ejabberd..."
	/usr/sbin/service ejabberd start
	dna-wait -s "16" -d "Now allowing ejabberd to start up correctly..."
	/usr/sbin/ejabberdctl status
	echo
	dna-echo -s "Finished starting ejabberd back up."

	if [ ! "${cluster_mode-null}" = "secondary" ]
	then

		### Proceed with primary node installation

		########################################################################

		### Add backup script to crontab

		dna-add_cron_job -n ${short_name}-backup -t "8 4 * * * " -c "bash /root/openspace42/${short_name}/tools/${short_name}-backup"

		### Register ejabberd admin user

		echo "${b-}Now registering ejabberd admin user [if it doesn't yet exist]...${x-}"
		echo
		ejab_admin_pw="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)"
		/usr/sbin/ejabberdctl register admin "$domain" "$ejab_admin_pw" &> /dev/null || true
		echo "${b-}Finished registering ejabberd admin user.${x-}"
		echo
		clear

		if [ -f "${conf_xmpp_dir}/ejabberd_admin_password_set" ]
		then
		    read -rp "${b-}Leave ejabberd admin user password the same as previously set? (Y/n): ${x-}" -n 1
		    echo
		    if [[ ! $REPLY =~ ^[Nn]$ ]]
		    then
		        echo "${b-}Skipping ejabberd admin user password reset.${x-}"
		        echo
		        ejab_admin_pwreset=n
		    else
		        echo
		        echo "${b-}Ok, resetting ejabberd admin user password to: | $ejab_admin_pw | ${x-}"
		        echo
		        /usr/sbin/ejabberdctl change_password admin "$domain" "$ejab_admin_pw"
		        ejab_admin_pwreset=y
		    fi
		else
		    touch "${conf_xmpp_dir}/ejabberd_admin_password_set"
		    ejab_admin_pwreset=y
		fi

		### Update ejabberd's module repo

		echo "${b-}Now updating ejabberd's module repo...${x-}"
		echo
		set +e
		/usr/sbin/ejabberdctl modules_update_specs
		set -e
		echo "${b-}Finished updating ejabberd's module repo...${x-}"
		echo

		### Create shared roster groups

		echo "${b-}Now creating 'ADMIN:EVERYBODY' and 'ADMIN:ONLINE' shared roster groups [admin@$domain can see 'everybody' and 'all online']...${x-}"
		echo
		/usr/sbin/ejabberdctl srg_create everybody "$domain" "everybody [$domain]" "This aenigma group includes every user on this domain" ""
		/usr/sbin/ejabberdctl srg-user-add @all@ localhost everybody "$domain"
		/usr/sbin/ejabberdctl srg_create online "$domain" "online [$domain]" "This aenigma group includes every user who is online on this domain" ""
		/usr/sbin/ejabberdctl srg-user-add @online@ localhost online "$domain"
		/usr/sbin/ejabberdctl srg_create admin "$domain" admin "This is a shared roster group set by aenigma" "everybody\\nonline"
		/usr/sbin/ejabberdctl srg-user-add admin "$domain" admin "$domain"
		echo "${b-}Finished creating shared roster groups.${x-}"
		echo
		clear

	fi

	### Run a generic APT operation to catch its output and alert the user if something has gone wrong

	echo "${b-}Now performing a final run of APT to ensure all package installations have completed successfully...${x-}"
	echo
	set +e
	if apt-get -y upgrade
	then
	    echo
	    echo "${g-}${b-}All APT package installations completed successfully...${x-}"
	    echo
	else
	    echo
	    echo "${r-}${b-}An error has occured during APT operations.${x-}"
	    echo
	    echo "${b-}This was the last step in this installation, so it's possible your end result is at least partially working.${x-}"
	    echo
	    echo "${b-}Please review the above log and try running the installation again. If necessary open an issue on github. Thank you.${x-}"
	    echo
	    read -rp "${b-}[press enter to continue reading...]${x-}"
	fi
	set -e
	clear

	### Run an nginx restart to catch its output and alert the user if something has gone wrong

	echo "${b-}Now performing a final restart of nginx to ensure all related installations have completed successfully...${x-}"
	echo
	set +e
	if service nginx restart
	then
	    echo
	    echo "${g-}${b-}All nginx installations completed successfully...${x-}"
	    echo
	else
	    echo
	    echo "${r-}${b-}An error has occured during nginx operations.${x-}"
	    echo
	    echo "${b-}This was the last step in this installation, so it's possible your end result is at least partially working.${x-}"
	    echo
	    echo "${b-}Please review the above log and try running the installation again. If necessary open an issue on github. Thank you.${x-}"
	    echo
	    read -rp "${b-}[press enter to continue reading...]${x-}"
	fi
	set -e
	clear

	### Run an sslh restart to catch its output and alert the user if something has gone wrong

	echo "${b-}Now performing a final restart of nginx to ensure all related installations have completed successfully...${x-}"
	echo
	set +e
	if service sslh restart
	then
	    echo
	    echo "${g-}${b-}All sslh installations completed successfully...${x-}"
	    echo
	else
	    echo
	    echo "${r-}${b-}An error has occured during sslh operations.${x-}"
	    echo
	    echo "${b-}This was the last step in this installation, so it's possible your end result is at least partially working.${x-}"
	    echo
	    echo "${b-}Please review the above log and try running the installation again. If necessary open an issue on github. Thank you.${x-}"
	    echo
	    read -rp "${b-}[press enter to continue reading...]${x-}"
	fi
	set -e
	clear

	if [ ! "${cluster_mode-null}" = "secondary" ]
	then

		### Proceed with primary node installation

		########################################################################

		### Pring login information and credentials

		echo "${g-}${b-}You can finally log in:${x-}"
		echo
		echo "${b-}https://${hostname}${x-}"
		echo
		echo "${b-}admin@${domain}${x-}"
		echo

		if [ $ejab_admin_pwreset = "y" ]
		then
		    echo "${b-}$ejab_admin_pw${x-}"
		    echo
		else
		    echo "${b-}[your previously set password]${x-}"
		    echo
		fi

		read -rp "${b-}[press enter to continue reading...]${x-}"
		echo

		if [ "${cluster_mode}" = "cluster" ]
		then

			dna-echo -m "It's now time to run the | ${o-}clusterize${n-} | script to start adding your secondary nodes."
			ask_for_boolean_question="Are you ready to do so now?"
            dna-ask_for_boolean_def_yes
            if [ "$ask_for_boolean_output" = "y" ]
            then
				dna-echo -m "Ok, running the | ${o-}clusterize${n-} | script now..."
				bash "${tools_dir}/${short_name}-clusterize"
			else
				dna-echo -m "Ok, you can run the | ${o-}clusterize${n-} | script at any time by executing:"
				dna-echo -m " | ${y-}bash ${tools_dir}/${short_name}-clusterize${n-} | "
				read -rp "${b-}[press enter to continue reading...]${x-}"
				echo
			fi
		fi

	else

		dna-echo -m "Now joining ejabberd cluster by connecting to the primary node..."

		if /usr/sbin/ejabberdctl --no-timeout join_cluster "ejabberd@ae01.${domain}"
		then
			dna-echo -m "${g-}The ejabberd cluster was successfully joined!"
		else
			dna-echo -m "${r-}The ejabberd cluster join operation failed."
			dna-exit
		fi

	fi

	### Generate aenigma-specific DHparam file

	dna-generate_project_specific_dhparam

	### If DHparam file was found or generated, amend the config file to include them:

	if [ "${dh_param_status}" = "ok" ]
	then
		sed -i "s|### dhfile: 'DHFILE'|dhfile: 'DHFILE'|g" "/etc/ejabberd/ejabberd.yml"
		sed -i "s|### s2s_dhfile: 'DHFILE'|s2s_dhfile: 'DHFILE'|g" "/etc/ejabberd/ejabberd.yml"
		/usr/sbin/service ejabberd restart
	fi

	############################################################################
	############################################################################
	############################################################################

}

################################################################################
