#!/usr/bin/env bash

### openspace synthia bootstrap framework v0.2.0 [https://github.com/openspace42/synthia]

os_dna_version=0.2.5

################################################################################

define_vars() {

	############################################################################
	######################## Insert your variables here ########################
	############################################################################

	proj_name="aenigma"
	short_name="aenigma"
	author_name="openspace42"
	git_host="https://github.com/"

	### Set this to `y` if your project stores no data on end users' machines that could go lost during a re-install or update
	skip_install_time_backup=n

	### Set this to the directory that has the most impactful size when performing a backup [such as `/var/www/` for nginx-related projects]
	backup_ref_dir="/var/lib/ejabberd"

	############################################################################
	############################################################################
	############################################################################

	os-define_vars

}

################################################################################

check_root() {

	if [[ $EUID -ne 0 ]]
	then
		echo "This script must be run as root."
		echo
		echo "Exiting..."
		echo
		exit 1
	fi

}

download_os_dna() {

	clone_host="https://github.com"
	clone_author="openspace42"
	clone_name="dna"

	clone_base_dir=/root/$clone_author
	clone_dir=$clone_base_dir/$clone_name

	mkdir -p $clone_base_dir

	if [ -d $clone_dir ]
	then
		rm -r ${clone_dir:?}
	fi

	( cd "$clone_base_dir" && git clone "$clone_host/$clone_author/$clone_name" && cd "$clone_name" && \
		if [ ! "${custom_dna_version-null}" = "b" ]; \
		then \
			git checkout "tags/v$os_dna_version" && \
			echo "$os_dna_version" > "./version_installed"; \
		else \
			clone_latest_commit="$(git log -n 1 --pretty=format:"%H"  | cut -c1-7)" && \
			echo "bleeding-edge-$clone_latest_commit" > "./version_installed"; \
		fi &> /dev/null \
	)

}

source_os_dna() {

	for f in /root/openspace42/dna/functions/*
	do
		. $f
	done

}

################################################################################

################################################################################
######################## Insert project functions here #########################
################################################################################

aenigma_xmpp_intro() {

	echo "0] First of all, a little introduction on how XMPP actually works"
	echo
	echo "XMPP works a little bit like email. You can have a domain [amsterdamhacklab.xyz] and receive email for that domain on a server located at mx01.amsterdamhacklab.xyz, by using the appropriate DNS configuration, and also have other servers [webserver, mapserver, etc...] on other subdomains. In that case, a DNS MX record tells sending servers to direct mail intended for amsterdamhacklab.xyz to mx01.amsterdamhacklab.xyz."
	echo
	echo "In the same way, the XMPP server for amsterdamhacklab.xyz can be located at xmpp.amsterdamhacklab.xyz and a DNS SRV record tells any sending servers that XMPP for that domain [i.e. a message directed to mark@amsterdamhacklab.xyz] is handled by the server located at xmpp.amsterdamhacklab.xyz."
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "1] Now, if the domain for which you're setting up your new aenigma server is a domain connected to a bigger project, for which XMPP is just another way of getting in touch with you, definitely set things up like this by using the first option."
	echo
	echo "This will give you working @domain.tld xmpp account addresses, but the aenigma server will reside at subdomain.domain.tld, as in the following example."
	echo
	echo "Main domain:          amsterdamhacklab.xyz."
	echo "Website:              amsterdamhacklab.xyz / www.amsterdamhacklab.xyz [hosted by another server]."
	echo "Your XMPP address:    mark@amsterdamhacklab.xyz."
	echo "XMPP server:          xmpp.amsterdamhacklab.xyz"
	echo
	echo "PROs:                 a] clean addresses [no mark@xmpp.amsterdamhacklab.xyz stuff]"
	echo "                      b] more logical setup."
	echo "CONs:                 a] requires TLS [SSL] certificate for the top level domain [amsterdamhacklab.xyz]"
	echo "                         to be copied over to your new aenigma server [not hard at all, can be automated, see below]"
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "2] If instead your domain [i.e. aenigmapod42.im] is only intended to be used for your shiny new aenigma server, and you don't need other, different servers [a webserver for instance] managing different aspects of your project, you can do as so:"
	echo
	echo "Set your aenigma server to be located directly at your top level domain, therefore responding directly to amsterdamhacklab.xyz."
	echo
	echo "Your server hostname:  aenigmapod42.im"
	echo "Your addresses:        mark@aenigmapod42.im."
	echo
	echo "PROs:                  a] clean addresses"
	echo "                       b] no separate TLS certificate needed."
	echo "CONs:                  a] your domain must be logically dedicated to your aenigma server"
	echo "                          and not to a wider project."
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "3] In a third, although NOT suggested case, if you have a domain tied to a wider project [i.e. amsterdamhacklab.xyz] but you don't mind having longer and more complex XMPP account addresses [like mark@xmpp.amsterdamhacklab.xyz], you can choose the third option."
	echo
	echo "Your server hostname:  subdomain.domain.tld"
	echo "Your addresses:        mark@subdomain.domain.tld."
	echo
	echo "PROs:                  a] domain can be logically connected to other stuff and different servers"
	echo "                          with no separate TLS certificate needed."
	echo "CONs:                  a] longer and more complex addresses"
	echo "                       b] not logically 'clean'."
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "Now that you know how XMPP works, make your choice and let's get your brand new aenigma server up and running!"
	echo
	echo "----------------"
	echo

}

aenigma-add_ejabberd_repo() {

	currdistro="$(lsb_release --codename | cut -f2)"
	apt-get -y install apt-transport-https || true
	echo "deb https://apt.jabber.at $currdistro ejabberd" > /etc/apt/sources.list.d/jabber.at.list
	wget -qO- https://apt.jabber.at/gpg-key | apt-key add -
	apt-get update

}

aenigma-install_ejabberd_config() {

	echo "${b}Now creating ejabberd directory and setting custom aenigma config to /etc/ejabberd/ejabberd.yml...${x}"
	echo

	ejab_cand_vers="$(apt-cache show ejabberd | grep Version | head -1 | sed "s|Version: ||" | cut -d ':' -f 2 | cut -f1 -d'-')"

	source_ejab_conf_file="$source_dir/conf/ejabberd/ejabberd-$ejab_cand_vers.yml"

	if [ ! -f $source_ejab_conf_file ]
	then
		### Fallback to ejabberd.yml for v17.08 in case the ejabberd candidate install version isn't among the ones we have config files for
		source_ejab_conf_file="$source_dir/conf/ejabberd/ejabberd-17.08.yml"
	fi

	mkdir -p /etc/ejabberd/
	touch /etc/ejabberd/ejabberd.yml
	sed -i "s/example.im/${domain}/g" "$source_ejab_conf_file"
	sed -i "s/hostname.im/${hostname}/g" "$source_ejab_conf_file"
	if [ $config_option = 1 ]
	then
		sed -i "s|example.im|${domain}|g" $source_dir/conf/ejabberd/ejabberd-tlsaddition-domain.txt
		sed -i "s|pathtofile|${domain_tls_cert_location}|g" $source_dir/conf/ejabberd/ejabberd-tlsaddition-domain.txt
		sed -i '/## aenigma_host_config_domain_placeholder_start:/,/## aenigma_host_config_domain_placeholder_end:/{//!d}' $source_dir/conf/ejabberd/ejabberd.yml
		sed -i "/## aenigma_host_config_domain_placeholder_start:/ r $source_dir/conf/ejabberd/ejabberd-tlsaddition-domain.txt" $source_dir/conf/ejabberd/ejabberd.yml
	fi
	cp "$source_ejab_conf_file" /etc/ejabberd/ejabberd.yml
	echo "${b}Finished creating ejabberd directory and setting custom aenigma config to /etc/ejabberd/ejabberd.yml.${x}"
	echo

}

backup_locally_loop() {

	cp -r "$conf_dir" "$tmp_backup_dir"/conf/
	mkdir -p "$tmp_backup_dir"/data/
	/usr/sbin/ejabberdctl backup ejabberd-mnesia-backup
	mv /var/lib/ejabberd/ejabberd-mnesia-backup "$tmp_backup_dir"/data/ejabberd-mnesia-backup
	cp -r /etc/ejabberd/ "$tmp_backup_dir"/data/etc-ejabberd/
	cp -r /var/lib/ejabberd/ "$tmp_backup_dir"/data/var-lib-ejabberd/

}

restore_loop() {

	echo "${b}1] Now restoring aenigma config directory...${x}"
	echo

	rsync -aAXx --delete $restore_file_path/conf/ $conf_dir/

	echo "${b}2] Now restoring ejabberd database...${x}"
	echo

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
	        echo "${g}${b}ejabberd is already running. Continuing...${x}"
	        echo
	else
	        echo "${r}${b}ejabberd NOT running. Starting it now...${x}"
	        echo
	        echo "${b}Now starting ejabberd ...${x}"
	        /usr/sbin/service ejabberd start
	        echo
	        sleep 8
	        /usr/sbin/ejabberdctl
	        echo
	        sleep 1
	fi

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
	        cd $restore_file_path/data/
		cp ./ejabberd-mnesia-backup /var/lib/ejabberd/
	        /usr/sbin/ejabberdctl restore ejabberd-mnesia-backup
		rm /var/lib/ejabberd/ejabberd-mnesia-backup
	        echo "${b}Successfully restored ejabberd database...${x}"
	        echo
	        sleep 8
	else
	        echo "${r}${b}ERROR: ejabberd STILL NOT running. Unable to restore database from backup.${x}"
	        echo
	        os-exit_function
	fi

	echo "${b}Now restoring ejabberd directories...${x}"
	echo

	echo "${b}Now stopping ejabberd for directory restore...${x}"
	echo
	/usr/sbin/service ejabberd stop
	sleep 8

	echo "${b}3] Now syncing ejabberd directories...${x}"
	echo

	rsync -aAXx --delete $restore_file_path/data/etc-ejabberd/ /etc/ejabberd/
	rsync -aAXx --delete $restore_file_path/data/var-lib-ejabberd/ /var/lib/ejabberd/

	echo "${b}Now setting permissions on ejabberd directories...${x}"
	echo

	chown -R ejabberd:ejabberd /etc/ejabberd/
	chown -R ejabberd:ejabberd /var/lib/ejabberd/

	echo "${b}Now starting ejabberd...${x}"
	/usr/sbin/service ejabberd start
	echo
	sleep 16
	/usr/sbin/ejabberdctl status
	echo
	sleep 1

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then

	        echo "${g}${b}Restore complete!${x}"
	        echo
	        echo "${b}Now please verify your aenigma instance is running correctly and has everything you except it to.${x}"
	        echo

	        read -p "${b}Has your previous instance of aenigma been restored correctly? (Y/n): ${x}" -n 1 -r
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
	                echo "${g}${b}Ok, all done!${x}"
	                echo
	                if [ -f $conf_dir/blocks3backups ]
	                then
				rm $conf_dir/blocks3backups
	                        echo "${b}Removing S3 backups lock since your restore has been successful.${x}"
	                        echo
	                        echo "${r}${b}This machine will now pick up where the old one left off and start backing up again to S3 and will overwrite all previous data stored on S3.${x}"
	                        echo
	                        echo "${b}If you've changed your mind and are NOT yet sure this restore was completely successful, simply:${x}"
	                        echo
	                        echo "${b} | touch $conf_dir/blocks3backups |"
	                        echo
	                        echo "${b}And remember to remove it as soon as you're done verifying this restored instance to then resume backups to S3!${x}"
	                        echo
	                        echo "${g}${b}All done for now.${x}"
	                        echo
	                fi
	        else
	                echo
	                echo "${b}Sorry about that, please collect all evidence you can find so and simply file an issue report at:${x}"
	        	echo
	        	echo "${b} | https://github.com/openspace42/aenigma/issues |${x}"
	        	echo
	        	echo "${b}Thank you in advance!${x}"
	                echo
	        fi

	else

	        echo "${r}${b}ERROR: ejabberd not running after restore. Please check ejabberd directories.${x}"
	        echo
	        echo "${b}Please collect all evidence you can find so and simply file an issue report at:${x}"
	        echo
	        echo "${b} | https://github.com/openspace42/aenigma/issues |${x}"
	        echo
	        echo "${b}Thank you in advance!${x}"
	        echo
	        echo "${b}Exiting...${x}"
	        echo
	        exit

	fi

	if [ -d "$restores_dir/local/" ]
	then
		rm -r "$restores_dir/local/"
	fi

	if [ -d "/root/$short_name-restore/" ]
	then
		rm -r "/root/$short_name-restore/"
	fi

	if [ -d "$tmpdir" ]
	then
		rm -r "${tmpdir:?}"
	fi

	if [ $bootstrapmode = "on" ]
	then
		echo "${b}Now that we're finished with the initial restore, it's time to re-run the install script and get this machine up and running with your old instance's files and settings${x}"
		echo
		echo "${b}Running install script now.${x}"
		echo
		echo "${r}${b}Should you exit the install script during its runtime, you can re-run it manually with:${x}"
		echo
		echo "${b} | bash $sourcedir/install.sh | ${x}"
		cd
		bash $sourcedir/install.sh
	fi

}

################################################################################
################################################################################
################################################################################

perform_installation() {

	############################################################################
	################### Add your install-time functions here ###################
	############################################################################

	os-check_sslh_connection

	os-check_distro_ubuntu_lts

	os-check_inception_run

	################################################################################

	os-apt_full_upgrade -e

	os-install_duplicity

	mkdir -p "$tls_dir"
	mkdir -p "$temp_dir"

	################################################################################

	### Copy files to destination

	rsync -aAXx $source_dir/ $install_dir/ --include=tools*** --include=functions --exclude="*"

	### Skip intro if requested by user

	if [ $skip_intro = "n" ]
	then
	    aenigma_xmpp_intro
	fi

	### Set aenigma config option [described in intro]

	validate_input() {

	    case $input in
	        1|2|3)	config_option=$input
	        valid=y
	        ;;
	        *)	echo "${r}${b}Invalid setting for | config_option | in function | ${FUNCNAME[0]} |.${x}"
	        echo
	        valid=n
	        ;;
	    esac

	}

	os-set_option -o config_option -v y -d n -p xmpp

	### Set xmpp domain [only one supported for now] if config_option != 3
	### In the latter case the xmpp domain will match the machine hostname [see below]

	if [ ! $config_option = "3" ]
	then

	    echo "${b}Ok, you've chosen option $config_option.${x}"
	    echo

	    describe_setting() {

	        echo "${b}Now set your top level domain, which will also be the part after the @ in your XMPP account addresses:${x}"
	        echo

	    }

	    os-set_option -o domain -v n -d y -p xmpp

	    if [ $prev_val_outcome = "not-kept" ]
	    then
	        echo "${b}- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -${x}"
	        echo
	        echo "${r}${b}WARNING:${x}"
	        echo
	        echo "${r}${b}Changing domains will not preserve any user accounts or data. It will revert this server to a fresh install.${x}"
	        echo
	        echo "${b}In the future, all user accounts and data for the previous domain might be recovered automatically if you ever re-run the install and select the old domain, but this hasn't been thoroughly tested yet.${x}"
	        echo
	        echo "${b}If you abort the domain change operation now, nothing will be deleted.${x}"
	        echo
	        echo "${b}- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -${x}"
	        echo
	        read -rp "${b}Are you absolutely sure you want to change the XMPP domain now? (y/N): ${x}" -n 1
	        echo
	        if [[ $REPLY =~ ^[Yy]$ ]]
	        then
	            echo "${b}Ok, proceeding...${x}"
	            echo
	        else
	            echo "${b}Ok, setting your domain back to the previous value | $prev_value |...${x}"
	            echo
	            domain="$prev_val"
	            echo "$prev_val" > "$opt_path"
	        fi
	    fi

	else

	    echo "${b}Ok, you've chosen option 3.${x}"
	    echo
	    echo "${b}Your domain [the part after the @ in your XMPP account addresses] will match your server hostname.${x}"
	    echo

	fi

	### Review and set machine hostname according to config_option

	curr_host_name="$(cat /etc/hostname)"

	if [ ! $config_option = "2" ]
	then

	    describe_setting() {

	        if [ $config_option = "1" ]
	        then
	            echo "${b}Your hostname must be a third level domain [subdomain] of either $domain or another domain.${x}"
	            echo
	        elif [ $config_option = "3" ]
	        then
	            echo "${b}Your hostname must be a third level domain [subdomain] of your main domain.${x}"
	            echo
	            echo "${b}Keep in mind that your hostname will also become your domain [the part after the @ in your XMPP account addresses].${x}"
	            echo
	        fi

	    }

	    os-set_option -o hostname -v n -d y -p /etc

	    if [ $config_option = "3" ]
	    then
	        domain=$hostname
	    fi

	else

	    echo "${b}Your hostname must be identical to your domain: $domain.${x}"
	    echo
	    echo "${b}Your current hostname is:${x}"
	    echo
	    echo " | $curr_host_name |"
	    echo
	    if [ "$curr_host_name" = "$domain" ]
	    then
	        echo "${g}${b}Your hostname matches your domain, all good!${x}"
	        echo
	    else
	        echo "${r}${b}Your hostname does NOT match the domain you've specified.${x}"
	        echo
	        echo "${b}Having chosen option 2, they must be identical.${x}"
	        echo
	        read -rp "${b}Do you want to set your hostname to match your domain? (Y/n): ${x}" -n 1
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
	            echo "${b}Ok, setting hostname to match domain.${x}"
	            echo
	            echo "$domain" > /etc/hostname
	            echo "${b}New hostname set to | $domain | ${x}"
	            echo
	        else
	            echo
	            echo "${b}Not changing hostname. Exiting...${x}"
	            echo
	            exit
	        fi
	    fi

	    hostname="$(cat /etc/hostname)"

	fi
	clear

	### Review domain and hostname to see if the user approves

	echo "----------------"
	echo
	echo "${b}To make sure everything is correct:${x}"
	echo
	echo "1] Your ${b}XMPP domain${x} [the part after the @ in your XMPP account addresses] will be:"
	echo
	echo "${b} | ${g}$domain${x}${b} | ${x}"
	echo
	echo "2] And therefore an ${b}XMPP account address${x} will look as follows:"
	echo
	echo "${b} | ${g}mark@$domain${x}${b} | ${x}"
	echo
	echo "3] Your ${b}hostname${x}, the location on the internet of this server, will be:"
	echo
	echo "${b} | ${g}$hostname${x}${b} | ${x}"
	echo
	echo "4] And therefore your ${b}aenigma admin panel${x} will be located at:"
	echo
	echo "${b} | ${g}https://$hostname${x}${b} | ${x}"
	echo
	echo "----------------"
	echo

	read -rp "${b}Does everything look all right? (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
	    echo "${b}Ok, continuing.${x}"
	    echo
	    touch $conf_dir/domain
	    echo "$domain" > $conf_dir/domain
	else
	    echo
	    echo "${b}Ok, no worries. You can re-run this script right now and make the correct choices. Exiting...${x}"
	    echo
	    exit
	fi
	clear

	### Set admin email address

	os-set_admin_email

	### Check internet connectivity and get public IP addresses

	os-get_public_ipv4

	os-check_ipv6_connectivity

	### Provision the LetsEncrypt wildcard TLS certificate for $domain

    echo "${b}It's time to set up the LetsEncrypt wildcard TLS [SSL] certificate that will be valid for *.$domain.${x}"
    echo

	os-provision_le_wildcard_cert -d "$domain"

	#### Copy the LetsEncrypt post-renewal script to its location and actually run it now to be ready for the installation

	cp "$source_dir/conf/nginx/letsencrypt-ejabberd-post-renewal-hook" "/etc/letsencrypt/renewal-hooks/post"

	bash "/etc/letsencrypt/renewal-hooks/post/letsencrypt-ejabberd-post-renewal-hook"

    if [ -f $tls_dir/$domain.pem ]
    then
        echo "${g}${b}External TLS certificate for $domain found in | $tls_dir/$domain.pem |."
        echo
		sleep 1
    else
        echo "${r}${b}Something went wrong provisioning the wildcard TLS certificate for $domain.${x}"
        echo
        os-exit_function
    fi

    domain_tls_cert_location="$tls_dir/$domain.pem"
    echo "$domain_tls_cert_location" > "$conf_dir/domain_tls_cert_location"

	### Setup backup restore

	os-setup_backup_restore

	### Perform DNS checks

	if [ ! $config_option = "3" ]
	then
	    declare -a dnsarray=(
	    "hostname"
	    "XMPP"
	    "SRV"
	    )
	else
	    declare -a dnsarray=(
	    "hostname"
	    "XMPP"
	    )
	fi

	if [ $ipv6_avail = "y" ]
	then
	    declare -a iparray=(
	    "v4"
	    "v6"
	    )
	else
	    declare -a iparray=(
	    "v4"
	    )
	fi

	server_number=00 ### Change this in the future to clusterize

	for dnstype in "${dnsarray[@]}"
	do

	    if [ "$dnstype" = "hostname" ]
	    then
	        dnschecktype=$hostname
	    else
	        dnschecktype=$domain
	    fi

	    srvdone=n

	    for ipversion in "${iparray[@]}"
	    do

	        if [ $srvdone = n ]
	        then

	            if [ ! "$dnstype" = "SRV" ]
	            then
	                echo "${b}Now let's make sure your $dnstype IP$ipversion DNS settings are correct.${x}"
	                echo
	            else
	                echo "${b}Since you've chosen option 1, your domain is different from your hostname.${x}"
	                echo
	                echo "${b}Therefore, we have to set some DNS 'SRV' records which will direct XMPP connections for $domain to this server.${x}"
	                echo
	                echo "${b}Now let's make sure your XMPP SRV records are correct.${x}"
	                echo
	            fi

	            if [ "$dnstype" = "hostname" ]
	            then
	                declare -A digarray=(
	                [HN]=""
	                )
	            elif [ "$dnstype" = "domain" ]
	            then
	                declare -A digarray=(
	                [HN]=""
	                )
	            elif [ "$dnstype" = "XMPP" ]
	            then
	                declare -A digarray=(
	                [xc]="xc${server_number}."
	                [xe]="xe${server_number}."
	                [xi]="xi${server_number}."
	                [xm]="xm${server_number}."
	                [xp]="xp${server_number}."
	                [xu]="xu${server_number}."
	                )
	            elif [ "$dnstype" = "SRV" ]
	            then
	                declare -A digarray=(
	                [sj]="_jabber._tcp."
	                [ss]="_xmpp-server._tcp."
	                [sc]="_xmpp-client._tcp."
	                )
	            fi

	            digarrayiter=0

	            for i in "${!digarray[@]}"
	            do

					if [ "$dnstype" = "hostname" ]
	                then
						declare -A sub_digarray=(
		                [tl]="${digarray[$i]}"
		                [ww]="www.${digarray[$i]}"
		                )
					else
						declare -A sub_digarray=(
		                [tl]="${digarray[$i]}"
		                )
					fi

					for i in "${!sub_digarray[@]}"
		            do

		                digarrayiter=$((digarrayiter + 1))

		                if [ ! "$dnstype" = "SRV" ]
		                then
		                    echo "${b}$digarrayiter] Now checking the ${sub_digarray[$i]}$dnschecktype DNS record in IP$ipversion...${x}"
		                    echo
		                else
		                    echo "${b}$digarrayiter] Now checking the ${sub_digarray[$i]}$dnschecktype SRV record...${x}"
		                    echo
		                fi

		                accept=n
		                until [ $accept = "y" ]
		                do

		                    if [ ! "$dnstype" = "SRV" ]
		                    then
		                        if [ "$ipversion" = "v4" ]
		                        then
		                            thisip=$this_ipv4
		                            digresult="$(getent ahostsv4 "${sub_digarray[$i]}""$dnschecktype". | head -1 |sed 's/ .*//')"
		                            rectype="A"
		                        else
		                            thisip=$this_ipv6
		                            digresult="$(getent ahostsv6 "${sub_digarray[$i]}""$dnschecktype". | grep -v "$this_ipv4" | head -1 | sed 's/ .*//')"
		                            rectype="AAAA"
		                        fi
		                    else
		                        if [ ! "${sub_digarray[$i]}" = "_xmpp-client._tcp." ]
		                        then
		                            thisip="0 0 5269 $hostname."
		                        else
		                            thisip="0 0 5222 $hostname."
		                        fi
		                        digresult="$(dig +short -t srv "${sub_digarray[$i]}""$domain")"
		                        rectype="SRV"
		                    fi

		                    if [ -z "$digresult" ]
		                    then

		                        if [ ! "$dnstype" = "SRV" ]
		                        then
		                            echo "${r}${b}The ${sub_digarray[$i]}$dnschecktype IP$ipversion DNS record does NOT appear to be at all set.${x}"
		                            echo
		                        else
		                            echo "${r}${b}The ${sub_digarray[$i]}$dnschecktype SRV record does NOT appear to be at all set.${x}"
		                            echo
		                        fi

		                        echo "${b}Please ensure you set your DNS record as follows:${x}"
		                        echo
		                        echo -e "| ${sub_digarray[$i]}$dnschecktype\\t\\t$rectype\\t$thisip |"
		                        echo
		                        if [ ! "${sub_digarray[$i]}$dnschecktype" = "$hostname" ]
		                        then
		                            if [ $rectype = "A" ] || [ $rectype = "AAAA" ]
		                            then
		                                if [ "$ipversion" = "v4" ]
		                                then
		                                    echo "${g}${b}You can also set this record as a CNAME [suggested choice]:${x}"
		                                    echo
		                                    echo -e "| ${sub_digarray[$i]}$dnschecktype\\t\\tCNAME\\t$hostname |"
		                                    echo
		                                fi
		                            fi
		                        fi
		                        result=notset
		                    else
		                        if [ "$digresult" = "$thisip" ]
		                        then

		                            if [ ! "$dnstype" = "SRV" ]
		                            then
		                                echo "${g}${b}The ${sub_digarray[$i]}$dnschecktype IP$ipversion DNS record appears to resolve correctly to this server.${x}"
		                                echo
		                            else
		                                echo "${g}${b}The ${sub_digarray[$i]}$dnschecktype SRV record appears to resolve correctly to this server.${x}"
		                                echo
		                            fi

		                            echo -e "| ${sub_digarray[$i]}$dnschecktype\\t\\t$rectype\\t$thisip |"
		                            echo
		                            result=ok
		                        else

		                            if [ ! "$dnstype" = "SRV" ]
		                            then
		                                echo "${r}${b}The ${sub_digarray[$i]}$dnschecktype IP$ipversion DNS record does NOT appear to correctly resolve to this server.${x}"
		                                echo
		                            else
		                                echo "${r}${b}The ${sub_digarray[$i]}$dnschecktype SRV record does NOT appear to correctly resolve to this server.${x}"
		                                echo
		                            fi

		                            echo "${b}This is the result of a DNS query for ${sub_digarray[$i]}$dnschecktype:${x}"
		                            echo
		                            echo "$digresult"
		                            echo
		                            echo "${b}Please set it instead to:${x}"
		                            echo
		                            echo -e "| ${sub_digarray[$i]}$dnschecktype\\t\\t$rectype\\t$thisip |"
		                            echo
		                            if [ ! "${sub_digarray[$i]}$dnschecktype" = "$hostname" ]
		                            then
		                                if [ $rectype = "A" ] || [ $rectype = "AAAA" ]
		                                then
		                                    if [ "$ipversion" = "v4" ]
		                                    then
		                                        echo "${g}${b}You can also set this record as a CNAME [suggested choice]:${x}"
		                                        echo
		                                        echo -e "| ${sub_digarray[$i]}$dnschecktype\\t\\tCNAME\\t$hostname |"
		                                        echo
		                                    fi
		                                fi
		                            fi
		                            result=incorrect
		                        fi
		                    fi

		                    if [ ! $result = "ok" ]
		                    then
		                        valid=n
		                        until [ $valid = "y" ]
		                        do
		                            read -n 1 -rp "${b}Test again?${x} (${b}Y${x}[es]/${b}s${x}[kip]/${b}e${x}[xit]) " answer;
		                            case $answer in
		                                "")
		                                echo
		                                valid=y
		                                accept=n
		                                ;;
		                                y)
		                                echo -e "\\n"
		                                valid=y
		                                accept=n
		                                ;;
		                                s)
		                                echo -e "\\n"
		                                echo "${b}Skipping DNS check for this record...${x}"
		                                echo
		                                valid=y
		                                accept=y
		                                ;;
		                                e)
		                                echo -e "\\n"
		                                echo "${b}Exiting...${x}"
		                                echo
		                                exit
		                                ;;
		                                *)
		                                echo -e "\\n"
		                                echo "${b}Invalid option. Retry...${x}"
		                                echo
		                                valid=n
		                                accept=n
		                                ;;
		                            esac
		                        done
		                    else
		                        accept=y
		                    fi
		                    clear

		                done

					done

	            done

	            if [ ! "$dnstype" = "SRV" ]
	            then
	                echo "${b}Finished checking your $dnstype IP$ipversion DNS settings.${x}"
	                echo
	            else
	                echo "${b}Finished checking your XMPP SRV records.${x}"
	                echo
	                srvdone=y
	            fi

	        fi

	    done

	done
	clear

	### Set UFW rules

	echo "${b}Now setting UFW rules...${x}"
	echo

	ufw allow 5222
	ufw allow 5223
	ufw allow 5269
	ufw allow 5444
	ufw allow 80
	ufw allow 443

	echo
	echo "${b}Finished setting UFW rules.${x}"
	echo

	### Install and if necessary upgrade EasyEngine

	echo "${b}Now installing easyengine...${x}"
	echo
	wget -qO ee rt.cx/ee
	bash ee || true
	rm ee
	source /etc/bash_completion.d/ee_auto.rc
	ee update || true
	rm /tmp/eeupdate* || true
	mkdir -p /var/www/
	chown -R www-data:www-data /var/www/
	echo
	echo "${b}Finished installing easyengine.${x}"
	echo

	### Stop SSLH to avoid conflicts between the time new EE sites are created + TLS-provisioned and the time they're made SSLH-compliant

	/usr/sbin/service sslh stop &> /dev/null || true

	############################################################################

	### Create and configure the $hostname website

	### We still use a separate LE TLS cert for $hostname for ease of automation via EE

	echo "${b}Now creating easyengine site for $hostname, generating its TLS certificate, and installing it...${x}"
	echo
	ee site create "$hostname" || true
	echo
	echo "${b}Finished creating easyengine site for $hostname.${x}"
	echo

	echo "${b}Now setting custom nginx config for $hostname...${x}"
	echo
	sed -i "s/example.im/${hostname}/g" $source_dir/conf/nginx/hostname.conf
	cp "$source_dir"/conf/nginx/hostname.conf /etc/nginx/sites-available/"$hostname"
	service nginx reload || true
	echo "${b}Finished setting custom nginx config for $hostname.${x}"
	echo

	echo "${b}Now updating easyengine site $hostname to TLS encrypted with LetsEncrypt...${x}"
	echo
	ee site update "$hostname"  --le --experimental || true
	if [ ! -f /etc/letsencrypt/live/"$hostname"/fullchain.pem ]
	then
	    echo "${r}${b}There was an issue provisioning the TLS certificate for $hostname with LetsEncrypt.${x}"
	    echo
	    echo "${b}Make sure you haven't skipped any DNS checks and try running the installation again...${x}"
	    echo
	    echo "${b}Exiting...${x}"
	    echo
	    exit
	fi
	echo
	echo "${b}Finished updating easyengine site $hostname to TLS encrypted with LetsEncrypt...${x}"
	echo

	echo "${b}Now setting index.html in docroot for $hostname...${x}"
	echo
	cp "$source_dir"/conf/web/hostname/index.html /var/www/"$hostname"/htdocs/
	echo "${b}Finished setting index.html in docroot for $hostname.${x}"
	echo

	echo "${b}Now adding IPv6 support to the HTTPS version of the $hostname site...${x}"
	echo
	sed -i "s/example.im/${hostname}/g" $source_dir/conf/nginx/ssl-hostname.conf
	cp "$source_dir"/conf/nginx/ssl-hostname.conf /var/www/"$hostname"/conf/nginx/ssl.conf
	echo "${b}Finished adding IPv6 support to the HTTPS version of the $hostname site...${x}"
	echo

	echo "${b}Now adding IPv6 support to the HTTPS redirect for the $hostname site...${x}"
	echo
	sed -i "s/example.im/${hostname}/g" $source_dir/conf/nginx/force-ssl-hostname.conf
	cp "$source_dir"/conf/nginx/force-ssl-hostname.conf /etc/nginx/conf.d/force-ssl-"$hostname".conf
	echo "${b}Finished adding IPv6 support to the HTTPS redirect for the $hostname site...${x}"
	echo

	############################################################################

	### Run the LetsEncrypt post-renewal now to be ready for the installation

	bash "/etc/letsencrypt/renewal-hooks/post/letsencrypt-ejabberd-post-renewal-hook"

	### Restart nginx

	service nginx restart || true

	### Prepare APT for ejabberd installation

	aenigma-add_ejabberd_repo

	aenigma-install_ejabberd_config

	### Create ejabberd uploads directory

	echo "${b}Now creating uploads directory...${x}"
	echo
	mkdir -p /etc/ejabberd/uploads/
	echo "${b}Finished creating uploads directory.${x}"
	echo

	### Create HTTP uploads directory

	echo "${b}Now creating HTTP fileserver directory...${x}"
	echo
	mkdir -p /var/www/ejabberd/
	echo "${b}Finished creating HTTP fileserver directory.${x}"
	echo

	### Create logfile

	echo "${b}Now creating logfile...${x}"
	echo
	mkdir -p /var/log/ejabberd/
	touch /var/log/ejabberd/www_access.log
	echo "${b}Finished creating logfile.${x}"
	echo

	### Add backup script to crontab

	os-add_cron_job -n $short_name-backup -t "8 4 * * * " -c "bash /root/openspace42/$short_name/tools/$short_name-backup"

	### Install SSLH

	echo "${b}Now installing SSLH...${x}"
	echo
	/usr/sbin/service sslh stop &> /dev/null || true
	ssh_port="$(cat $os_base_dir/inception/ssh-port)"
	apt-get -y install libwrap0-dev libconfig-dev || true
	rm -r "$temp_dir/sslh" &> /dev/null || true
	git clone https://github.com/yrutschle/sslh "$temp_dir/sslh"
	( cd "$temp_dir/sslh" && make install && make && cp sslh-select /usr/local/sbin/sslh )
	sed -i "s|this_ipv4-var|${this_ipv4}|g" $source_dir/conf/sslh/etc-sslh.cfg
	if [ $ipv6_avail = "y" ]
	then
	    sed -i "s|#ipv6_comma|,|g" $source_dir/conf/sslh/etc-sslh.cfg
	    sed -i "s|#ipv6_line||g" $source_dir/conf/sslh/etc-sslh.cfg
	    sed -i "s|this_ipv6-var|${this_ipv6}|g" $source_dir/conf/sslh/etc-sslh.cfg
	else
	    sed -i "s|#ipv6_comma||g" $source_dir/conf/sslh/etc-sslh.cfg
	    sed -i "s|#ipv6_line|#|g" $source_dir/conf/sslh/etc-sslh.cfg
	fi
	sed -i "s|domain-var|${domain}|g" $source_dir/conf/sslh/etc-sslh.cfg
	sed -i "s|ssh_port-var|${ssh_port}|g" $source_dir/conf/sslh/etc-sslh.cfg
	cp $source_dir/conf/sslh/etc-sslh.cfg /etc/sslh.cfg
	cp $source_dir/conf/sslh/etc-init.d.sslh /etc/init.d/sslh
	chmod +x /etc/init.d/sslh
	update-rc.d sslh defaults
	systemctl daemon-reload
	rm -r "$temp_dir/sslh"
	mkdir -p /var/run/sslh
	touch /var/run/sslh/sslh.pid
	service sslh restart || true
	echo
	echo "${b}Finished installing SSLH.${x}"
	echo

	### Ensure DPKG is available before proceeding

	os-check_dpkg_availability

	### Actually install ejabberd

	echo "${b}Now installing ejabberd...${x}"
	echo
	export DEBIAN_FRONTEND=noninteractive ; apt-get install -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --force-yes ejabberd || true
	echo
	echo "${b}Finished installing ejabberd.${x}"
	echo

	### Secure permissions

	echo "${b}Now securing permissions...${x}"
	echo

	chown -R ejabberd:ejabberd $tls_dir
	chmod -R 700 $tls_dir

	chown -R ejabberd:ejabberd /etc/ejabberd/uploads/
	chmod -R 755 /etc/ejabberd/uploads/

	chown -R ejabberd:ejabberd /var/www/ejabberd/
	chmod -R 755 /var/www/ejabberd/

	echo "${b}Finished securing permissions.${x}"
	echo

	### Restart ejabberd and ensure it correctly comes up

	echo "${b}Now stopping ejabberd...${x}"
	echo
	/usr/sbin/service ejabberd stop
	sleep 8
	echo "${b}Finished stopping ejabberd.${x}"
	echo

	### Perform some changes on the ejabberd config file



	echo "${b}Now starting ejabberd...${x}"
	/usr/sbin/service ejabberd start
	echo
	sleep 8
	/usr/sbin/ejabberdctl status
	echo
	echo "${b}Finished starting ejabberd.${x}"
	echo

	### Register ejabberd admin user

	echo "${b}Now registering ejabberd admin user [if it doesn't yet exist]...${x}"
	echo
	ejab_admin_pw=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)
	/usr/sbin/ejabberdctl register admin "$domain" "$ejab_admin_pw" &> /dev/null || true
	echo "${b}Finished registering ejabberd admin user.${x}"
	echo
	clear

	if [ -f $conf_dir/ejab_admin_pw_set ]
	then
	    read -rp "${b}Leave ejabberd admin user password the same as previously set? (Y/n): ${x}" -n 1
	    echo
	    if [[ ! $REPLY =~ ^[Nn]$ ]]
	    then
	        echo "${b}Skipping ejabberd admin user password reset.${x}"
	        echo
	        ejab_admin_pwreset=n
	    else
	        echo
	        echo "${b}Ok, resetting ejabberd admin user password to: | $ejab_admin_pw | ${x}"
	        echo
	        /usr/sbin/ejabberdctl change_password admin "$domain" "$ejab_admin_pw"
	        ejab_admin_pwreset=y
	    fi
	else
	    touch $conf_dir/ejab_admin_pw_set
	    ejab_admin_pwreset=y
	fi

	### Update ejabberd's module repo

	echo "${b}Now updating ejabberd's module repo...${x}"
	echo
	set +e
	/usr/sbin/ejabberdctl modules_update_specs
	set -e
	echo "${b}Finished updating ejabberd's module repo...${x}"
	echo

	### Create shared roster groups

	echo "${b}Now creating 'ADMIN:EVERYBODY' and 'ADMIN:ONLINE' shared roster groups [admin@$domain can see 'everybody' and 'all online']...${x}"
	echo
	/usr/sbin/ejabberdctl srg_create everybody "$domain" "everybody [$domain]" "This aenigma group includes every user on this domain" ""
	/usr/sbin/ejabberdctl srg-user-add @all@ localhost everybody "$domain"
	/usr/sbin/ejabberdctl srg_create online "$domain" "online [$domain]" "This aenigma group includes every user who is online on this domain" ""
	/usr/sbin/ejabberdctl srg-user-add @online@ localhost online "$domain"
	/usr/sbin/ejabberdctl srg_create admin "$domain" admin "This is a shared roster group set by aenigma" "everybody\\nonline"
	/usr/sbin/ejabberdctl srg-user-add admin "$domain" admin "$domain"
	echo "${b}Finished creating shared roster groups.${x}"
	echo
	clear

	### Run a generic APT operation to catch its output and alert the user if something has gone wrong

	echo "${b}Now performing a final run of APT to ensure all package installations have completed successfully...${x}"
	echo
	set +e
	if apt-get -y upgrade
	then
	    echo
	    echo "${g}${b}All APT package installations completed successfully...${x}"
	    echo
	else
	    echo
	    echo "${r}${b}An error has occured during APT operations.${x}"
	    echo
	    echo "${b}This was the last step in this installation, so it's possible your end result is at least partially working.${x}"
	    echo
	    echo "${b}Please review the above log and try running the installation again. If necessary open an issue on github. Thank you.${x}"
	    echo
	    read -rp "${b}[press enter to continue reading...]${x}"
	fi
	set -e
	clear

	### Run an nginx restart to catch its output and alert the user if something has gone wrong

	echo "${b}Now performing a final restart of nginx to ensure all related installations have completed successfully...${x}"
	echo
	set +e
	if service nginx restart
	then
	    echo
	    echo "${g}${b}All nginx installations completed successfully...${x}"
	    echo
	else
	    echo
	    echo "${r}${b}An error has occured during nginx operations.${x}"
	    echo
	    echo "${b}This was the last step in this installation, so it's possible your end result is at least partially working.${x}"
	    echo
	    echo "${b}Please review the above log and try running the installation again. If necessary open an issue on github. Thank you.${x}"
	    echo
	    read -rp "${b}[press enter to continue reading...]${x}"
	fi
	set -e
	clear

	### Run an sslh restart to catch its output and alert the user if something has gone wrong

	echo "${b}Now performing a final restart of nginx to ensure all related installations have completed successfully...${x}"
	echo
	set +e
	if service sslh restart
	then
	    echo
	    echo "${g}${b}All sslh installations completed successfully...${x}"
	    echo
	else
	    echo
	    echo "${r}${b}An error has occured during sslh operations.${x}"
	    echo
	    echo "${b}This was the last step in this installation, so it's possible your end result is at least partially working.${x}"
	    echo
	    echo "${b}Please review the above log and try running the installation again. If necessary open an issue on github. Thank you.${x}"
	    echo
	    read -rp "${b}[press enter to continue reading...]${x}"
	fi
	set -e
	clear

	### Pring login information and credentials

	echo "${g}${b}You can finally log in:${x}"
	echo
	echo "${b}https://$hostname${x}"
	echo
	echo "${b}admin@$domain${x}"
	echo

	if [ $ejab_admin_pwreset = "y" ]
	then
	    echo "${b}$ejab_admin_pw${x}"
	    echo
	else
	    echo "${b}[your previously set password]${x}"
	    echo
	fi

	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	### Generate aenigma-specific DHparam file

	os-generate_project_specific_dhparam

	############################################################################
	############################################################################
	############################################################################

}

################################################################################
