#!/bin/bash

r=$(tput setaf 1)
g=$(tput setaf 2)
l=$(tput setaf 4)
m=$(tput setaf 5)
x=$(tput sgr0)
b=$(tput bold)

# All in One Bash Logger | v0.51 | 20171018 | 20171214 | Nk

scriptname=$(basename "$0")                                             # The name of this script
now="$(date +"%Y-%m-%d_%H-%M-%S")"                                      # The current timestamp
logdir="$HOME/logs/$scriptname"                                         # Don't store anything else than logs in here!
logfile="$logdir/$now"                                                  # The new logfile
if [[ -t 1 ]]; then interactive=y; else interactive=n; fi               # Determine if this is an interactive shell
mkdir -p "$logdir"                                                      # Touch the dir
touch "$logfile"                                                        # Touch the file
if [ -f "$logdir"/latest-log ]; then rm "$logdir"/latest-log; fi        # Remove the old latest-log symlink
ln -s "$logfile" "$logdir"/latest-log                                   # Recreate the symlink
( cd "$logdir" && rm "$(ls -t | awk 'NR>43')" ) 2> /dev/null || true    # Delete all logs older than the newest 42
exec >  >(tee -ia "$logfile")                                           # Log stdout to logfile
if [ $interactive = "n" ]; then exec 2> >(tee -ia "$logfile" >&2); fi   # Log stderr to logfile if non-interactive
echo && echo "Starting $scriptname script on $now..." && echo           # Write heading to logfile
chmod -R 700 "$logdir"                                                  # Secure logs directory

sourcedir=/root/aenigma # Don't change! | No trailing slash!
basedir=/root/openspace42 # Don't change! | No trailing slash!
installdir=$basedir/aenigma # Don't change! | No trailing slash!
configdir=$installdir/config # Don't change! | No trailing slash!
toolsdir=$installdir/tools # Don't change! | No trailing slash!
backupsdir=$installdir/backups # Don't change! | No trailing slash!
localbackupsdir=$backupsdir/local # Don't change! | No trailing slash!
s3backupsdir=$backupsdir/s3 # Don't change! | No trailing slash!
restoresdir=$installdir/restores # Don't change! | No trailing slash!
tlsdir=/etc/ssl/aenigma # Don't change! | No trailing slash!
tmpdir=/tmp/aenigma # Don't change! | No trailing slash!

if [[ $EUID -ne 0 ]]
then
	echo "${r}${b}This script must be run as root. Run it as:${x}"
	echo
	echo "sudo bash aenigma/install.sh"
	echo
        # Send email indicating backup aborted
        echo "${b}Exiting...${x}"
        echo
        exit
fi

if [ ! -f $configdir/installcomplete ]
then
        echo "It appears aenigma is not currently installed or there is an incomplete installation on this machine."
        echo
        echo "This backup script only works on a fully installed aenigma instance."
        echo
        echo "Please finish installing aenigma before running this script."
        echo
        # Send email indicating backup aborted
        echo "${b}Exiting...${x}"
        echo
        exit
fi

if [ -f $configdir/blocks3backups ]
then
        echo "${r}${b}NOT performing backup as $configdir/blocks3backups file found.${x}"
        echo
        echo "${b}This should indicate that during the initial installation script you specified your intent to use this machine as a restore for a previous backup on S3.${x}"
        echo
        echo "${b}If this is the case, simply run the restore script right away. If it is not, and you want to use this machine for a new installation and OVERWRITE all backups currently on S3, erase this file: $configdir/blocks3backups.${x}"
        echo
        echo "${r}${b}NO backups will run on this instance until you perform the restore script or remove the file to specify your intent to use this machine as it is for a new installation.${x}"
        echo
        # Send email indicating backup aborted
        echo "${b}Exiting...${x}"
        echo
        exit
fi



rm -r ${tmpdir:?}/* 2> /dev/null
mkdir -p $localbackupsdir
mkdir -p $s3backupsdir
mkdir -p $tmpdir
backupname=aenigma-backup-$now
tmpbackupdir=$tmpdir/$backupname
mkdir -p "$tmpbackupdir"



echo "Now backing up locally..."
echo

# Purge backups older than the latest 42
( cd $localbackupsdir && rm "$(ls -t | awk 'NR>42')" ) 2> /dev/null || true

/usr/sbin/ejabberdctl backup /tmp/ejabberd-mnesia-backup
mv /tmp/ejabberd-mnesia-backup "$tmpbackupdir"/ejabberd-mnesia-backup
cp -r /etc/ejabberd/ "$tmpbackupdir"/etc-ejabberd/
cp -r /var/lib/ejabberd/ "$tmpbackupdir"/var-lib-ejabberd/
cp -r "$configdir" "$tmpbackupdir"/config/
cd $tmpdir || exit
tar -cvjSf "$localbackupsdir"/"$backupname".tar.bz2 "$backupname"
echo

echo
echo "Backed up to $localbackupsdir/."
echo



backuptype="$(cat $configdir/backuptype)"

if [ "$backuptype" = "s3" ]
then

        echo "Now backing up to S3..."
        echo

        rsync -aAXxv "$tmpbackupdir"/* "$s3backupsdir"/
        echo

        awsaki="$(cat $configdir/s3/awsaki)"
        awssak="$(cat $configdir/s3/awssak)"
        s3endpoint="$(cat $configdir/s3/s3endpoint)"
        s3bucketname="$(cat $configdir/s3/s3bucketname)"

        # Export some ENV variables so you don't have to type anything
        export AWS_ACCESS_KEY_ID=$awsaki
        export AWS_SECRET_ACCESS_KEY=$awssak
        export PASSPHRASE=$configdir/backupspw

        # Your GPG key
        #GPG_KEY= # Insert GPG key here if using GPG

        # The S3 destination followed by bucket name
        DEST="s3://$s3endpoint/$s3bucketname/"

	duplicitylogdir=/root/logs/aenigma-duplicity
	duplicitybckplogdir=$duplicitylogdir/backup

        # Set up some variables for logging
        LOGFILE="$duplicitybckplogdir/backup.log"
        DAILYLOGFILE="$duplicitybckplogdir/backup.daily.log"
        FULLBACKLOGFILE="$duplicitybckplogdir/backup.full.log"
        HOST=$(hostname)
        DATE=$(date +%Y-%m-%d)
        MAILADDR="$(cat $configdir/adminmail)"
        TODAY=$(date +%d%m%Y)

        is_running=$(ps -ef | grep duplicity  | grep python | wc -l)

        if [ ! -d $duplicitybckplogdir ]
        then
                mkdir -p $duplicitybckplogdir
        fi

        if [ ! -f $FULLBACKLOGFILE ]
        then
                touch $FULLBACKLOGFILE
        fi

        if [ "$is_running" -eq 0 ]
        then
                # Clear the old daily log file
                cat /dev/null > ${DAILYLOGFILE}

                # Trace function for logging, don't change this
                trace () {
                        stamp=$(date +%Y-%m-%d_%H:%M:%S)
                        echo "$stamp: $*" >> ${DAILYLOGFILE}
                }

                # How long to keep backups for
                OLDER_THAN="1M"

                # The source of your backup
                SOURCE=$s3backupsdir/ # Use / for full system backup [not the case for aenigma]

                FULL=
                tail -1 "${FULLBACKLOGFILE}" | grep "${TODAY}" > /dev/null || true
                if [ $? -ne 0 -a "$(date +%d)" -eq 1 ]
                then
                        FULL=full
                fi;

                trace "Backup for local filesystem started"

                trace "... removing old backups"

                duplicity remove-older-than "${OLDER_THAN}" "${DEST}" >> "${DAILYLOGFILE}" 2>&1  || true

                trace "... backing up filesystem"

                #    duplicity \
                #        ${FULL} \
                #        --encrypt-key=${GPG_KEY} \
                #        --sign-key=${GPG_KEY} \
                #        --include=/var/rsnap-mysql \
                #        --include=/var/www \
                #        --include=/etc \
                #        --exclude=/** \
                #        ${SOURCE} ${DEST} >> ${DAILYLOGFILE} 2>&1

                duplicity "${FULL}" "${SOURCE}" "${DEST}" # Insert --encrypt-key and --sign-key after ${FULL} if using GPG

                trace "Backup for local filesystem complete"
                trace "------------------------------------"

                # Send the daily log file by email
                #cat "$DAILYLOGFILE" | mail -s "Duplicity Backup Log for $HOST - $DATE" $MAILADDR
                #BACKUPSTATUS=`cat "$DAILYLOGFILE" | grep Errors | awk '{ print $2 }'`
                BACKUPSTATUS=$(cat "$DAILYLOGFILE" | grep -i error | wc -l)
                if [ "$BACKUPSTATUS" != "0" ]
                then
                        cat "$DAILYLOGFILE" | mail -aFrom:"aenigma@$HOST" -s "ERROR in aenigma backup for $HOST on $DATE" "$MAILADDR"
                elif [ "$FULL" = "full" ]
                then
                        echo "$(date +%d%m%Y_%T) Full Back Done" >> $FULLBACKLOGFILE
                fi

                # Append the daily log file to the main log file
                cat "$DAILYLOGFILE" >> $LOGFILE

                # Reset the ENV variables. Don't need them sitting around
                unset AWS_ACCESS_KEY_ID
                unset AWS_SECRET_ACCESS_KEY
                unset PASSPHRASE

        fi

fi

rm -r "$tmpbackupdir"
rm -r ${tmpdir:?}/* 2> /dev/null || true

echo end
